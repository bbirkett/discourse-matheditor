var global, factory;
(global = this),
  (factory = function () {
    var t = {
      "AMS-Regular": {
        65: [0, 0.68889, 0, 0],
        66: [0, 0.68889, 0, 0],
        67: [0, 0.68889, 0, 0],
        68: [0, 0.68889, 0, 0],
        69: [0, 0.68889, 0, 0],
        70: [0, 0.68889, 0, 0],
        71: [0, 0.68889, 0, 0],
        72: [0, 0.68889, 0, 0],
        73: [0, 0.68889, 0, 0],
        74: [0.16667, 0.68889, 0, 0],
        75: [0, 0.68889, 0, 0],
        76: [0, 0.68889, 0, 0],
        77: [0, 0.68889, 0, 0],
        78: [0, 0.68889, 0, 0],
        79: [0.16667, 0.68889, 0, 0],
        80: [0, 0.68889, 0, 0],
        81: [0.16667, 0.68889, 0, 0],
        82: [0, 0.68889, 0, 0],
        83: [0, 0.68889, 0, 0],
        84: [0, 0.68889, 0, 0],
        85: [0, 0.68889, 0, 0],
        86: [0, 0.68889, 0, 0],
        87: [0, 0.68889, 0, 0],
        88: [0, 0.68889, 0, 0],
        89: [0, 0.68889, 0, 0],
        90: [0, 0.68889, 0, 0],
        107: [0, 0.68889, 0, 0],
        165: [0, 0.675, 0.025, 0],
        174: [0.15559, 0.69224, 0, 0],
        240: [0, 0.68889, 0, 0],
        295: [0, 0.68889, 0, 0],
        710: [0, 0.825, 0, 0],
        732: [0, 0.9, 0, 0],
        770: [0, 0.825, 0, 0],
        771: [0, 0.9, 0, 0],
        989: [0.08167, 0.58167, 0, 0],
        1008: [0, 0.43056, 0.04028, 0],
        8245: [0, 0.54986, 0, 0],
        8463: [0, 0.68889, 0, 0],
        8487: [0, 0.68889, 0, 0],
        8498: [0, 0.68889, 0, 0],
        8502: [0, 0.68889, 0, 0],
        8503: [0, 0.68889, 0, 0],
        8504: [0, 0.68889, 0, 0],
        8513: [0, 0.68889, 0, 0],
        8592: [-0.03598, 0.46402, 0, 0],
        8594: [-0.03598, 0.46402, 0, 0],
        8602: [-0.13313, 0.36687, 0, 0],
        8603: [-0.13313, 0.36687, 0, 0],
        8606: [0.01354, 0.52239, 0, 0],
        8608: [0.01354, 0.52239, 0, 0],
        8610: [0.01354, 0.52239, 0, 0],
        8611: [0.01354, 0.52239, 0, 0],
        8619: [0, 0.54986, 0, 0],
        8620: [0, 0.54986, 0, 0],
        8621: [-0.13313, 0.37788, 0, 0],
        8622: [-0.13313, 0.36687, 0, 0],
        8624: [0, 0.69224, 0, 0],
        8625: [0, 0.69224, 0, 0],
        8630: [0, 0.43056, 0, 0],
        8631: [0, 0.43056, 0, 0],
        8634: [0.08198, 0.58198, 0, 0],
        8635: [0.08198, 0.58198, 0, 0],
        8638: [0.19444, 0.69224, 0, 0],
        8639: [0.19444, 0.69224, 0, 0],
        8642: [0.19444, 0.69224, 0, 0],
        8643: [0.19444, 0.69224, 0, 0],
        8644: [0.1808, 0.675, 0, 0],
        8646: [0.1808, 0.675, 0, 0],
        8647: [0.1808, 0.675, 0, 0],
        8648: [0.19444, 0.69224, 0, 0],
        8649: [0.1808, 0.675, 0, 0],
        8650: [0.19444, 0.69224, 0, 0],
        8651: [0.01354, 0.52239, 0, 0],
        8652: [0.01354, 0.52239, 0, 0],
        8653: [-0.13313, 0.36687, 0, 0],
        8654: [-0.13313, 0.36687, 0, 0],
        8655: [-0.13313, 0.36687, 0, 0],
        8666: [0.13667, 0.63667, 0, 0],
        8667: [0.13667, 0.63667, 0, 0],
        8669: [-0.13313, 0.37788, 0, 0],
        8672: [-0.064, 0.437, 0, 0],
        8674: [-0.064, 0.437, 0, 0],
        8705: [0, 0.825, 0, 0],
        8708: [0, 0.68889, 0, 0],
        8709: [0.08167, 0.58167, 0, 0],
        8717: [0, 0.43056, 0, 0],
        8722: [-0.03598, 0.46402, 0, 0],
        8724: [0.08198, 0.69224, 0, 0],
        8726: [0.08167, 0.58167, 0, 0],
        8733: [0, 0.69224, 0, 0],
        8736: [0, 0.69224, 0, 0],
        8737: [0, 0.69224, 0, 0],
        8738: [0.03517, 0.52239, 0, 0],
        8739: [0.08167, 0.58167, 0, 0],
        8740: [0.25142, 0.74111, 0, 0],
        8741: [0.08167, 0.58167, 0, 0],
        8742: [0.25142, 0.74111, 0, 0],
        8756: [0, 0.69224, 0, 0],
        8757: [0, 0.69224, 0, 0],
        8764: [-0.13313, 0.36687, 0, 0],
        8765: [-0.13313, 0.37788, 0, 0],
        8769: [-0.13313, 0.36687, 0, 0],
        8770: [-0.03625, 0.46375, 0, 0],
        8774: [0.30274, 0.79383, 0, 0],
        8776: [-0.01688, 0.48312, 0, 0],
        8778: [0.08167, 0.58167, 0, 0],
        8782: [0.06062, 0.54986, 0, 0],
        8783: [0.06062, 0.54986, 0, 0],
        8785: [0.08198, 0.58198, 0, 0],
        8786: [0.08198, 0.58198, 0, 0],
        8787: [0.08198, 0.58198, 0, 0],
        8790: [0, 0.69224, 0, 0],
        8791: [0.22958, 0.72958, 0, 0],
        8796: [0.08198, 0.91667, 0, 0],
        8806: [0.25583, 0.75583, 0, 0],
        8807: [0.25583, 0.75583, 0, 0],
        8808: [0.25142, 0.75726, 0, 0],
        8809: [0.25142, 0.75726, 0, 0],
        8812: [0.25583, 0.75583, 0, 0],
        8814: [0.20576, 0.70576, 0, 0],
        8815: [0.20576, 0.70576, 0, 0],
        8816: [0.30274, 0.79383, 0, 0],
        8817: [0.30274, 0.79383, 0, 0],
        8818: [0.22958, 0.72958, 0, 0],
        8819: [0.22958, 0.72958, 0, 0],
        8822: [0.1808, 0.675, 0, 0],
        8823: [0.1808, 0.675, 0, 0],
        8828: [0.13667, 0.63667, 0, 0],
        8829: [0.13667, 0.63667, 0, 0],
        8830: [0.22958, 0.72958, 0, 0],
        8831: [0.22958, 0.72958, 0, 0],
        8832: [0.20576, 0.70576, 0, 0],
        8833: [0.20576, 0.70576, 0, 0],
        8840: [0.30274, 0.79383, 0, 0],
        8841: [0.30274, 0.79383, 0, 0],
        8842: [0.13597, 0.63597, 0, 0],
        8843: [0.13597, 0.63597, 0, 0],
        8847: [0.03517, 0.54986, 0, 0],
        8848: [0.03517, 0.54986, 0, 0],
        8858: [0.08198, 0.58198, 0, 0],
        8859: [0.08198, 0.58198, 0, 0],
        8861: [0.08198, 0.58198, 0, 0],
        8862: [0, 0.675, 0, 0],
        8863: [0, 0.675, 0, 0],
        8864: [0, 0.675, 0, 0],
        8865: [0, 0.675, 0, 0],
        8872: [0, 0.69224, 0, 0],
        8873: [0, 0.69224, 0, 0],
        8874: [0, 0.69224, 0, 0],
        8876: [0, 0.68889, 0, 0],
        8877: [0, 0.68889, 0, 0],
        8878: [0, 0.68889, 0, 0],
        8879: [0, 0.68889, 0, 0],
        8882: [0.03517, 0.54986, 0, 0],
        8883: [0.03517, 0.54986, 0, 0],
        8884: [0.13667, 0.63667, 0, 0],
        8885: [0.13667, 0.63667, 0, 0],
        8888: [0, 0.54986, 0, 0],
        8890: [0.19444, 0.43056, 0, 0],
        8891: [0.19444, 0.69224, 0, 0],
        8892: [0.19444, 0.69224, 0, 0],
        8901: [0, 0.54986, 0, 0],
        8903: [0.08167, 0.58167, 0, 0],
        8905: [0.08167, 0.58167, 0, 0],
        8906: [0.08167, 0.58167, 0, 0],
        8907: [0, 0.69224, 0, 0],
        8908: [0, 0.69224, 0, 0],
        8909: [-0.03598, 0.46402, 0, 0],
        8910: [0, 0.54986, 0, 0],
        8911: [0, 0.54986, 0, 0],
        8912: [0.03517, 0.54986, 0, 0],
        8913: [0.03517, 0.54986, 0, 0],
        8914: [0, 0.54986, 0, 0],
        8915: [0, 0.54986, 0, 0],
        8916: [0, 0.69224, 0, 0],
        8918: [0.0391, 0.5391, 0, 0],
        8919: [0.0391, 0.5391, 0, 0],
        8920: [0.03517, 0.54986, 0, 0],
        8921: [0.03517, 0.54986, 0, 0],
        8922: [0.38569, 0.88569, 0, 0],
        8923: [0.38569, 0.88569, 0, 0],
        8926: [0.13667, 0.63667, 0, 0],
        8927: [0.13667, 0.63667, 0, 0],
        8928: [0.30274, 0.79383, 0, 0],
        8929: [0.30274, 0.79383, 0, 0],
        8934: [0.23222, 0.74111, 0, 0],
        8935: [0.23222, 0.74111, 0, 0],
        8936: [0.23222, 0.74111, 0, 0],
        8937: [0.23222, 0.74111, 0, 0],
        8938: [0.20576, 0.70576, 0, 0],
        8939: [0.20576, 0.70576, 0, 0],
        8940: [0.30274, 0.79383, 0, 0],
        8941: [0.30274, 0.79383, 0, 0],
        8994: [0.19444, 0.69224, 0, 0],
        8995: [0.19444, 0.69224, 0, 0],
        9416: [0.15559, 0.69224, 0, 0],
        9484: [0, 0.69224, 0, 0],
        9488: [0, 0.69224, 0, 0],
        9492: [0, 0.37788, 0, 0],
        9496: [0, 0.37788, 0, 0],
        9585: [0.19444, 0.68889, 0, 0],
        9586: [0.19444, 0.74111, 0, 0],
        9632: [0, 0.675, 0, 0],
        9633: [0, 0.675, 0, 0],
        9650: [0, 0.54986, 0, 0],
        9651: [0, 0.54986, 0, 0],
        9654: [0.03517, 0.54986, 0, 0],
        9660: [0, 0.54986, 0, 0],
        9661: [0, 0.54986, 0, 0],
        9664: [0.03517, 0.54986, 0, 0],
        9674: [0.11111, 0.69224, 0, 0],
        9733: [0.19444, 0.69224, 0, 0],
        10003: [0, 0.69224, 0, 0],
        10016: [0, 0.69224, 0, 0],
        10731: [0.11111, 0.69224, 0, 0],
        10846: [0.19444, 0.75583, 0, 0],
        10877: [0.13667, 0.63667, 0, 0],
        10878: [0.13667, 0.63667, 0, 0],
        10885: [0.25583, 0.75583, 0, 0],
        10886: [0.25583, 0.75583, 0, 0],
        10887: [0.13597, 0.63597, 0, 0],
        10888: [0.13597, 0.63597, 0, 0],
        10889: [0.26167, 0.75726, 0, 0],
        10890: [0.26167, 0.75726, 0, 0],
        10891: [0.48256, 0.98256, 0, 0],
        10892: [0.48256, 0.98256, 0, 0],
        10901: [0.13667, 0.63667, 0, 0],
        10902: [0.13667, 0.63667, 0, 0],
        10933: [0.25142, 0.75726, 0, 0],
        10934: [0.25142, 0.75726, 0, 0],
        10935: [0.26167, 0.75726, 0, 0],
        10936: [0.26167, 0.75726, 0, 0],
        10937: [0.26167, 0.75726, 0, 0],
        10938: [0.26167, 0.75726, 0, 0],
        10949: [0.25583, 0.75583, 0, 0],
        10950: [0.25583, 0.75583, 0, 0],
        10955: [0.28481, 0.79383, 0, 0],
        10956: [0.28481, 0.79383, 0, 0],
        57350: [0.08167, 0.58167, 0, 0],
        57351: [0.08167, 0.58167, 0, 0],
        57352: [0.08167, 0.58167, 0, 0],
        57353: [0, 0.43056, 0.04028, 0],
        57356: [0.25142, 0.75726, 0, 0],
        57357: [0.25142, 0.75726, 0, 0],
        57358: [0.41951, 0.91951, 0, 0],
        57359: [0.30274, 0.79383, 0, 0],
        57360: [0.30274, 0.79383, 0, 0],
        57361: [0.41951, 0.91951, 0, 0],
        57366: [0.25142, 0.75726, 0, 0],
        57367: [0.25142, 0.75726, 0, 0],
        57368: [0.25142, 0.75726, 0, 0],
        57369: [0.25142, 0.75726, 0, 0],
        57370: [0.13597, 0.63597, 0, 0],
        57371: [0.13597, 0.63597, 0, 0],
      },
      "Caligraphic-Regular": {
        48: [0, 0.43056, 0, 0],
        49: [0, 0.43056, 0, 0],
        50: [0, 0.43056, 0, 0],
        51: [0.19444, 0.43056, 0, 0],
        52: [0.19444, 0.43056, 0, 0],
        53: [0.19444, 0.43056, 0, 0],
        54: [0, 0.64444, 0, 0],
        55: [0.19444, 0.43056, 0, 0],
        56: [0, 0.64444, 0, 0],
        57: [0.19444, 0.43056, 0, 0],
        65: [0, 0.68333, 0, 0.19445],
        66: [0, 0.68333, 0.03041, 0.13889],
        67: [0, 0.68333, 0.05834, 0.13889],
        68: [0, 0.68333, 0.02778, 0.08334],
        69: [0, 0.68333, 0.08944, 0.11111],
        70: [0, 0.68333, 0.09931, 0.11111],
        71: [0.09722, 0.68333, 0.0593, 0.11111],
        72: [0, 0.68333, 0.00965, 0.11111],
        73: [0, 0.68333, 0.07382, 0],
        74: [0.09722, 0.68333, 0.18472, 0.16667],
        75: [0, 0.68333, 0.01445, 0.05556],
        76: [0, 0.68333, 0, 0.13889],
        77: [0, 0.68333, 0, 0.13889],
        78: [0, 0.68333, 0.14736, 0.08334],
        79: [0, 0.68333, 0.02778, 0.11111],
        80: [0, 0.68333, 0.08222, 0.08334],
        81: [0.09722, 0.68333, 0, 0.11111],
        82: [0, 0.68333, 0, 0.08334],
        83: [0, 0.68333, 0.075, 0.13889],
        84: [0, 0.68333, 0.25417, 0],
        85: [0, 0.68333, 0.09931, 0.08334],
        86: [0, 0.68333, 0.08222, 0],
        87: [0, 0.68333, 0.08222, 0.08334],
        88: [0, 0.68333, 0.14643, 0.13889],
        89: [0.09722, 0.68333, 0.08222, 0.08334],
        90: [0, 0.68333, 0.07944, 0.13889],
      },
      "Fraktur-Regular": {
        33: [0, 0.69141, 0, 0],
        34: [0, 0.69141, 0, 0],
        38: [0, 0.69141, 0, 0],
        39: [0, 0.69141, 0, 0],
        40: [0.24982, 0.74947, 0, 0],
        41: [0.24982, 0.74947, 0, 0],
        42: [0, 0.62119, 0, 0],
        43: [0.08319, 0.58283, 0, 0],
        44: [0, 0.10803, 0, 0],
        45: [0.08319, 0.58283, 0, 0],
        46: [0, 0.10803, 0, 0],
        47: [0.24982, 0.74947, 0, 0],
        48: [0, 0.47534, 0, 0],
        49: [0, 0.47534, 0, 0],
        50: [0, 0.47534, 0, 0],
        51: [0.18906, 0.47534, 0, 0],
        52: [0.18906, 0.47534, 0, 0],
        53: [0.18906, 0.47534, 0, 0],
        54: [0, 0.69141, 0, 0],
        55: [0.18906, 0.47534, 0, 0],
        56: [0, 0.69141, 0, 0],
        57: [0.18906, 0.47534, 0, 0],
        58: [0, 0.47534, 0, 0],
        59: [0.12604, 0.47534, 0, 0],
        61: [-0.13099, 0.36866, 0, 0],
        63: [0, 0.69141, 0, 0],
        65: [0, 0.69141, 0, 0],
        66: [0, 0.69141, 0, 0],
        67: [0, 0.69141, 0, 0],
        68: [0, 0.69141, 0, 0],
        69: [0, 0.69141, 0, 0],
        70: [0.12604, 0.69141, 0, 0],
        71: [0, 0.69141, 0, 0],
        72: [0.06302, 0.69141, 0, 0],
        73: [0, 0.69141, 0, 0],
        74: [0.12604, 0.69141, 0, 0],
        75: [0, 0.69141, 0, 0],
        76: [0, 0.69141, 0, 0],
        77: [0, 0.69141, 0, 0],
        78: [0, 0.69141, 0, 0],
        79: [0, 0.69141, 0, 0],
        80: [0.18906, 0.69141, 0, 0],
        81: [0.03781, 0.69141, 0, 0],
        82: [0, 0.69141, 0, 0],
        83: [0, 0.69141, 0, 0],
        84: [0, 0.69141, 0, 0],
        85: [0, 0.69141, 0, 0],
        86: [0, 0.69141, 0, 0],
        87: [0, 0.69141, 0, 0],
        88: [0, 0.69141, 0, 0],
        89: [0.18906, 0.69141, 0, 0],
        90: [0.12604, 0.69141, 0, 0],
        91: [0.24982, 0.74947, 0, 0],
        93: [0.24982, 0.74947, 0, 0],
        94: [0, 0.69141, 0, 0],
        97: [0, 0.47534, 0, 0],
        98: [0, 0.69141, 0, 0],
        99: [0, 0.47534, 0, 0],
        100: [0, 0.62119, 0, 0],
        101: [0, 0.47534, 0, 0],
        102: [0.18906, 0.69141, 0, 0],
        103: [0.18906, 0.47534, 0, 0],
        104: [0.18906, 0.69141, 0, 0],
        105: [0, 0.69141, 0, 0],
        106: [0, 0.69141, 0, 0],
        107: [0, 0.69141, 0, 0],
        108: [0, 0.69141, 0, 0],
        109: [0, 0.47534, 0, 0],
        110: [0, 0.47534, 0, 0],
        111: [0, 0.47534, 0, 0],
        112: [0.18906, 0.52396, 0, 0],
        113: [0.18906, 0.47534, 0, 0],
        114: [0, 0.47534, 0, 0],
        115: [0, 0.47534, 0, 0],
        116: [0, 0.62119, 0, 0],
        117: [0, 0.47534, 0, 0],
        118: [0, 0.52396, 0, 0],
        119: [0, 0.52396, 0, 0],
        120: [0.18906, 0.47534, 0, 0],
        121: [0.18906, 0.47534, 0, 0],
        122: [0.18906, 0.47534, 0, 0],
        8216: [0, 0.69141, 0, 0],
        8217: [0, 0.69141, 0, 0],
        58112: [0, 0.62119, 0, 0],
        58113: [0, 0.62119, 0, 0],
        58114: [0.18906, 0.69141, 0, 0],
        58115: [0.18906, 0.69141, 0, 0],
        58116: [0.18906, 0.47534, 0, 0],
        58117: [0, 0.69141, 0, 0],
        58118: [0, 0.62119, 0, 0],
        58119: [0, 0.47534, 0, 0],
      },
      "Main-Bold": {
        33: [0, 0.69444, 0, 0],
        34: [0, 0.69444, 0, 0],
        35: [0.19444, 0.69444, 0, 0],
        36: [0.05556, 0.75, 0, 0],
        37: [0.05556, 0.75, 0, 0],
        38: [0, 0.69444, 0, 0],
        39: [0, 0.69444, 0, 0],
        40: [0.25, 0.75, 0, 0],
        41: [0.25, 0.75, 0, 0],
        42: [0, 0.75, 0, 0],
        43: [0.13333, 0.63333, 0, 0],
        44: [0.19444, 0.15556, 0, 0],
        45: [0, 0.44444, 0, 0],
        46: [0, 0.15556, 0, 0],
        47: [0.25, 0.75, 0, 0],
        48: [0, 0.64444, 0, 0],
        49: [0, 0.64444, 0, 0],
        50: [0, 0.64444, 0, 0],
        51: [0, 0.64444, 0, 0],
        52: [0, 0.64444, 0, 0],
        53: [0, 0.64444, 0, 0],
        54: [0, 0.64444, 0, 0],
        55: [0, 0.64444, 0, 0],
        56: [0, 0.64444, 0, 0],
        57: [0, 0.64444, 0, 0],
        58: [0, 0.44444, 0, 0],
        59: [0.19444, 0.44444, 0, 0],
        60: [0.08556, 0.58556, 0, 0],
        61: [-0.10889, 0.39111, 0, 0],
        62: [0.08556, 0.58556, 0, 0],
        63: [0, 0.69444, 0, 0],
        64: [0, 0.69444, 0, 0],
        65: [0, 0.68611, 0, 0],
        66: [0, 0.68611, 0, 0],
        67: [0, 0.68611, 0, 0],
        68: [0, 0.68611, 0, 0],
        69: [0, 0.68611, 0, 0],
        70: [0, 0.68611, 0, 0],
        71: [0, 0.68611, 0, 0],
        72: [0, 0.68611, 0, 0],
        73: [0, 0.68611, 0, 0],
        74: [0, 0.68611, 0, 0],
        75: [0, 0.68611, 0, 0],
        76: [0, 0.68611, 0, 0],
        77: [0, 0.68611, 0, 0],
        78: [0, 0.68611, 0, 0],
        79: [0, 0.68611, 0, 0],
        80: [0, 0.68611, 0, 0],
        81: [0.19444, 0.68611, 0, 0],
        82: [0, 0.68611, 0, 0],
        83: [0, 0.68611, 0, 0],
        84: [0, 0.68611, 0, 0],
        85: [0, 0.68611, 0, 0],
        86: [0, 0.68611, 0.01597, 0],
        87: [0, 0.68611, 0.01597, 0],
        88: [0, 0.68611, 0, 0],
        89: [0, 0.68611, 0.02875, 0],
        90: [0, 0.68611, 0, 0],
        91: [0.25, 0.75, 0, 0],
        92: [0.25, 0.75, 0, 0],
        93: [0.25, 0.75, 0, 0],
        94: [0, 0.69444, 0, 0],
        95: [0.31, 0.13444, 0.03194, 0],
        97: [0, 0.44444, 0, 0],
        98: [0, 0.69444, 0, 0],
        99: [0, 0.44444, 0, 0],
        100: [0, 0.69444, 0, 0],
        101: [0, 0.44444, 0, 0],
        102: [0, 0.69444, 0.10903, 0],
        103: [0.19444, 0.44444, 0.01597, 0],
        104: [0, 0.69444, 0, 0],
        105: [0, 0.69444, 0, 0],
        106: [0.19444, 0.69444, 0, 0],
        107: [0, 0.69444, 0, 0],
        108: [0, 0.69444, 0, 0],
        109: [0, 0.44444, 0, 0],
        110: [0, 0.44444, 0, 0],
        111: [0, 0.44444, 0, 0],
        112: [0.19444, 0.44444, 0, 0],
        113: [0.19444, 0.44444, 0, 0],
        114: [0, 0.44444, 0, 0],
        115: [0, 0.44444, 0, 0],
        116: [0, 0.63492, 0, 0],
        117: [0, 0.44444, 0, 0],
        118: [0, 0.44444, 0.01597, 0],
        119: [0, 0.44444, 0.01597, 0],
        120: [0, 0.44444, 0, 0],
        121: [0.19444, 0.44444, 0.01597, 0],
        122: [0, 0.44444, 0, 0],
        123: [0.25, 0.75, 0, 0],
        124: [0.25, 0.75, 0, 0],
        125: [0.25, 0.75, 0, 0],
        126: [0.35, 0.34444, 0, 0],
        168: [0, 0.69444, 0, 0],
        172: [0, 0.44444, 0, 0],
        176: [0, 0.69444, 0, 0],
        177: [0.13333, 0.63333, 0, 0],
        184: [0.17014, 0, 0, 0],
        198: [0, 0.68611, 0, 0],
        215: [0.13333, 0.63333, 0, 0],
        216: [0.04861, 0.73472, 0, 0],
        223: [0, 0.69444, 0, 0],
        230: [0, 0.44444, 0, 0],
        247: [0.13333, 0.63333, 0, 0],
        248: [0.09722, 0.54167, 0, 0],
        305: [0, 0.44444, 0, 0],
        338: [0, 0.68611, 0, 0],
        339: [0, 0.44444, 0, 0],
        567: [0.19444, 0.44444, 0, 0],
        710: [0, 0.69444, 0, 0],
        711: [0, 0.63194, 0, 0],
        713: [0, 0.59611, 0, 0],
        714: [0, 0.69444, 0, 0],
        715: [0, 0.69444, 0, 0],
        728: [0, 0.69444, 0, 0],
        729: [0, 0.69444, 0, 0],
        730: [0, 0.69444, 0, 0],
        732: [0, 0.69444, 0, 0],
        733: [0, 0.69444, 0, 0],
        915: [0, 0.68611, 0, 0],
        916: [0, 0.68611, 0, 0],
        920: [0, 0.68611, 0, 0],
        923: [0, 0.68611, 0, 0],
        926: [0, 0.68611, 0, 0],
        928: [0, 0.68611, 0, 0],
        931: [0, 0.68611, 0, 0],
        933: [0, 0.68611, 0, 0],
        934: [0, 0.68611, 0, 0],
        936: [0, 0.68611, 0, 0],
        937: [0, 0.68611, 0, 0],
        8211: [0, 0.44444, 0.03194, 0],
        8212: [0, 0.44444, 0.03194, 0],
        8216: [0, 0.69444, 0, 0],
        8217: [0, 0.69444, 0, 0],
        8220: [0, 0.69444, 0, 0],
        8221: [0, 0.69444, 0, 0],
        8224: [0.19444, 0.69444, 0, 0],
        8225: [0.19444, 0.69444, 0, 0],
        8242: [0, 0.55556, 0, 0],
        8407: [0, 0.72444, 0.15486, 0],
        8463: [0, 0.69444, 0, 0],
        8465: [0, 0.69444, 0, 0],
        8467: [0, 0.69444, 0, 0],
        8472: [0.19444, 0.44444, 0, 0],
        8476: [0, 0.69444, 0, 0],
        8501: [0, 0.69444, 0, 0],
        8592: [-0.10889, 0.39111, 0, 0],
        8593: [0.19444, 0.69444, 0, 0],
        8594: [-0.10889, 0.39111, 0, 0],
        8595: [0.19444, 0.69444, 0, 0],
        8596: [-0.10889, 0.39111, 0, 0],
        8597: [0.25, 0.75, 0, 0],
        8598: [0.19444, 0.69444, 0, 0],
        8599: [0.19444, 0.69444, 0, 0],
        8600: [0.19444, 0.69444, 0, 0],
        8601: [0.19444, 0.69444, 0, 0],
        8636: [-0.10889, 0.39111, 0, 0],
        8637: [-0.10889, 0.39111, 0, 0],
        8640: [-0.10889, 0.39111, 0, 0],
        8641: [-0.10889, 0.39111, 0, 0],
        8656: [-0.10889, 0.39111, 0, 0],
        8657: [0.19444, 0.69444, 0, 0],
        8658: [-0.10889, 0.39111, 0, 0],
        8659: [0.19444, 0.69444, 0, 0],
        8660: [-0.10889, 0.39111, 0, 0],
        8661: [0.25, 0.75, 0, 0],
        8704: [0, 0.69444, 0, 0],
        8706: [0, 0.69444, 0.06389, 0],
        8707: [0, 0.69444, 0, 0],
        8709: [0.05556, 0.75, 0, 0],
        8711: [0, 0.68611, 0, 0],
        8712: [0.08556, 0.58556, 0, 0],
        8715: [0.08556, 0.58556, 0, 0],
        8722: [0.13333, 0.63333, 0, 0],
        8723: [0.13333, 0.63333, 0, 0],
        8725: [0.25, 0.75, 0, 0],
        8726: [0.25, 0.75, 0, 0],
        8727: [-0.02778, 0.47222, 0, 0],
        8728: [-0.02639, 0.47361, 0, 0],
        8729: [-0.02639, 0.47361, 0, 0],
        8730: [0.18, 0.82, 0, 0],
        8733: [0, 0.44444, 0, 0],
        8734: [0, 0.44444, 0, 0],
        8736: [0, 0.69224, 0, 0],
        8739: [0.25, 0.75, 0, 0],
        8741: [0.25, 0.75, 0, 0],
        8743: [0, 0.55556, 0, 0],
        8744: [0, 0.55556, 0, 0],
        8745: [0, 0.55556, 0, 0],
        8746: [0, 0.55556, 0, 0],
        8747: [0.19444, 0.69444, 0.12778, 0],
        8764: [-0.10889, 0.39111, 0, 0],
        8768: [0.19444, 0.69444, 0, 0],
        8771: [0.00222, 0.50222, 0, 0],
        8776: [0.02444, 0.52444, 0, 0],
        8781: [0.00222, 0.50222, 0, 0],
        8801: [0.00222, 0.50222, 0, 0],
        8804: [0.19667, 0.69667, 0, 0],
        8805: [0.19667, 0.69667, 0, 0],
        8810: [0.08556, 0.58556, 0, 0],
        8811: [0.08556, 0.58556, 0, 0],
        8826: [0.08556, 0.58556, 0, 0],
        8827: [0.08556, 0.58556, 0, 0],
        8834: [0.08556, 0.58556, 0, 0],
        8835: [0.08556, 0.58556, 0, 0],
        8838: [0.19667, 0.69667, 0, 0],
        8839: [0.19667, 0.69667, 0, 0],
        8846: [0, 0.55556, 0, 0],
        8849: [0.19667, 0.69667, 0, 0],
        8850: [0.19667, 0.69667, 0, 0],
        8851: [0, 0.55556, 0, 0],
        8852: [0, 0.55556, 0, 0],
        8853: [0.13333, 0.63333, 0, 0],
        8854: [0.13333, 0.63333, 0, 0],
        8855: [0.13333, 0.63333, 0, 0],
        8856: [0.13333, 0.63333, 0, 0],
        8857: [0.13333, 0.63333, 0, 0],
        8866: [0, 0.69444, 0, 0],
        8867: [0, 0.69444, 0, 0],
        8868: [0, 0.69444, 0, 0],
        8869: [0, 0.69444, 0, 0],
        8900: [-0.02639, 0.47361, 0, 0],
        8901: [-0.02639, 0.47361, 0, 0],
        8902: [-0.02778, 0.47222, 0, 0],
        8968: [0.25, 0.75, 0, 0],
        8969: [0.25, 0.75, 0, 0],
        8970: [0.25, 0.75, 0, 0],
        8971: [0.25, 0.75, 0, 0],
        8994: [-0.13889, 0.36111, 0, 0],
        8995: [-0.13889, 0.36111, 0, 0],
        9651: [0.19444, 0.69444, 0, 0],
        9657: [-0.02778, 0.47222, 0, 0],
        9661: [0.19444, 0.69444, 0, 0],
        9667: [-0.02778, 0.47222, 0, 0],
        9711: [0.19444, 0.69444, 0, 0],
        9824: [0.12963, 0.69444, 0, 0],
        9825: [0.12963, 0.69444, 0, 0],
        9826: [0.12963, 0.69444, 0, 0],
        9827: [0.12963, 0.69444, 0, 0],
        9837: [0, 0.75, 0, 0],
        9838: [0.19444, 0.69444, 0, 0],
        9839: [0.19444, 0.69444, 0, 0],
        10216: [0.25, 0.75, 0, 0],
        10217: [0.25, 0.75, 0, 0],
        10815: [0, 0.68611, 0, 0],
        10927: [0.19667, 0.69667, 0, 0],
        10928: [0.19667, 0.69667, 0, 0],
        57376: [0.19444, 0.69444, 0, 0],
      },
      "Main-BoldItalic": {
        33: [0, 0.69444, 0.11417, 0],
        34: [0, 0.69444, 0.07939, 0],
        35: [0.19444, 0.69444, 0.06833, 0],
        37: [0.05556, 0.75, 0.12861, 0],
        38: [0, 0.69444, 0.08528, 0],
        39: [0, 0.69444, 0.12945, 0],
        40: [0.25, 0.75, 0.15806, 0],
        41: [0.25, 0.75, 0.03306, 0],
        42: [0, 0.75, 0.14333, 0],
        43: [0.10333, 0.60333, 0.03306, 0],
        44: [0.19444, 0.14722, 0, 0],
        45: [0, 0.44444, 0.02611, 0],
        46: [0, 0.14722, 0, 0],
        47: [0.25, 0.75, 0.15806, 0],
        48: [0, 0.64444, 0.13167, 0],
        49: [0, 0.64444, 0.13167, 0],
        50: [0, 0.64444, 0.13167, 0],
        51: [0, 0.64444, 0.13167, 0],
        52: [0.19444, 0.64444, 0.13167, 0],
        53: [0, 0.64444, 0.13167, 0],
        54: [0, 0.64444, 0.13167, 0],
        55: [0.19444, 0.64444, 0.13167, 0],
        56: [0, 0.64444, 0.13167, 0],
        57: [0, 0.64444, 0.13167, 0],
        58: [0, 0.44444, 0.06695, 0],
        59: [0.19444, 0.44444, 0.06695, 0],
        61: [-0.10889, 0.39111, 0.06833, 0],
        63: [0, 0.69444, 0.11472, 0],
        64: [0, 0.69444, 0.09208, 0],
        65: [0, 0.68611, 0, 0],
        66: [0, 0.68611, 0.0992, 0],
        67: [0, 0.68611, 0.14208, 0],
        68: [0, 0.68611, 0.09062, 0],
        69: [0, 0.68611, 0.11431, 0],
        70: [0, 0.68611, 0.12903, 0],
        71: [0, 0.68611, 0.07347, 0],
        72: [0, 0.68611, 0.17208, 0],
        73: [0, 0.68611, 0.15681, 0],
        74: [0, 0.68611, 0.145, 0],
        75: [0, 0.68611, 0.14208, 0],
        76: [0, 0.68611, 0, 0],
        77: [0, 0.68611, 0.17208, 0],
        78: [0, 0.68611, 0.17208, 0],
        79: [0, 0.68611, 0.09062, 0],
        80: [0, 0.68611, 0.0992, 0],
        81: [0.19444, 0.68611, 0.09062, 0],
        82: [0, 0.68611, 0.02559, 0],
        83: [0, 0.68611, 0.11264, 0],
        84: [0, 0.68611, 0.12903, 0],
        85: [0, 0.68611, 0.17208, 0],
        86: [0, 0.68611, 0.18625, 0],
        87: [0, 0.68611, 0.18625, 0],
        88: [0, 0.68611, 0.15681, 0],
        89: [0, 0.68611, 0.19803, 0],
        90: [0, 0.68611, 0.14208, 0],
        91: [0.25, 0.75, 0.1875, 0],
        93: [0.25, 0.75, 0.09972, 0],
        94: [0, 0.69444, 0.06709, 0],
        95: [0.31, 0.13444, 0.09811, 0],
        97: [0, 0.44444, 0.09426, 0],
        98: [0, 0.69444, 0.07861, 0],
        99: [0, 0.44444, 0.05222, 0],
        100: [0, 0.69444, 0.10861, 0],
        101: [0, 0.44444, 0.085, 0],
        102: [0.19444, 0.69444, 0.21778, 0],
        103: [0.19444, 0.44444, 0.105, 0],
        104: [0, 0.69444, 0.09426, 0],
        105: [0, 0.69326, 0.11387, 0],
        106: [0.19444, 0.69326, 0.1672, 0],
        107: [0, 0.69444, 0.11111, 0],
        108: [0, 0.69444, 0.10861, 0],
        109: [0, 0.44444, 0.09426, 0],
        110: [0, 0.44444, 0.09426, 0],
        111: [0, 0.44444, 0.07861, 0],
        112: [0.19444, 0.44444, 0.07861, 0],
        113: [0.19444, 0.44444, 0.105, 0],
        114: [0, 0.44444, 0.11111, 0],
        115: [0, 0.44444, 0.08167, 0],
        116: [0, 0.63492, 0.09639, 0],
        117: [0, 0.44444, 0.09426, 0],
        118: [0, 0.44444, 0.11111, 0],
        119: [0, 0.44444, 0.11111, 0],
        120: [0, 0.44444, 0.12583, 0],
        121: [0.19444, 0.44444, 0.105, 0],
        122: [0, 0.44444, 0.13889, 0],
        126: [0.35, 0.34444, 0.11472, 0],
        163: [0, 0.69444, 0, 0],
        168: [0, 0.69444, 0.11473, 0],
        176: [0, 0.69444, 0, 0],
        184: [0.17014, 0, 0, 0],
        198: [0, 0.68611, 0.11431, 0],
        216: [0.04861, 0.73472, 0.09062, 0],
        223: [0.19444, 0.69444, 0.09736, 0],
        230: [0, 0.44444, 0.085, 0],
        248: [0.09722, 0.54167, 0.09458, 0],
        305: [0, 0.44444, 0.09426, 0],
        338: [0, 0.68611, 0.11431, 0],
        339: [0, 0.44444, 0.085, 0],
        567: [0.19444, 0.44444, 0.04611, 0],
        710: [0, 0.69444, 0.06709, 0],
        711: [0, 0.63194, 0.08271, 0],
        713: [0, 0.59444, 0.10444, 0],
        714: [0, 0.69444, 0.08528, 0],
        715: [0, 0.69444, 0, 0],
        728: [0, 0.69444, 0.10333, 0],
        729: [0, 0.69444, 0.12945, 0],
        730: [0, 0.69444, 0, 0],
        732: [0, 0.69444, 0.11472, 0],
        733: [0, 0.69444, 0.11472, 0],
        915: [0, 0.68611, 0.12903, 0],
        916: [0, 0.68611, 0, 0],
        920: [0, 0.68611, 0.09062, 0],
        923: [0, 0.68611, 0, 0],
        926: [0, 0.68611, 0.15092, 0],
        928: [0, 0.68611, 0.17208, 0],
        931: [0, 0.68611, 0.11431, 0],
        933: [0, 0.68611, 0.10778, 0],
        934: [0, 0.68611, 0.05632, 0],
        936: [0, 0.68611, 0.10778, 0],
        937: [0, 0.68611, 0.0992, 0],
        8211: [0, 0.44444, 0.09811, 0],
        8212: [0, 0.44444, 0.09811, 0],
        8216: [0, 0.69444, 0.12945, 0],
        8217: [0, 0.69444, 0.12945, 0],
        8220: [0, 0.69444, 0.16772, 0],
        8221: [0, 0.69444, 0.07939, 0],
      },
      "Main-Italic": {
        33: [0, 0.69444, 0.12417, 0],
        34: [0, 0.69444, 0.06961, 0],
        35: [0.19444, 0.69444, 0.06616, 0],
        37: [0.05556, 0.75, 0.13639, 0],
        38: [0, 0.69444, 0.09694, 0],
        39: [0, 0.69444, 0.12417, 0],
        40: [0.25, 0.75, 0.16194, 0],
        41: [0.25, 0.75, 0.03694, 0],
        42: [0, 0.75, 0.14917, 0],
        43: [0.05667, 0.56167, 0.03694, 0],
        44: [0.19444, 0.10556, 0, 0],
        45: [0, 0.43056, 0.02826, 0],
        46: [0, 0.10556, 0, 0],
        47: [0.25, 0.75, 0.16194, 0],
        48: [0, 0.64444, 0.13556, 0],
        49: [0, 0.64444, 0.13556, 0],
        50: [0, 0.64444, 0.13556, 0],
        51: [0, 0.64444, 0.13556, 0],
        52: [0.19444, 0.64444, 0.13556, 0],
        53: [0, 0.64444, 0.13556, 0],
        54: [0, 0.64444, 0.13556, 0],
        55: [0.19444, 0.64444, 0.13556, 0],
        56: [0, 0.64444, 0.13556, 0],
        57: [0, 0.64444, 0.13556, 0],
        58: [0, 0.43056, 0.0582, 0],
        59: [0.19444, 0.43056, 0.0582, 0],
        61: [-0.13313, 0.36687, 0.06616, 0],
        63: [0, 0.69444, 0.1225, 0],
        64: [0, 0.69444, 0.09597, 0],
        65: [0, 0.68333, 0, 0],
        66: [0, 0.68333, 0.10257, 0],
        67: [0, 0.68333, 0.14528, 0],
        68: [0, 0.68333, 0.09403, 0],
        69: [0, 0.68333, 0.12028, 0],
        70: [0, 0.68333, 0.13305, 0],
        71: [0, 0.68333, 0.08722, 0],
        72: [0, 0.68333, 0.16389, 0],
        73: [0, 0.68333, 0.15806, 0],
        74: [0, 0.68333, 0.14028, 0],
        75: [0, 0.68333, 0.14528, 0],
        76: [0, 0.68333, 0, 0],
        77: [0, 0.68333, 0.16389, 0],
        78: [0, 0.68333, 0.16389, 0],
        79: [0, 0.68333, 0.09403, 0],
        80: [0, 0.68333, 0.10257, 0],
        81: [0.19444, 0.68333, 0.09403, 0],
        82: [0, 0.68333, 0.03868, 0],
        83: [0, 0.68333, 0.11972, 0],
        84: [0, 0.68333, 0.13305, 0],
        85: [0, 0.68333, 0.16389, 0],
        86: [0, 0.68333, 0.18361, 0],
        87: [0, 0.68333, 0.18361, 0],
        88: [0, 0.68333, 0.15806, 0],
        89: [0, 0.68333, 0.19383, 0],
        90: [0, 0.68333, 0.14528, 0],
        91: [0.25, 0.75, 0.1875, 0],
        93: [0.25, 0.75, 0.10528, 0],
        94: [0, 0.69444, 0.06646, 0],
        95: [0.31, 0.12056, 0.09208, 0],
        97: [0, 0.43056, 0.07671, 0],
        98: [0, 0.69444, 0.06312, 0],
        99: [0, 0.43056, 0.05653, 0],
        100: [0, 0.69444, 0.10333, 0],
        101: [0, 0.43056, 0.07514, 0],
        102: [0.19444, 0.69444, 0.21194, 0],
        103: [0.19444, 0.43056, 0.08847, 0],
        104: [0, 0.69444, 0.07671, 0],
        105: [0, 0.65536, 0.1019, 0],
        106: [0.19444, 0.65536, 0.14467, 0],
        107: [0, 0.69444, 0.10764, 0],
        108: [0, 0.69444, 0.10333, 0],
        109: [0, 0.43056, 0.07671, 0],
        110: [0, 0.43056, 0.07671, 0],
        111: [0, 0.43056, 0.06312, 0],
        112: [0.19444, 0.43056, 0.06312, 0],
        113: [0.19444, 0.43056, 0.08847, 0],
        114: [0, 0.43056, 0.10764, 0],
        115: [0, 0.43056, 0.08208, 0],
        116: [0, 0.61508, 0.09486, 0],
        117: [0, 0.43056, 0.07671, 0],
        118: [0, 0.43056, 0.10764, 0],
        119: [0, 0.43056, 0.10764, 0],
        120: [0, 0.43056, 0.12042, 0],
        121: [0.19444, 0.43056, 0.08847, 0],
        122: [0, 0.43056, 0.12292, 0],
        126: [0.35, 0.31786, 0.11585, 0],
        163: [0, 0.69444, 0, 0],
        168: [0, 0.66786, 0.10474, 0],
        176: [0, 0.69444, 0, 0],
        184: [0.17014, 0, 0, 0],
        198: [0, 0.68333, 0.12028, 0],
        216: [0.04861, 0.73194, 0.09403, 0],
        223: [0.19444, 0.69444, 0.10514, 0],
        230: [0, 0.43056, 0.07514, 0],
        248: [0.09722, 0.52778, 0.09194, 0],
        305: [0, 0.43056, 0, 0.02778],
        338: [0, 0.68333, 0.12028, 0],
        339: [0, 0.43056, 0.07514, 0],
        567: [0.19444, 0.43056, 0, 0.08334],
        710: [0, 0.69444, 0.06646, 0],
        711: [0, 0.62847, 0.08295, 0],
        713: [0, 0.56167, 0.10333, 0],
        714: [0, 0.69444, 0.09694, 0],
        715: [0, 0.69444, 0, 0],
        728: [0, 0.69444, 0.10806, 0],
        729: [0, 0.66786, 0.11752, 0],
        730: [0, 0.69444, 0, 0],
        732: [0, 0.66786, 0.11585, 0],
        733: [0, 0.69444, 0.1225, 0],
        915: [0, 0.68333, 0.13305, 0],
        916: [0, 0.68333, 0, 0],
        920: [0, 0.68333, 0.09403, 0],
        923: [0, 0.68333, 0, 0],
        926: [0, 0.68333, 0.15294, 0],
        928: [0, 0.68333, 0.16389, 0],
        931: [0, 0.68333, 0.12028, 0],
        933: [0, 0.68333, 0.11111, 0],
        934: [0, 0.68333, 0.05986, 0],
        936: [0, 0.68333, 0.11111, 0],
        937: [0, 0.68333, 0.10257, 0],
        8211: [0, 0.43056, 0.09208, 0],
        8212: [0, 0.43056, 0.09208, 0],
        8216: [0, 0.69444, 0.12417, 0],
        8217: [0, 0.69444, 0.12417, 0],
        8220: [0, 0.69444, 0.1685, 0],
        8221: [0, 0.69444, 0.06961, 0],
        8463: [0, 0.68889, 0, 0],
      },
      "Main-Regular": {
        32: [0, 0, 0, 0],
        33: [0, 0.69444, 0, 0],
        34: [0, 0.69444, 0, 0],
        35: [0.19444, 0.69444, 0, 0],
        36: [0.05556, 0.75, 0, 0],
        37: [0.05556, 0.75, 0, 0],
        38: [0, 0.69444, 0, 0],
        39: [0, 0.69444, 0, 0],
        40: [0.25, 0.75, 0, 0],
        41: [0.25, 0.75, 0, 0],
        42: [0, 0.75, 0, 0],
        43: [0.08333, 0.58333, 0, 0],
        44: [0.19444, 0.10556, 0, 0],
        45: [0, 0.43056, 0, 0],
        46: [0, 0.10556, 0, 0],
        47: [0.25, 0.75, 0, 0],
        48: [0, 0.64444, 0, 0],
        49: [0, 0.64444, 0, 0],
        50: [0, 0.64444, 0, 0],
        51: [0, 0.64444, 0, 0],
        52: [0, 0.64444, 0, 0],
        53: [0, 0.64444, 0, 0],
        54: [0, 0.64444, 0, 0],
        55: [0, 0.64444, 0, 0],
        56: [0, 0.64444, 0, 0],
        57: [0, 0.64444, 0, 0],
        58: [0, 0.43056, 0, 0],
        59: [0.19444, 0.43056, 0, 0],
        60: [0.0391, 0.5391, 0, 0],
        61: [-0.13313, 0.36687, 0, 0],
        62: [0.0391, 0.5391, 0, 0],
        63: [0, 0.69444, 0, 0],
        64: [0, 0.69444, 0, 0],
        65: [0, 0.68333, 0, 0],
        66: [0, 0.68333, 0, 0],
        67: [0, 0.68333, 0, 0],
        68: [0, 0.68333, 0, 0],
        69: [0, 0.68333, 0, 0],
        70: [0, 0.68333, 0, 0],
        71: [0, 0.68333, 0, 0],
        72: [0, 0.68333, 0, 0],
        73: [0, 0.68333, 0, 0],
        74: [0, 0.68333, 0, 0],
        75: [0, 0.68333, 0, 0],
        76: [0, 0.68333, 0, 0],
        77: [0, 0.68333, 0, 0],
        78: [0, 0.68333, 0, 0],
        79: [0, 0.68333, 0, 0],
        80: [0, 0.68333, 0, 0],
        81: [0.19444, 0.68333, 0, 0],
        82: [0, 0.68333, 0, 0],
        83: [0, 0.68333, 0, 0],
        84: [0, 0.68333, 0, 0],
        85: [0, 0.68333, 0, 0],
        86: [0, 0.68333, 0.01389, 0],
        87: [0, 0.68333, 0.01389, 0],
        88: [0, 0.68333, 0, 0],
        89: [0, 0.68333, 0.025, 0],
        90: [0, 0.68333, 0, 0],
        91: [0.25, 0.75, 0, 0],
        92: [0.25, 0.75, 0, 0],
        93: [0.25, 0.75, 0, 0],
        94: [0, 0.69444, 0, 0],
        95: [0.31, 0.12056, 0.02778, 0],
        97: [0, 0.43056, 0, 0],
        98: [0, 0.69444, 0, 0],
        99: [0, 0.43056, 0, 0],
        100: [0, 0.69444, 0, 0],
        101: [0, 0.43056, 0, 0],
        102: [0, 0.69444, 0.07778, 0],
        103: [0.19444, 0.43056, 0.01389, 0],
        104: [0, 0.69444, 0, 0],
        105: [0, 0.66786, 0, 0],
        106: [0.19444, 0.66786, 0, 0],
        107: [0, 0.69444, 0, 0],
        108: [0, 0.69444, 0, 0],
        109: [0, 0.43056, 0, 0],
        110: [0, 0.43056, 0, 0],
        111: [0, 0.43056, 0, 0],
        112: [0.19444, 0.43056, 0, 0],
        113: [0.19444, 0.43056, 0, 0],
        114: [0, 0.43056, 0, 0],
        115: [0, 0.43056, 0, 0],
        116: [0, 0.61508, 0, 0],
        117: [0, 0.43056, 0, 0],
        118: [0, 0.43056, 0.01389, 0],
        119: [0, 0.43056, 0.01389, 0],
        120: [0, 0.43056, 0, 0],
        121: [0.19444, 0.43056, 0.01389, 0],
        122: [0, 0.43056, 0, 0],
        123: [0.25, 0.75, 0, 0],
        124: [0.25, 0.75, 0, 0],
        125: [0.25, 0.75, 0, 0],
        126: [0.35, 0.31786, 0, 0],
        160: [0, 0, 0, 0],
        167: [0.19444, 0.69444, 0, 0],
        168: [0, 0.66786, 0, 0],
        172: [0, 0.43056, 0, 0],
        176: [0, 0.69444, 0, 0],
        177: [0.08333, 0.58333, 0, 0],
        182: [0.19444, 0.69444, 0, 0],
        184: [0.17014, 0, 0, 0],
        198: [0, 0.68333, 0, 0],
        215: [0.08333, 0.58333, 0, 0],
        216: [0.04861, 0.73194, 0, 0],
        223: [0, 0.69444, 0, 0],
        230: [0, 0.43056, 0, 0],
        247: [0.08333, 0.58333, 0, 0],
        248: [0.09722, 0.52778, 0, 0],
        305: [0, 0.43056, 0, 0],
        338: [0, 0.68333, 0, 0],
        339: [0, 0.43056, 0, 0],
        567: [0.19444, 0.43056, 0, 0],
        710: [0, 0.69444, 0, 0],
        711: [0, 0.62847, 0, 0],
        713: [0, 0.56778, 0, 0],
        714: [0, 0.69444, 0, 0],
        715: [0, 0.69444, 0, 0],
        728: [0, 0.69444, 0, 0],
        729: [0, 0.66786, 0, 0],
        730: [0, 0.69444, 0, 0],
        732: [0, 0.66786, 0, 0],
        733: [0, 0.69444, 0, 0],
        915: [0, 0.68333, 0, 0],
        916: [0, 0.68333, 0, 0],
        920: [0, 0.68333, 0, 0],
        923: [0, 0.68333, 0, 0],
        926: [0, 0.68333, 0, 0],
        928: [0, 0.68333, 0, 0],
        931: [0, 0.68333, 0, 0],
        933: [0, 0.68333, 0, 0],
        934: [0, 0.68333, 0, 0],
        936: [0, 0.68333, 0, 0],
        937: [0, 0.68333, 0, 0],
        8211: [0, 0.43056, 0.02778, 0],
        8212: [0, 0.43056, 0.02778, 0],
        8216: [0, 0.69444, 0, 0],
        8217: [0, 0.69444, 0, 0],
        8220: [0, 0.69444, 0, 0],
        8221: [0, 0.69444, 0, 0],
        8224: [0.19444, 0.69444, 0, 0],
        8225: [0.19444, 0.69444, 0, 0],
        8230: [0, 0.12, 0, 0],
        8242: [0, 0.55556, 0, 0],
        8407: [0, 0.71444, 0.15382, 0],
        8463: [0, 0.68889, 0, 0],
        8465: [0, 0.69444, 0, 0],
        8467: [0, 0.69444, 0, 0.11111],
        8472: [0.19444, 0.43056, 0, 0.11111],
        8476: [0, 0.69444, 0, 0],
        8501: [0, 0.69444, 0, 0],
        8592: [-0.13313, 0.36687, 0, 0],
        8593: [0.19444, 0.69444, 0, 0],
        8594: [-0.13313, 0.36687, 0, 0],
        8595: [0.19444, 0.69444, 0, 0],
        8596: [-0.13313, 0.36687, 0, 0],
        8597: [0.25, 0.75, 0, 0],
        8598: [0.19444, 0.69444, 0, 0],
        8599: [0.19444, 0.69444, 0, 0],
        8600: [0.19444, 0.69444, 0, 0],
        8601: [0.19444, 0.69444, 0, 0],
        8614: [0.011, 0.511, 0, 0],
        8617: [0.011, 0.511, 0, 0],
        8618: [0.011, 0.511, 0, 0],
        8636: [-0.13313, 0.36687, 0, 0],
        8637: [-0.13313, 0.36687, 0, 0],
        8640: [-0.13313, 0.36687, 0, 0],
        8641: [-0.13313, 0.36687, 0, 0],
        8652: [0.011, 0.671, 0, 0],
        8656: [-0.13313, 0.36687, 0, 0],
        8657: [0.19444, 0.69444, 0, 0],
        8658: [-0.13313, 0.36687, 0, 0],
        8659: [0.19444, 0.69444, 0, 0],
        8660: [-0.13313, 0.36687, 0, 0],
        8661: [0.25, 0.75, 0, 0],
        8704: [0, 0.69444, 0, 0],
        8706: [0, 0.69444, 0.05556, 0.08334],
        8707: [0, 0.69444, 0, 0],
        8709: [0.05556, 0.75, 0, 0],
        8711: [0, 0.68333, 0, 0],
        8712: [0.0391, 0.5391, 0, 0],
        8715: [0.0391, 0.5391, 0, 0],
        8722: [0.08333, 0.58333, 0, 0],
        8723: [0.08333, 0.58333, 0, 0],
        8725: [0.25, 0.75, 0, 0],
        8726: [0.25, 0.75, 0, 0],
        8727: [-0.03472, 0.46528, 0, 0],
        8728: [-0.05555, 0.44445, 0, 0],
        8729: [-0.05555, 0.44445, 0, 0],
        8730: [0.2, 0.8, 0, 0],
        8733: [0, 0.43056, 0, 0],
        8734: [0, 0.43056, 0, 0],
        8736: [0, 0.69224, 0, 0],
        8739: [0.25, 0.75, 0, 0],
        8741: [0.25, 0.75, 0, 0],
        8743: [0, 0.55556, 0, 0],
        8744: [0, 0.55556, 0, 0],
        8745: [0, 0.55556, 0, 0],
        8746: [0, 0.55556, 0, 0],
        8747: [0.19444, 0.69444, 0.11111, 0],
        8764: [-0.13313, 0.36687, 0, 0],
        8768: [0.19444, 0.69444, 0, 0],
        8771: [-0.03625, 0.46375, 0, 0],
        8773: [-0.022, 0.589, 0, 0],
        8776: [-0.01688, 0.48312, 0, 0],
        8781: [-0.03625, 0.46375, 0, 0],
        8784: [-0.133, 0.67, 0, 0],
        8801: [-0.03625, 0.46375, 0, 0],
        8804: [0.13597, 0.63597, 0, 0],
        8805: [0.13597, 0.63597, 0, 0],
        8810: [0.0391, 0.5391, 0, 0],
        8811: [0.0391, 0.5391, 0, 0],
        8826: [0.0391, 0.5391, 0, 0],
        8827: [0.0391, 0.5391, 0, 0],
        8834: [0.0391, 0.5391, 0, 0],
        8835: [0.0391, 0.5391, 0, 0],
        8838: [0.13597, 0.63597, 0, 0],
        8839: [0.13597, 0.63597, 0, 0],
        8846: [0, 0.55556, 0, 0],
        8849: [0.13597, 0.63597, 0, 0],
        8850: [0.13597, 0.63597, 0, 0],
        8851: [0, 0.55556, 0, 0],
        8852: [0, 0.55556, 0, 0],
        8853: [0.08333, 0.58333, 0, 0],
        8854: [0.08333, 0.58333, 0, 0],
        8855: [0.08333, 0.58333, 0, 0],
        8856: [0.08333, 0.58333, 0, 0],
        8857: [0.08333, 0.58333, 0, 0],
        8866: [0, 0.69444, 0, 0],
        8867: [0, 0.69444, 0, 0],
        8868: [0, 0.69444, 0, 0],
        8869: [0, 0.69444, 0, 0],
        8872: [0.249, 0.75, 0, 0],
        8900: [-0.05555, 0.44445, 0, 0],
        8901: [-0.05555, 0.44445, 0, 0],
        8902: [-0.03472, 0.46528, 0, 0],
        8904: [0.005, 0.505, 0, 0],
        8942: [0.03, 0.9, 0, 0],
        8943: [-0.19, 0.31, 0, 0],
        8945: [-0.1, 0.82, 0, 0],
        8968: [0.25, 0.75, 0, 0],
        8969: [0.25, 0.75, 0, 0],
        8970: [0.25, 0.75, 0, 0],
        8971: [0.25, 0.75, 0, 0],
        8994: [-0.14236, 0.35764, 0, 0],
        8995: [-0.14236, 0.35764, 0, 0],
        9136: [0.244, 0.744, 0, 0],
        9137: [0.244, 0.744, 0, 0],
        9651: [0.19444, 0.69444, 0, 0],
        9657: [-0.03472, 0.46528, 0, 0],
        9661: [0.19444, 0.69444, 0, 0],
        9667: [-0.03472, 0.46528, 0, 0],
        9711: [0.19444, 0.69444, 0, 0],
        9824: [0.12963, 0.69444, 0, 0],
        9825: [0.12963, 0.69444, 0, 0],
        9826: [0.12963, 0.69444, 0, 0],
        9827: [0.12963, 0.69444, 0, 0],
        9837: [0, 0.75, 0, 0],
        9838: [0.19444, 0.69444, 0, 0],
        9839: [0.19444, 0.69444, 0, 0],
        10216: [0.25, 0.75, 0, 0],
        10217: [0.25, 0.75, 0, 0],
        10222: [0.244, 0.744, 0, 0],
        10223: [0.244, 0.744, 0, 0],
        10229: [0.011, 0.511, 0, 0],
        10230: [0.011, 0.511, 0, 0],
        10231: [0.011, 0.511, 0, 0],
        10232: [0.024, 0.525, 0, 0],
        10233: [0.024, 0.525, 0, 0],
        10234: [0.024, 0.525, 0, 0],
        10236: [0.011, 0.511, 0, 0],
        10815: [0, 0.68333, 0, 0],
        10927: [0.13597, 0.63597, 0, 0],
        10928: [0.13597, 0.63597, 0, 0],
        57376: [0.19444, 0.69444, 0, 0],
      },
      "Math-BoldItalic": {
        65: [0, 0.68611, 0, 0],
        66: [0, 0.68611, 0.04835, 0],
        67: [0, 0.68611, 0.06979, 0],
        68: [0, 0.68611, 0.03194, 0],
        69: [0, 0.68611, 0.05451, 0],
        70: [0, 0.68611, 0.15972, 0],
        71: [0, 0.68611, 0, 0],
        72: [0, 0.68611, 0.08229, 0],
        73: [0, 0.68611, 0.07778, 0],
        74: [0, 0.68611, 0.10069, 0],
        75: [0, 0.68611, 0.06979, 0],
        76: [0, 0.68611, 0, 0],
        77: [0, 0.68611, 0.11424, 0],
        78: [0, 0.68611, 0.11424, 0],
        79: [0, 0.68611, 0.03194, 0],
        80: [0, 0.68611, 0.15972, 0],
        81: [0.19444, 0.68611, 0, 0],
        82: [0, 0.68611, 0.00421, 0],
        83: [0, 0.68611, 0.05382, 0],
        84: [0, 0.68611, 0.15972, 0],
        85: [0, 0.68611, 0.11424, 0],
        86: [0, 0.68611, 0.25555, 0],
        87: [0, 0.68611, 0.15972, 0],
        88: [0, 0.68611, 0.07778, 0],
        89: [0, 0.68611, 0.25555, 0],
        90: [0, 0.68611, 0.06979, 0],
        97: [0, 0.44444, 0, 0],
        98: [0, 0.69444, 0, 0],
        99: [0, 0.44444, 0, 0],
        100: [0, 0.69444, 0, 0],
        101: [0, 0.44444, 0, 0],
        102: [0.19444, 0.69444, 0.11042, 0],
        103: [0.19444, 0.44444, 0.03704, 0],
        104: [0, 0.69444, 0, 0],
        105: [0, 0.69326, 0, 0],
        106: [0.19444, 0.69326, 0.0622, 0],
        107: [0, 0.69444, 0.01852, 0],
        108: [0, 0.69444, 0.0088, 0],
        109: [0, 0.44444, 0, 0],
        110: [0, 0.44444, 0, 0],
        111: [0, 0.44444, 0, 0],
        112: [0.19444, 0.44444, 0, 0],
        113: [0.19444, 0.44444, 0.03704, 0],
        114: [0, 0.44444, 0.03194, 0],
        115: [0, 0.44444, 0, 0],
        116: [0, 0.63492, 0, 0],
        117: [0, 0.44444, 0, 0],
        118: [0, 0.44444, 0.03704, 0],
        119: [0, 0.44444, 0.02778, 0],
        120: [0, 0.44444, 0, 0],
        121: [0.19444, 0.44444, 0.03704, 0],
        122: [0, 0.44444, 0.04213, 0],
        915: [0, 0.68611, 0.15972, 0],
        916: [0, 0.68611, 0, 0],
        920: [0, 0.68611, 0.03194, 0],
        923: [0, 0.68611, 0, 0],
        926: [0, 0.68611, 0.07458, 0],
        928: [0, 0.68611, 0.08229, 0],
        931: [0, 0.68611, 0.05451, 0],
        933: [0, 0.68611, 0.15972, 0],
        934: [0, 0.68611, 0, 0],
        936: [0, 0.68611, 0.11653, 0],
        937: [0, 0.68611, 0.04835, 0],
        945: [0, 0.44444, 0, 0],
        946: [0.19444, 0.69444, 0.03403, 0],
        947: [0.19444, 0.44444, 0.06389, 0],
        948: [0, 0.69444, 0.03819, 0],
        949: [0, 0.44444, 0, 0],
        950: [0.19444, 0.69444, 0.06215, 0],
        951: [0.19444, 0.44444, 0.03704, 0],
        952: [0, 0.69444, 0.03194, 0],
        953: [0, 0.44444, 0, 0],
        954: [0, 0.44444, 0, 0],
        955: [0, 0.69444, 0, 0],
        956: [0.19444, 0.44444, 0, 0],
        957: [0, 0.44444, 0.06898, 0],
        958: [0.19444, 0.69444, 0.03021, 0],
        959: [0, 0.44444, 0, 0],
        960: [0, 0.44444, 0.03704, 0],
        961: [0.19444, 0.44444, 0, 0],
        962: [0.09722, 0.44444, 0.07917, 0],
        963: [0, 0.44444, 0.03704, 0],
        964: [0, 0.44444, 0.13472, 0],
        965: [0, 0.44444, 0.03704, 0],
        966: [0.19444, 0.44444, 0, 0],
        967: [0.19444, 0.44444, 0, 0],
        968: [0.19444, 0.69444, 0.03704, 0],
        969: [0, 0.44444, 0.03704, 0],
        977: [0, 0.69444, 0, 0],
        981: [0.19444, 0.69444, 0, 0],
        982: [0, 0.44444, 0.03194, 0],
        1009: [0.19444, 0.44444, 0, 0],
        1013: [0, 0.44444, 0, 0],
      },
      "Math-Italic": {
        65: [0, 0.68333, 0, 0.13889],
        66: [0, 0.68333, 0.05017, 0.08334],
        67: [0, 0.68333, 0.07153, 0.08334],
        68: [0, 0.68333, 0.02778, 0.05556],
        69: [0, 0.68333, 0.05764, 0.08334],
        70: [0, 0.68333, 0.13889, 0.08334],
        71: [0, 0.68333, 0, 0.08334],
        72: [0, 0.68333, 0.08125, 0.05556],
        73: [0, 0.68333, 0.07847, 0.11111],
        74: [0, 0.68333, 0.09618, 0.16667],
        75: [0, 0.68333, 0.07153, 0.05556],
        76: [0, 0.68333, 0, 0.02778],
        77: [0, 0.68333, 0.10903, 0.08334],
        78: [0, 0.68333, 0.10903, 0.08334],
        79: [0, 0.68333, 0.02778, 0.08334],
        80: [0, 0.68333, 0.13889, 0.08334],
        81: [0.19444, 0.68333, 0, 0.08334],
        82: [0, 0.68333, 0.00773, 0.08334],
        83: [0, 0.68333, 0.05764, 0.08334],
        84: [0, 0.68333, 0.13889, 0.08334],
        85: [0, 0.68333, 0.10903, 0.02778],
        86: [0, 0.68333, 0.22222, 0],
        87: [0, 0.68333, 0.13889, 0],
        88: [0, 0.68333, 0.07847, 0.08334],
        89: [0, 0.68333, 0.22222, 0],
        90: [0, 0.68333, 0.07153, 0.08334],
        97: [0, 0.43056, 0, 0],
        98: [0, 0.69444, 0, 0],
        99: [0, 0.43056, 0, 0.05556],
        100: [0, 0.69444, 0, 0.16667],
        101: [0, 0.43056, 0, 0.05556],
        102: [0.19444, 0.69444, 0.10764, 0.16667],
        103: [0.19444, 0.43056, 0.03588, 0.02778],
        104: [0, 0.69444, 0, 0],
        105: [0, 0.65952, 0, 0],
        106: [0.19444, 0.65952, 0.05724, 0],
        107: [0, 0.69444, 0.03148, 0],
        108: [0, 0.69444, 0.01968, 0.08334],
        109: [0, 0.43056, 0, 0],
        110: [0, 0.43056, 0, 0],
        111: [0, 0.43056, 0, 0.05556],
        112: [0.19444, 0.43056, 0, 0.08334],
        113: [0.19444, 0.43056, 0.03588, 0.08334],
        114: [0, 0.43056, 0.02778, 0.05556],
        115: [0, 0.43056, 0, 0.05556],
        116: [0, 0.61508, 0, 0.08334],
        117: [0, 0.43056, 0, 0.02778],
        118: [0, 0.43056, 0.03588, 0.02778],
        119: [0, 0.43056, 0.02691, 0.08334],
        120: [0, 0.43056, 0, 0.02778],
        121: [0.19444, 0.43056, 0.03588, 0.05556],
        122: [0, 0.43056, 0.04398, 0.05556],
        915: [0, 0.68333, 0.13889, 0.08334],
        916: [0, 0.68333, 0, 0.16667],
        920: [0, 0.68333, 0.02778, 0.08334],
        923: [0, 0.68333, 0, 0.16667],
        926: [0, 0.68333, 0.07569, 0.08334],
        928: [0, 0.68333, 0.08125, 0.05556],
        931: [0, 0.68333, 0.05764, 0.08334],
        933: [0, 0.68333, 0.13889, 0.05556],
        934: [0, 0.68333, 0, 0.08334],
        936: [0, 0.68333, 0.11, 0.05556],
        937: [0, 0.68333, 0.05017, 0.08334],
        945: [0, 0.43056, 0.0037, 0.02778],
        946: [0.19444, 0.69444, 0.05278, 0.08334],
        947: [0.19444, 0.43056, 0.05556, 0],
        948: [0, 0.69444, 0.03785, 0.05556],
        949: [0, 0.43056, 0, 0.08334],
        950: [0.19444, 0.69444, 0.07378, 0.08334],
        951: [0.19444, 0.43056, 0.03588, 0.05556],
        952: [0, 0.69444, 0.02778, 0.08334],
        953: [0, 0.43056, 0, 0.05556],
        954: [0, 0.43056, 0, 0],
        955: [0, 0.69444, 0, 0],
        956: [0.19444, 0.43056, 0, 0.02778],
        957: [0, 0.43056, 0.06366, 0.02778],
        958: [0.19444, 0.69444, 0.04601, 0.11111],
        959: [0, 0.43056, 0, 0.05556],
        960: [0, 0.43056, 0.03588, 0],
        961: [0.19444, 0.43056, 0, 0.08334],
        962: [0.09722, 0.43056, 0.07986, 0.08334],
        963: [0, 0.43056, 0.03588, 0],
        964: [0, 0.43056, 0.1132, 0.02778],
        965: [0, 0.43056, 0.03588, 0.02778],
        966: [0.19444, 0.43056, 0, 0.08334],
        967: [0.19444, 0.43056, 0, 0.05556],
        968: [0.19444, 0.69444, 0.03588, 0.11111],
        969: [0, 0.43056, 0.03588, 0],
        977: [0, 0.69444, 0, 0.08334],
        981: [0.19444, 0.69444, 0, 0.08334],
        982: [0, 0.43056, 0.02778, 0],
        1009: [0.19444, 0.43056, 0, 0.08334],
        1013: [0, 0.43056, 0, 0.05556],
      },
      "SansSerif-Bold": {
        33: [0, 0.69444, 0, 0],
        34: [0, 0.69444, 0, 0],
        35: [0.19444, 0.69444, 0, 0],
        36: [0.05556, 0.75, 0, 0],
        37: [0.05556, 0.75, 0, 0],
        38: [0, 0.69444, 0, 0],
        39: [0, 0.69444, 0, 0],
        40: [0.25, 0.75, 0, 0],
        41: [0.25, 0.75, 0, 0],
        42: [0, 0.75, 0, 0],
        43: [0.11667, 0.61667, 0, 0],
        44: [0.10556, 0.13056, 0, 0],
        45: [0, 0.45833, 0, 0],
        46: [0, 0.13056, 0, 0],
        47: [0.25, 0.75, 0, 0],
        48: [0, 0.69444, 0, 0],
        49: [0, 0.69444, 0, 0],
        50: [0, 0.69444, 0, 0],
        51: [0, 0.69444, 0, 0],
        52: [0, 0.69444, 0, 0],
        53: [0, 0.69444, 0, 0],
        54: [0, 0.69444, 0, 0],
        55: [0, 0.69444, 0, 0],
        56: [0, 0.69444, 0, 0],
        57: [0, 0.69444, 0, 0],
        58: [0, 0.45833, 0, 0],
        59: [0.10556, 0.45833, 0, 0],
        61: [-0.09375, 0.40625, 0, 0],
        63: [0, 0.69444, 0, 0],
        64: [0, 0.69444, 0, 0],
        65: [0, 0.69444, 0, 0],
        66: [0, 0.69444, 0, 0],
        67: [0, 0.69444, 0, 0],
        68: [0, 0.69444, 0, 0],
        69: [0, 0.69444, 0, 0],
        70: [0, 0.69444, 0, 0],
        71: [0, 0.69444, 0, 0],
        72: [0, 0.69444, 0, 0],
        73: [0, 0.69444, 0, 0],
        74: [0, 0.69444, 0, 0],
        75: [0, 0.69444, 0, 0],
        76: [0, 0.69444, 0, 0],
        77: [0, 0.69444, 0, 0],
        78: [0, 0.69444, 0, 0],
        79: [0, 0.69444, 0, 0],
        80: [0, 0.69444, 0, 0],
        81: [0.10556, 0.69444, 0, 0],
        82: [0, 0.69444, 0, 0],
        83: [0, 0.69444, 0, 0],
        84: [0, 0.69444, 0, 0],
        85: [0, 0.69444, 0, 0],
        86: [0, 0.69444, 0.01528, 0],
        87: [0, 0.69444, 0.01528, 0],
        88: [0, 0.69444, 0, 0],
        89: [0, 0.69444, 0.0275, 0],
        90: [0, 0.69444, 0, 0],
        91: [0.25, 0.75, 0, 0],
        93: [0.25, 0.75, 0, 0],
        94: [0, 0.69444, 0, 0],
        95: [0.35, 0.10833, 0.03056, 0],
        97: [0, 0.45833, 0, 0],
        98: [0, 0.69444, 0, 0],
        99: [0, 0.45833, 0, 0],
        100: [0, 0.69444, 0, 0],
        101: [0, 0.45833, 0, 0],
        102: [0, 0.69444, 0.07639, 0],
        103: [0.19444, 0.45833, 0.01528, 0],
        104: [0, 0.69444, 0, 0],
        105: [0, 0.69444, 0, 0],
        106: [0.19444, 0.69444, 0, 0],
        107: [0, 0.69444, 0, 0],
        108: [0, 0.69444, 0, 0],
        109: [0, 0.45833, 0, 0],
        110: [0, 0.45833, 0, 0],
        111: [0, 0.45833, 0, 0],
        112: [0.19444, 0.45833, 0, 0],
        113: [0.19444, 0.45833, 0, 0],
        114: [0, 0.45833, 0.01528, 0],
        115: [0, 0.45833, 0, 0],
        116: [0, 0.58929, 0, 0],
        117: [0, 0.45833, 0, 0],
        118: [0, 0.45833, 0.01528, 0],
        119: [0, 0.45833, 0.01528, 0],
        120: [0, 0.45833, 0, 0],
        121: [0.19444, 0.45833, 0.01528, 0],
        122: [0, 0.45833, 0, 0],
        126: [0.35, 0.34444, 0, 0],
        168: [0, 0.69444, 0, 0],
        176: [0, 0.69444, 0, 0],
        180: [0, 0.69444, 0, 0],
        184: [0.17014, 0, 0, 0],
        305: [0, 0.45833, 0, 0],
        567: [0.19444, 0.45833, 0, 0],
        710: [0, 0.69444, 0, 0],
        711: [0, 0.63542, 0, 0],
        713: [0, 0.63778, 0, 0],
        728: [0, 0.69444, 0, 0],
        729: [0, 0.69444, 0, 0],
        730: [0, 0.69444, 0, 0],
        732: [0, 0.69444, 0, 0],
        733: [0, 0.69444, 0, 0],
        915: [0, 0.69444, 0, 0],
        916: [0, 0.69444, 0, 0],
        920: [0, 0.69444, 0, 0],
        923: [0, 0.69444, 0, 0],
        926: [0, 0.69444, 0, 0],
        928: [0, 0.69444, 0, 0],
        931: [0, 0.69444, 0, 0],
        933: [0, 0.69444, 0, 0],
        934: [0, 0.69444, 0, 0],
        936: [0, 0.69444, 0, 0],
        937: [0, 0.69444, 0, 0],
        8211: [0, 0.45833, 0.03056, 0],
        8212: [0, 0.45833, 0.03056, 0],
        8216: [0, 0.69444, 0, 0],
        8217: [0, 0.69444, 0, 0],
        8220: [0, 0.69444, 0, 0],
        8221: [0, 0.69444, 0, 0],
      },
      "SansSerif-Italic": {
        33: [0, 0.69444, 0.05733, 0],
        34: [0, 0.69444, 0.00316, 0],
        35: [0.19444, 0.69444, 0.05087, 0],
        36: [0.05556, 0.75, 0.11156, 0],
        37: [0.05556, 0.75, 0.03126, 0],
        38: [0, 0.69444, 0.03058, 0],
        39: [0, 0.69444, 0.07816, 0],
        40: [0.25, 0.75, 0.13164, 0],
        41: [0.25, 0.75, 0.02536, 0],
        42: [0, 0.75, 0.11775, 0],
        43: [0.08333, 0.58333, 0.02536, 0],
        44: [0.125, 0.08333, 0, 0],
        45: [0, 0.44444, 0.01946, 0],
        46: [0, 0.08333, 0, 0],
        47: [0.25, 0.75, 0.13164, 0],
        48: [0, 0.65556, 0.11156, 0],
        49: [0, 0.65556, 0.11156, 0],
        50: [0, 0.65556, 0.11156, 0],
        51: [0, 0.65556, 0.11156, 0],
        52: [0, 0.65556, 0.11156, 0],
        53: [0, 0.65556, 0.11156, 0],
        54: [0, 0.65556, 0.11156, 0],
        55: [0, 0.65556, 0.11156, 0],
        56: [0, 0.65556, 0.11156, 0],
        57: [0, 0.65556, 0.11156, 0],
        58: [0, 0.44444, 0.02502, 0],
        59: [0.125, 0.44444, 0.02502, 0],
        61: [-0.13, 0.37, 0.05087, 0],
        63: [0, 0.69444, 0.11809, 0],
        64: [0, 0.69444, 0.07555, 0],
        65: [0, 0.69444, 0, 0],
        66: [0, 0.69444, 0.08293, 0],
        67: [0, 0.69444, 0.11983, 0],
        68: [0, 0.69444, 0.07555, 0],
        69: [0, 0.69444, 0.11983, 0],
        70: [0, 0.69444, 0.13372, 0],
        71: [0, 0.69444, 0.11983, 0],
        72: [0, 0.69444, 0.08094, 0],
        73: [0, 0.69444, 0.13372, 0],
        74: [0, 0.69444, 0.08094, 0],
        75: [0, 0.69444, 0.11983, 0],
        76: [0, 0.69444, 0, 0],
        77: [0, 0.69444, 0.08094, 0],
        78: [0, 0.69444, 0.08094, 0],
        79: [0, 0.69444, 0.07555, 0],
        80: [0, 0.69444, 0.08293, 0],
        81: [0.125, 0.69444, 0.07555, 0],
        82: [0, 0.69444, 0.08293, 0],
        83: [0, 0.69444, 0.09205, 0],
        84: [0, 0.69444, 0.13372, 0],
        85: [0, 0.69444, 0.08094, 0],
        86: [0, 0.69444, 0.1615, 0],
        87: [0, 0.69444, 0.1615, 0],
        88: [0, 0.69444, 0.13372, 0],
        89: [0, 0.69444, 0.17261, 0],
        90: [0, 0.69444, 0.11983, 0],
        91: [0.25, 0.75, 0.15942, 0],
        93: [0.25, 0.75, 0.08719, 0],
        94: [0, 0.69444, 0.0799, 0],
        95: [0.35, 0.09444, 0.08616, 0],
        97: [0, 0.44444, 0.00981, 0],
        98: [0, 0.69444, 0.03057, 0],
        99: [0, 0.44444, 0.08336, 0],
        100: [0, 0.69444, 0.09483, 0],
        101: [0, 0.44444, 0.06778, 0],
        102: [0, 0.69444, 0.21705, 0],
        103: [0.19444, 0.44444, 0.10836, 0],
        104: [0, 0.69444, 0.01778, 0],
        105: [0, 0.67937, 0.09718, 0],
        106: [0.19444, 0.67937, 0.09162, 0],
        107: [0, 0.69444, 0.08336, 0],
        108: [0, 0.69444, 0.09483, 0],
        109: [0, 0.44444, 0.01778, 0],
        110: [0, 0.44444, 0.01778, 0],
        111: [0, 0.44444, 0.06613, 0],
        112: [0.19444, 0.44444, 0.0389, 0],
        113: [0.19444, 0.44444, 0.04169, 0],
        114: [0, 0.44444, 0.10836, 0],
        115: [0, 0.44444, 0.0778, 0],
        116: [0, 0.57143, 0.07225, 0],
        117: [0, 0.44444, 0.04169, 0],
        118: [0, 0.44444, 0.10836, 0],
        119: [0, 0.44444, 0.10836, 0],
        120: [0, 0.44444, 0.09169, 0],
        121: [0.19444, 0.44444, 0.10836, 0],
        122: [0, 0.44444, 0.08752, 0],
        126: [0.35, 0.32659, 0.08826, 0],
        168: [0, 0.67937, 0.06385, 0],
        176: [0, 0.69444, 0, 0],
        184: [0.17014, 0, 0, 0],
        305: [0, 0.44444, 0.04169, 0],
        567: [0.19444, 0.44444, 0.04169, 0],
        710: [0, 0.69444, 0.0799, 0],
        711: [0, 0.63194, 0.08432, 0],
        713: [0, 0.60889, 0.08776, 0],
        714: [0, 0.69444, 0.09205, 0],
        715: [0, 0.69444, 0, 0],
        728: [0, 0.69444, 0.09483, 0],
        729: [0, 0.67937, 0.07774, 0],
        730: [0, 0.69444, 0, 0],
        732: [0, 0.67659, 0.08826, 0],
        733: [0, 0.69444, 0.09205, 0],
        915: [0, 0.69444, 0.13372, 0],
        916: [0, 0.69444, 0, 0],
        920: [0, 0.69444, 0.07555, 0],
        923: [0, 0.69444, 0, 0],
        926: [0, 0.69444, 0.12816, 0],
        928: [0, 0.69444, 0.08094, 0],
        931: [0, 0.69444, 0.11983, 0],
        933: [0, 0.69444, 0.09031, 0],
        934: [0, 0.69444, 0.04603, 0],
        936: [0, 0.69444, 0.09031, 0],
        937: [0, 0.69444, 0.08293, 0],
        8211: [0, 0.44444, 0.08616, 0],
        8212: [0, 0.44444, 0.08616, 0],
        8216: [0, 0.69444, 0.07816, 0],
        8217: [0, 0.69444, 0.07816, 0],
        8220: [0, 0.69444, 0.14205, 0],
        8221: [0, 0.69444, 0.00316, 0],
      },
      "SansSerif-Regular": {
        33: [0, 0.69444, 0, 0],
        34: [0, 0.69444, 0, 0],
        35: [0.19444, 0.69444, 0, 0],
        36: [0.05556, 0.75, 0, 0],
        37: [0.05556, 0.75, 0, 0],
        38: [0, 0.69444, 0, 0],
        39: [0, 0.69444, 0, 0],
        40: [0.25, 0.75, 0, 0],
        41: [0.25, 0.75, 0, 0],
        42: [0, 0.75, 0, 0],
        43: [0.08333, 0.58333, 0, 0],
        44: [0.125, 0.08333, 0, 0],
        45: [0, 0.44444, 0, 0],
        46: [0, 0.08333, 0, 0],
        47: [0.25, 0.75, 0, 0],
        48: [0, 0.65556, 0, 0],
        49: [0, 0.65556, 0, 0],
        50: [0, 0.65556, 0, 0],
        51: [0, 0.65556, 0, 0],
        52: [0, 0.65556, 0, 0],
        53: [0, 0.65556, 0, 0],
        54: [0, 0.65556, 0, 0],
        55: [0, 0.65556, 0, 0],
        56: [0, 0.65556, 0, 0],
        57: [0, 0.65556, 0, 0],
        58: [0, 0.44444, 0, 0],
        59: [0.125, 0.44444, 0, 0],
        61: [-0.13, 0.37, 0, 0],
        63: [0, 0.69444, 0, 0],
        64: [0, 0.69444, 0, 0],
        65: [0, 0.69444, 0, 0],
        66: [0, 0.69444, 0, 0],
        67: [0, 0.69444, 0, 0],
        68: [0, 0.69444, 0, 0],
        69: [0, 0.69444, 0, 0],
        70: [0, 0.69444, 0, 0],
        71: [0, 0.69444, 0, 0],
        72: [0, 0.69444, 0, 0],
        73: [0, 0.69444, 0, 0],
        74: [0, 0.69444, 0, 0],
        75: [0, 0.69444, 0, 0],
        76: [0, 0.69444, 0, 0],
        77: [0, 0.69444, 0, 0],
        78: [0, 0.69444, 0, 0],
        79: [0, 0.69444, 0, 0],
        80: [0, 0.69444, 0, 0],
        81: [0.125, 0.69444, 0, 0],
        82: [0, 0.69444, 0, 0],
        83: [0, 0.69444, 0, 0],
        84: [0, 0.69444, 0, 0],
        85: [0, 0.69444, 0, 0],
        86: [0, 0.69444, 0.01389, 0],
        87: [0, 0.69444, 0.01389, 0],
        88: [0, 0.69444, 0, 0],
        89: [0, 0.69444, 0.025, 0],
        90: [0, 0.69444, 0, 0],
        91: [0.25, 0.75, 0, 0],
        93: [0.25, 0.75, 0, 0],
        94: [0, 0.69444, 0, 0],
        95: [0.35, 0.09444, 0.02778, 0],
        97: [0, 0.44444, 0, 0],
        98: [0, 0.69444, 0, 0],
        99: [0, 0.44444, 0, 0],
        100: [0, 0.69444, 0, 0],
        101: [0, 0.44444, 0, 0],
        102: [0, 0.69444, 0.06944, 0],
        103: [0.19444, 0.44444, 0.01389, 0],
        104: [0, 0.69444, 0, 0],
        105: [0, 0.67937, 0, 0],
        106: [0.19444, 0.67937, 0, 0],
        107: [0, 0.69444, 0, 0],
        108: [0, 0.69444, 0, 0],
        109: [0, 0.44444, 0, 0],
        110: [0, 0.44444, 0, 0],
        111: [0, 0.44444, 0, 0],
        112: [0.19444, 0.44444, 0, 0],
        113: [0.19444, 0.44444, 0, 0],
        114: [0, 0.44444, 0.01389, 0],
        115: [0, 0.44444, 0, 0],
        116: [0, 0.57143, 0, 0],
        117: [0, 0.44444, 0, 0],
        118: [0, 0.44444, 0.01389, 0],
        119: [0, 0.44444, 0.01389, 0],
        120: [0, 0.44444, 0, 0],
        121: [0.19444, 0.44444, 0.01389, 0],
        122: [0, 0.44444, 0, 0],
        126: [0.35, 0.32659, 0, 0],
        168: [0, 0.67937, 0, 0],
        176: [0, 0.69444, 0, 0],
        184: [0.17014, 0, 0, 0],
        305: [0, 0.44444, 0, 0],
        567: [0.19444, 0.44444, 0, 0],
        710: [0, 0.69444, 0, 0],
        711: [0, 0.63194, 0, 0],
        713: [0, 0.60889, 0, 0],
        714: [0, 0.69444, 0, 0],
        715: [0, 0.69444, 0, 0],
        728: [0, 0.69444, 0, 0],
        729: [0, 0.67937, 0, 0],
        730: [0, 0.69444, 0, 0],
        732: [0, 0.67659, 0, 0],
        733: [0, 0.69444, 0, 0],
        915: [0, 0.69444, 0, 0],
        916: [0, 0.69444, 0, 0],
        920: [0, 0.69444, 0, 0],
        923: [0, 0.69444, 0, 0],
        926: [0, 0.69444, 0, 0],
        928: [0, 0.69444, 0, 0],
        931: [0, 0.69444, 0, 0],
        933: [0, 0.69444, 0, 0],
        934: [0, 0.69444, 0, 0],
        936: [0, 0.69444, 0, 0],
        937: [0, 0.69444, 0, 0],
        8211: [0, 0.44444, 0.02778, 0],
        8212: [0, 0.44444, 0.02778, 0],
        8216: [0, 0.69444, 0, 0],
        8217: [0, 0.69444, 0, 0],
        8220: [0, 0.69444, 0, 0],
        8221: [0, 0.69444, 0, 0],
      },
      "Script-Regular": {
        65: [0, 0.7, 0.22925, 0],
        66: [0, 0.7, 0.04087, 0],
        67: [0, 0.7, 0.1689, 0],
        68: [0, 0.7, 0.09371, 0],
        69: [0, 0.7, 0.18583, 0],
        70: [0, 0.7, 0.13634, 0],
        71: [0, 0.7, 0.17322, 0],
        72: [0, 0.7, 0.29694, 0],
        73: [0, 0.7, 0.19189, 0],
        74: [0.27778, 0.7, 0.19189, 0],
        75: [0, 0.7, 0.31259, 0],
        76: [0, 0.7, 0.19189, 0],
        77: [0, 0.7, 0.15981, 0],
        78: [0, 0.7, 0.3525, 0],
        79: [0, 0.7, 0.08078, 0],
        80: [0, 0.7, 0.08078, 0],
        81: [0, 0.7, 0.03305, 0],
        82: [0, 0.7, 0.06259, 0],
        83: [0, 0.7, 0.19189, 0],
        84: [0, 0.7, 0.29087, 0],
        85: [0, 0.7, 0.25815, 0],
        86: [0, 0.7, 0.27523, 0],
        87: [0, 0.7, 0.27523, 0],
        88: [0, 0.7, 0.26006, 0],
        89: [0, 0.7, 0.2939, 0],
        90: [0, 0.7, 0.24037, 0],
      },
      "Size1-Regular": {
        40: [0.35001, 0.85, 0, 0],
        41: [0.35001, 0.85, 0, 0],
        47: [0.35001, 0.85, 0, 0],
        91: [0.35001, 0.85, 0, 0],
        92: [0.35001, 0.85, 0, 0],
        93: [0.35001, 0.85, 0, 0],
        123: [0.35001, 0.85, 0, 0],
        125: [0.35001, 0.85, 0, 0],
        710: [0, 0.72222, 0, 0],
        732: [0, 0.72222, 0, 0],
        770: [0, 0.72222, 0, 0],
        771: [0, 0.72222, 0, 0],
        8214: [-99e-5, 0.601, 0, 0],
        8593: [1e-5, 0.6, 0, 0],
        8595: [1e-5, 0.6, 0, 0],
        8657: [1e-5, 0.6, 0, 0],
        8659: [1e-5, 0.6, 0, 0],
        8719: [0.25001, 0.75, 0, 0],
        8720: [0.25001, 0.75, 0, 0],
        8721: [0.25001, 0.75, 0, 0],
        8730: [0.35001, 0.85, 0, 0],
        8739: [-0.00599, 0.606, 0, 0],
        8741: [-0.00599, 0.606, 0, 0],
        8747: [0.30612, 0.805, 0.19445, 0],
        8748: [0.306, 0.805, 0.19445, 0],
        8749: [0.306, 0.805, 0.19445, 0],
        8750: [0.30612, 0.805, 0.19445, 0],
        8896: [0.25001, 0.75, 0, 0],
        8897: [0.25001, 0.75, 0, 0],
        8898: [0.25001, 0.75, 0, 0],
        8899: [0.25001, 0.75, 0, 0],
        8968: [0.35001, 0.85, 0, 0],
        8969: [0.35001, 0.85, 0, 0],
        8970: [0.35001, 0.85, 0, 0],
        8971: [0.35001, 0.85, 0, 0],
        9168: [-99e-5, 0.601, 0, 0],
        10216: [0.35001, 0.85, 0, 0],
        10217: [0.35001, 0.85, 0, 0],
        10752: [0.25001, 0.75, 0, 0],
        10753: [0.25001, 0.75, 0, 0],
        10754: [0.25001, 0.75, 0, 0],
        10756: [0.25001, 0.75, 0, 0],
        10758: [0.25001, 0.75, 0, 0],
      },
      "Size2-Regular": {
        40: [0.65002, 1.15, 0, 0],
        41: [0.65002, 1.15, 0, 0],
        47: [0.65002, 1.15, 0, 0],
        91: [0.65002, 1.15, 0, 0],
        92: [0.65002, 1.15, 0, 0],
        93: [0.65002, 1.15, 0, 0],
        123: [0.65002, 1.15, 0, 0],
        125: [0.65002, 1.15, 0, 0],
        710: [0, 0.75, 0, 0],
        732: [0, 0.75, 0, 0],
        770: [0, 0.75, 0, 0],
        771: [0, 0.75, 0, 0],
        8719: [0.55001, 1.05, 0, 0],
        8720: [0.55001, 1.05, 0, 0],
        8721: [0.55001, 1.05, 0, 0],
        8730: [0.65002, 1.15, 0, 0],
        8747: [0.86225, 1.36, 0.44445, 0],
        8748: [0.862, 1.36, 0.44445, 0],
        8749: [0.862, 1.36, 0.44445, 0],
        8750: [0.86225, 1.36, 0.44445, 0],
        8896: [0.55001, 1.05, 0, 0],
        8897: [0.55001, 1.05, 0, 0],
        8898: [0.55001, 1.05, 0, 0],
        8899: [0.55001, 1.05, 0, 0],
        8968: [0.65002, 1.15, 0, 0],
        8969: [0.65002, 1.15, 0, 0],
        8970: [0.65002, 1.15, 0, 0],
        8971: [0.65002, 1.15, 0, 0],
        10216: [0.65002, 1.15, 0, 0],
        10217: [0.65002, 1.15, 0, 0],
        10752: [0.55001, 1.05, 0, 0],
        10753: [0.55001, 1.05, 0, 0],
        10754: [0.55001, 1.05, 0, 0],
        10756: [0.55001, 1.05, 0, 0],
        10758: [0.55001, 1.05, 0, 0],
      },
      "Size3-Regular": {
        40: [0.95003, 1.45, 0, 0],
        41: [0.95003, 1.45, 0, 0],
        47: [0.95003, 1.45, 0, 0],
        91: [0.95003, 1.45, 0, 0],
        92: [0.95003, 1.45, 0, 0],
        93: [0.95003, 1.45, 0, 0],
        123: [0.95003, 1.45, 0, 0],
        125: [0.95003, 1.45, 0, 0],
        710: [0, 0.75, 0, 0],
        732: [0, 0.75, 0, 0],
        770: [0, 0.75, 0, 0],
        771: [0, 0.75, 0, 0],
        8730: [0.95003, 1.45, 0, 0],
        8968: [0.95003, 1.45, 0, 0],
        8969: [0.95003, 1.45, 0, 0],
        8970: [0.95003, 1.45, 0, 0],
        8971: [0.95003, 1.45, 0, 0],
        10216: [0.95003, 1.45, 0, 0],
        10217: [0.95003, 1.45, 0, 0],
      },
      "Size4-Regular": {
        40: [1.25003, 1.75, 0, 0],
        41: [1.25003, 1.75, 0, 0],
        47: [1.25003, 1.75, 0, 0],
        91: [1.25003, 1.75, 0, 0],
        92: [1.25003, 1.75, 0, 0],
        93: [1.25003, 1.75, 0, 0],
        123: [1.25003, 1.75, 0, 0],
        125: [1.25003, 1.75, 0, 0],
        710: [0, 0.825, 0, 0],
        732: [0, 0.825, 0, 0],
        770: [0, 0.825, 0, 0],
        771: [0, 0.825, 0, 0],
        8730: [1.25003, 1.75, 0, 0],
        8968: [1.25003, 1.75, 0, 0],
        8969: [1.25003, 1.75, 0, 0],
        8970: [1.25003, 1.75, 0, 0],
        8971: [1.25003, 1.75, 0, 0],
        9115: [0.64502, 1.155, 0, 0],
        9116: [1e-5, 0.6, 0, 0],
        9117: [0.64502, 1.155, 0, 0],
        9118: [0.64502, 1.155, 0, 0],
        9119: [1e-5, 0.6, 0, 0],
        9120: [0.64502, 1.155, 0, 0],
        9121: [0.64502, 1.155, 0, 0],
        9122: [-99e-5, 0.601, 0, 0],
        9123: [0.64502, 1.155, 0, 0],
        9124: [0.64502, 1.155, 0, 0],
        9125: [-99e-5, 0.601, 0, 0],
        9126: [0.64502, 1.155, 0, 0],
        9127: [1e-5, 0.9, 0, 0],
        9128: [0.65002, 1.15, 0, 0],
        9129: [0.90001, 0, 0, 0],
        9130: [0, 0.3, 0, 0],
        9131: [1e-5, 0.9, 0, 0],
        9132: [0.65002, 1.15, 0, 0],
        9133: [0.90001, 0, 0, 0],
        9143: [0.88502, 0.915, 0, 0],
        10216: [1.25003, 1.75, 0, 0],
        10217: [1.25003, 1.75, 0, 0],
        57344: [-0.00499, 0.605, 0, 0],
        57345: [-0.00499, 0.605, 0, 0],
        57680: [0, 0.12, 0, 0],
        57681: [0, 0.12, 0, 0],
        57682: [0, 0.12, 0, 0],
        57683: [0, 0.12, 0, 0],
      },
      "Typewriter-Regular": {
        32: [0, 0, 0, 0],
        33: [0, 0.61111, 0, 0],
        34: [0, 0.61111, 0, 0],
        35: [0, 0.61111, 0, 0],
        36: [0.08333, 0.69444, 0, 0],
        37: [0.08333, 0.69444, 0, 0],
        38: [0, 0.61111, 0, 0],
        39: [0, 0.61111, 0, 0],
        40: [0.08333, 0.69444, 0, 0],
        41: [0.08333, 0.69444, 0, 0],
        42: [0, 0.52083, 0, 0],
        43: [-0.08056, 0.53055, 0, 0],
        44: [0.13889, 0.125, 0, 0],
        45: [-0.08056, 0.53055, 0, 0],
        46: [0, 0.125, 0, 0],
        47: [0.08333, 0.69444, 0, 0],
        48: [0, 0.61111, 0, 0],
        49: [0, 0.61111, 0, 0],
        50: [0, 0.61111, 0, 0],
        51: [0, 0.61111, 0, 0],
        52: [0, 0.61111, 0, 0],
        53: [0, 0.61111, 0, 0],
        54: [0, 0.61111, 0, 0],
        55: [0, 0.61111, 0, 0],
        56: [0, 0.61111, 0, 0],
        57: [0, 0.61111, 0, 0],
        58: [0, 0.43056, 0, 0],
        59: [0.13889, 0.43056, 0, 0],
        60: [-0.05556, 0.55556, 0, 0],
        61: [-0.19549, 0.41562, 0, 0],
        62: [-0.05556, 0.55556, 0, 0],
        63: [0, 0.61111, 0, 0],
        64: [0, 0.61111, 0, 0],
        65: [0, 0.61111, 0, 0],
        66: [0, 0.61111, 0, 0],
        67: [0, 0.61111, 0, 0],
        68: [0, 0.61111, 0, 0],
        69: [0, 0.61111, 0, 0],
        70: [0, 0.61111, 0, 0],
        71: [0, 0.61111, 0, 0],
        72: [0, 0.61111, 0, 0],
        73: [0, 0.61111, 0, 0],
        74: [0, 0.61111, 0, 0],
        75: [0, 0.61111, 0, 0],
        76: [0, 0.61111, 0, 0],
        77: [0, 0.61111, 0, 0],
        78: [0, 0.61111, 0, 0],
        79: [0, 0.61111, 0, 0],
        80: [0, 0.61111, 0, 0],
        81: [0.13889, 0.61111, 0, 0],
        82: [0, 0.61111, 0, 0],
        83: [0, 0.61111, 0, 0],
        84: [0, 0.61111, 0, 0],
        85: [0, 0.61111, 0, 0],
        86: [0, 0.61111, 0, 0],
        87: [0, 0.61111, 0, 0],
        88: [0, 0.61111, 0, 0],
        89: [0, 0.61111, 0, 0],
        90: [0, 0.61111, 0, 0],
        91: [0.08333, 0.69444, 0, 0],
        92: [0.08333, 0.69444, 0, 0],
        93: [0.08333, 0.69444, 0, 0],
        94: [0, 0.61111, 0, 0],
        95: [0.09514, 0, 0, 0],
        96: [0, 0.61111, 0, 0],
        97: [0, 0.43056, 0, 0],
        98: [0, 0.61111, 0, 0],
        99: [0, 0.43056, 0, 0],
        100: [0, 0.61111, 0, 0],
        101: [0, 0.43056, 0, 0],
        102: [0, 0.61111, 0, 0],
        103: [0.22222, 0.43056, 0, 0],
        104: [0, 0.61111, 0, 0],
        105: [0, 0.61111, 0, 0],
        106: [0.22222, 0.61111, 0, 0],
        107: [0, 0.61111, 0, 0],
        108: [0, 0.61111, 0, 0],
        109: [0, 0.43056, 0, 0],
        110: [0, 0.43056, 0, 0],
        111: [0, 0.43056, 0, 0],
        112: [0.22222, 0.43056, 0, 0],
        113: [0.22222, 0.43056, 0, 0],
        114: [0, 0.43056, 0, 0],
        115: [0, 0.43056, 0, 0],
        116: [0, 0.55358, 0, 0],
        117: [0, 0.43056, 0, 0],
        118: [0, 0.43056, 0, 0],
        119: [0, 0.43056, 0, 0],
        120: [0, 0.43056, 0, 0],
        121: [0.22222, 0.43056, 0, 0],
        122: [0, 0.43056, 0, 0],
        123: [0.08333, 0.69444, 0, 0],
        124: [0.08333, 0.69444, 0, 0],
        125: [0.08333, 0.69444, 0, 0],
        126: [0, 0.61111, 0, 0],
        127: [0, 0.61111, 0, 0],
        160: [0, 0, 0, 0],
        176: [0, 0.61111, 0, 0],
        184: [0.19445, 0, 0, 0],
        305: [0, 0.43056, 0, 0],
        567: [0.22222, 0.43056, 0, 0],
        711: [0, 0.56597, 0, 0],
        713: [0, 0.56555, 0, 0],
        714: [0, 0.61111, 0, 0],
        715: [0, 0.61111, 0, 0],
        728: [0, 0.61111, 0, 0],
        730: [0, 0.61111, 0, 0],
        770: [0, 0.61111, 0, 0],
        771: [0, 0.61111, 0, 0],
        776: [0, 0.61111, 0, 0],
        915: [0, 0.61111, 0, 0],
        916: [0, 0.61111, 0, 0],
        920: [0, 0.61111, 0, 0],
        923: [0, 0.61111, 0, 0],
        926: [0, 0.61111, 0, 0],
        928: [0, 0.61111, 0, 0],
        931: [0, 0.61111, 0, 0],
        933: [0, 0.61111, 0, 0],
        934: [0, 0.61111, 0, 0],
        936: [0, 0.61111, 0, 0],
        937: [0, 0.61111, 0, 0],
        8216: [0, 0.61111, 0, 0],
        8217: [0, 0.61111, 0, 0],
        8242: [0, 0.61111, 0, 0],
        9251: [0.11111, 0.21944, 0, 0],
      },
    };
    const e = /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/,
      s = {
        slant: [0.25, 0.25, 0.25],
        space: [0, 0, 0],
        stretch: [0, 0, 0],
        shrink: [0, 0, 0],
        xHeight: [0.431, 0.431, 0.431],
        quad: [1, 1.171, 1.472],
        extraSpace: [0, 0, 0],
        num1: [0.677, 0.732, 0.925],
        num2: [0.394, 0.384, 0.387],
        num3: [0.444, 0.471, 0.504],
        denom1: [0.686, 0.752, 1.025],
        denom2: [0.345, 0.344, 0.532],
        sup1: [0.413, 0.503, 0.504],
        sup2: [0.363, 0.431, 0.404],
        sup3: [0.289, 0.286, 0.294],
        sub1: [0.15, 0.143, 0.2],
        sub2: [0.247, 0.286, 0.4],
        supDrop: [0.386, 0.353, 0.494],
        subDrop: [0.05, 0.071, 0.1],
        delim1: [2.39, 1.7, 1.98],
        delim2: [1.01, 1.157, 1.42],
        axisHeight: [0.25, 0.25, 0.25],
      },
      i = 0.04,
      a = 0.111,
      r = 0.166,
      n = 0.2,
      o = 0.6,
      l = 0.1,
      c = 10,
      h = 0.2,
      d = 0.5,
      m = 1.2,
      p = 0.04,
      u = 0.3,
      f = 0.04,
      g = {
        " ": " ",
        "​": " ",
        Å: "A",
        Ç: "C",
        Ð: "D",
        Þ: "o",
        å: "a",
        ç: "c",
        ð: "d",
        þ: "o",
        А: "A",
        Б: "B",
        В: "B",
        Г: "F",
        Д: "A",
        Е: "E",
        Ж: "K",
        З: "3",
        И: "N",
        Й: "N",
        К: "K",
        Л: "N",
        М: "M",
        Н: "H",
        О: "O",
        П: "N",
        Р: "P",
        С: "C",
        Т: "T",
        У: "y",
        Ф: "O",
        Х: "X",
        Ц: "U",
        Ч: "h",
        Ш: "W",
        Щ: "W",
        Ъ: "B",
        Ы: "X",
        Ь: "B",
        Э: "3",
        Ю: "X",
        Я: "R",
        а: "a",
        б: "b",
        в: "a",
        г: "r",
        д: "y",
        е: "e",
        ж: "m",
        з: "e",
        и: "n",
        й: "n",
        к: "n",
        л: "n",
        м: "m",
        н: "n",
        о: "o",
        п: "n",
        р: "p",
        с: "c",
        т: "o",
        у: "y",
        ф: "b",
        х: "x",
        ц: "n",
        ч: "n",
        ш: "w",
        щ: "w",
        ъ: "a",
        ы: "m",
        ь: "a",
        э: "e",
        ю: "m",
        я: "r",
      };

    function y(s, i) {
      let a = s.charCodeAt(0);
      s[0] in g ? (a = g[s[0]].charCodeAt(0)) : e.test(s[0]) && (a = 77);
      const r = t[i][a];
      return r
        ? {
            defaultMetrics: !1,
            depth: r[0],
            height: r[1],
            italic: r[2],
            skew: r[3],
          }
        : {
            defaultMetrics: !0,
            depth: 0.2,
            height: 0.7,
            italic: 0,
            skew: 0,
          };
    }

    function b(t, e, s = NaN) {
      if ("string" == typeof t) {
        const s = t.match(/([-+]?[0-9.]*)\s*([a-zA-Z]+)/);
        s
          ? ((t = parseFloat(s[1])), (e = s[2].toLowerCase()))
          : (t = parseFloat(t));
      }
      const i =
        {
          pt: 1,
          mm: 7227 / 2540,
          cm: 7227 / 254,
          ex: 35271 / 8192,
          px: 0.75,
          em: c,
          bp: 1.00375,
          dd: 1238 / 1157,
          pc: 12,
          in: 72.27,
          mu: 10 / 18,
        }[e] || 1;
      if (isFinite(s)) {
        const e = Math.pow(10, s);
        return Math.round((t / c) * i * e) / e;
      }
      return (t / c) * i;
    }

    function x(t, e) {
      return b(t, e) * (4 / 3) * c;
    }
    class v {
      constructor(t, e, i, a) {
        (this.id = t),
          (this.size = e),
          (this.cramped = a),
          (this.sizeMultiplier = i),
          (this.metrics = Object.keys(s).reduce(
            (t, e) => ({
              ...t,
              [e]: s[e][this.size],
            }),
            {}
          )),
          (this.metrics.emPerEx = s.xHeight[this.size] / s.quad[this.size]);
      }
      sup() {
        return k[[4, 5, 4, 5, 6, 7, 6, 7][this.id]];
      }
      sub() {
        return k[[5, 5, 5, 5, 7, 7, 7, 7][this.id]];
      }
      fracNum() {
        return k[[2, 3, 4, 5, 6, 7, 6, 7][this.id]];
      }
      fracDen() {
        return k[[3, 3, 5, 5, 7, 7, 7, 7][this.id]];
      }
      cramp() {
        return k[[1, 1, 3, 3, 5, 5, 7, 7][this.id]];
      }
      cls() {
        return [
          "displaystyle textstyle",
          "textstyle",
          "scriptstyle",
          "scriptscriptstyle",
        ][this.size];
      }
      adjustTo(t) {
        let e = [
          [
            "",
            "",
            "reset-textstyle scriptstyle",
            "reset-textstyle scriptscriptstyle",
          ],
          [
            "reset-textstyle displaystyle textstyle",
            "",
            "reset-textstyle scriptstyle",
            "reset-textstyle scriptscriptstyle",
          ],
          [
            "reset-scriptstyle textstyle displaystyle",
            "reset-scriptstyle textstyle",
            "",
            "reset-scriptstyle scriptscriptstyle",
          ],
          [
            "reset-scriptscriptstyle textstyle displaystyle",
            "reset-scriptscriptstyle textstyle",
            "reset-scriptscriptstyle scriptstyle",
            "",
          ],
        ][this.size][t.size];
        return e.length > 0 && (e = " " + e), e;
      }
      isTight() {
        return this.size >= 2;
      }
    }
    const k = {
      0: new v(0, 0, 1, !1),
      1: new v(1, 0, 1, !0),
      2: new v(2, 1, 1, !1),
      3: new v(3, 1, 1, !0),
      4: new v(4, 2, 0.7, !1),
      5: new v(5, 2, 0.7, !0),
      6: new v(6, 3, 0.5, !1),
      7: new v(7, 3, 0.5, !0),
    };
    (k.displaystyle = k[0]),
      (k.textstyle = k[2]),
      (k.scriptstyle = k[4]),
      (k.scriptscriptstyle = k[6]);
    class w {
      constructor(t) {
        (this.macros = t.macros || {}),
          (this.atomIdsSettings = t.atomIdsSettings),
          (this.mathstyle = t.mathstyle || k.displaystyle),
          (this.letterShapeStyle = t.letterShapeStyle || "tex"),
          (this.size = t.size || "size5"),
          (this.parentMathstyle = t.parentMathstyle || this.mathstyle),
          (this.parentSize = t.parentSize || this.size),
          (this.opacity = t.opacity),
          (this.smartFence = t.smartFence);
      }
      clone(t = {}) {
        const e = new w(this);
        return (
          t &&
            (Object.assign(e, t),
            t.mathstyle
              ? ((e.parentMathstyle = this.mathstyle),
                (e.parentSize = this.size),
                "string" == typeof t.mathstyle &&
                  (e.mathstyle = k[t.mathstyle]))
              : (e.mathstyle = this.mathstyle)),
          e
        );
      }
      setMathstyle(t) {
        t && "auto" !== t && (this.mathstyle = k[t]);
      }
      cramp() {
        return this.clone({
          mathstyle: this.mathstyle.cramp(),
        });
      }
      sup() {
        return this.clone({
          mathstyle: this.mathstyle.sup(),
        });
      }
      sub() {
        return this.clone({
          mathstyle: this.mathstyle.sub(),
        });
      }
    }
    const S = {
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [
          ["leftbraceunder", "midbraceunder", "rightbraceunder"],
          1.6,
          548,
        ],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [
          ["leftharpoondownplus", "rightharpoonplus"],
          1.75,
          716,
        ],
        xleftrightharpoons: [
          ["leftharpoonplus", "rightharpoondownplus"],
          1.75,
          716,
        ],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        xrightleftarrows: [
          ["baraboveleftarrow", "rightarrowabovebar"],
          1.75,
          901,
        ],
        xrightequilibrium: [
          ["baraboveshortleftharpoon", "rightharpoonaboveshortbar"],
          1.75,
          716,
        ],
        xleftequilibrium: [
          ["shortbaraboveleftharpoon", "shortrightharpoonabovebar"],
          1.75,
          716,
        ],
      },
      M = {
        widehat1: [1062, 239, 0.24],
        widehat2: [2364, 300, 0.3],
        widehat3: [2364, 360, 0.36],
        widehat4: [2364, 420, 0.42],
        widecheck1: [1062, 239, 0.24],
        widecheck2: [2364, 300, 0.3],
        widecheck3: [2364, 360, 0.36],
        widecheck4: [2364, 420, 0.42],
        widetilde1: [600, 260, 0.26],
        widetilde2: [1033, 286, 0.286],
        widetilde3: [2339, 306, 0.306],
        widetilde4: [2340, 312, 0.34],
      },
      A = {
        doubleleftarrow:
          "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
        doublerightarrow:
          "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
        leftarrow:
          "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
        leftbrace:
          "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
        leftbraceunder:
          "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
        leftgroup:
          "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
        leftgroupunder:
          "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
        leftharpoon:
          "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
        leftharpoonplus:
          "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
        leftharpoondown:
          "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
        leftharpoondownplus:
          "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
        lefthook:
          "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
        leftlinesegment:
          "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
        leftmapsto:
          "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
        leftToFrom:
          "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
        longequal:
          "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
        midbrace:
          "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
        midbraceunder:
          "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
        oiintSize1:
          "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
        oiintSize2:
          "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
        oiiintSize1:
          "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
        oiiintSize2:
          "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
        rightarrow:
          "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
        rightbrace:
          "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
        rightbraceunder:
          "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
        rightgroup:
          "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
        rightgroupunder:
          "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
        rightharpoon:
          "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
        rightharpoonplus:
          "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
        rightharpoondown:
          "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
        rightharpoondownplus:
          "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
        righthook:
          "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
        rightlinesegment:
          "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
        rightToFrom:
          "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
        twoheadleftarrow:
          "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
        twoheadrightarrow:
          "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
        widetilde1:
          "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
        widetilde2:
          "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
        widetilde3:
          "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
        widetilde4:
          "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
        vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
        widehat1:
          "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
        widehat2:
          "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat3:
          "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat4:
          "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widecheck1:
          "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
        widecheck2:
          "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck3:
          "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck4:
          "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        baraboveleftarrow:
          "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
        rightarrowabovebar:
          "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
        baraboveshortleftharpoon:
          "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
        rightharpoonaboveshortbar:
          "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
        shortbaraboveleftharpoon:
          "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
        shortrightharpoonabovebar:
          "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z",
      };

    function _(t, e) {
      const s = [];
      let i,
        a = [];
      return (
        t.forEach((t) => {
          if ("first" !== t.type) {
            let r;
            "variant" === e
              ? ((r = t.variant),
                t.variantStyle &&
                  "up" !== t.variantStyle &&
                  (r += "-" + t.variantStyle))
              : (r = t[e]),
              r !== i
                ? (a.length > 0 && s.push(a), (a = [t]), (i = r))
                : a.push(t);
          }
        }),
        a.length > 0 && s.push(a),
        s
      );
    }
    const C = {};

    function L(t, e) {
      C[t] = {
        ...e,
      };
    }
    const z = [
      "",
      "mord",
      "mbin",
      "mop",
      "mrel",
      "mopen",
      "mclose",
      "mpunct",
      "minner",
      "spacing",
      "first",
      "command",
      "error",
      "placeholder",
      "textord",
      "none",
    ];

    function $(t) {
      return z.includes(t);
    }
    const T = {
        "mord+mop": 3,
        "mord+mbin": 4,
        "mord+mrel": 5,
        "mord+minner": 3,
        "mop+mord": 3,
        "mop+mop": 3,
        "mop+mbin": 5,
        "mop+minner": 3,
        "mbin+mord": 4,
        "mbin+mop": 4,
        "mbin+mopen": 4,
        "mbin+minner": 4,
        "mrel+mord": 5,
        "mrel+mop": 5,
        "mrel+mopen": 5,
        "mrel+minner": 5,
        "mclose+mop": 3,
        "mclose+mbin": 4,
        "mclose+mrel": 5,
        "mclose+minner": 3,
        "mpunct+mord": 3,
        "mpunct+mop": 3,
        "mpunct+mbin": 4,
        "mpunct+mrel": 5,
        "mpunct+mopen": 3,
        "mpunct+mpunct": 3,
        "mpunct+minner": 3,
      },
      D = ["​", " ", "  ", " ", " ", "  ", " ", "", "", " "],
      F = ["", " ⁣", "", " ⁣", " ⁣", " ⁣"],
      q = {
        "mord+mop": 3,
        "mop+mord": 3,
        "mop+mop": 3,
        "mclose+mop": 3,
        "minner+mop": 3,
      };

    function E(t) {
      if ("string" == typeof t) return t;
      if ("number" == typeof t)
        return Number(Math.ceil(100 * t) / 100).toString();
      if (void 0 === t) return "";
      if (Array.isArray(t)) {
        let e = "";
        for (const s of t) e += E(s);
        return e;
      }
      return "";
    }
    class P {
      constructor(t, e = "", s = "") {
        (this.classes = e),
          Array.isArray(t)
            ? (this.children = [].concat(...t))
            : "string" == typeof t
            ? (this.body = t)
            : t && "object" == typeof t && (this.children = [t]),
          (this.type = s),
          (this.style = null),
          this.updateDimensions();
      }
      updateDimensions() {
        let t = 0,
          e = 0,
          s = 1;
        this.children &&
          this.children.forEach((i) => {
            i.height > t && (t = i.height),
              i.depth > e && (e = i.depth),
              i.maxFontSize > s && (s = i.maxFontSize);
          }),
          (this.height = t),
          (this.depth = e),
          (this.maxFontSize = s);
      }
      selected(t) {
        t &&
          !/ML__selected/.test(this.classes) &&
          (this.classes.length > 0 && (this.classes += " "),
          (this.classes += "ML__selected")),
          !t &&
            /ML__selected/.test(this.classes) &&
            (this.classes = this.classes.replace("ML__selected", "")),
          this.children && this.children.forEach((e) => e.selected(t));
      }
      applyStyle(t) {
        if (!t) return;
        if (
          (t.color &&
            ("none" !== t.color
              ? this.setStyle("color", t.color)
              : this.setStyle("color", "")),
          t.backgroundColor &&
            ("none" !== t.backgroundColor
              ? this.setStyle("background-color", t.backgroundColor)
              : this.setStyle("background-color", "")),
          t.cssClass && (this.classes += " " + t.cssClass),
          !this.body)
        )
          return;
        const e = (function (t, e) {
          return C[e.mode] && C[e.mode].applyStyle
            ? C[e.mode].applyStyle(t, e)
            : "";
        })(this, t);
        if (this.body && e) {
          (this.maxFontSize =
            {
              size1: 0.5,
              size2: 0.7,
              size3: 0.8,
              size4: 0.9,
              size5: 1,
              size6: 1.2,
              size7: 1.44,
              size8: 1.73,
              size9: 2.07,
              size10: 2.49,
            }[t.fontSize] || 1),
            (this.height = 0),
            (this.depth = 0),
            (this.skew = 0),
            (this.italic = 0);
          for (let t = 0; t < this.body.length; t++) {
            const s = y(this.body.charAt(t), e);
            s &&
              ((this.height = Math.max(this.height, s.height)),
              (this.depth = Math.max(this.depth, s.depth)),
              (this.skew = s.skew),
              (this.italic = s.italic));
          }
        }
      }
      setStyle(t, ...e) {
        const s = E(e);
        s.length > 0 && (this.style || (this.style = {}), (this.style[t] = s));
      }
      setTop(t) {
        t &&
          0 !== t &&
          (this.style || (this.style = {}),
          (this.style.top = E(t) + "em"),
          (this.height -= t),
          (this.depth += t));
      }
      setLeft(t) {
        t &&
          0 !== t &&
          (this.style || (this.style = {}),
          (this.style["margin-left"] = E(t) + "em"));
      }
      setRight(t) {
        t &&
          0 !== t &&
          (this.style || (this.style = {}),
          (this.style["margin-right"] = E(t) + "em"));
      }
      setWidth(t) {
        t &&
          0 !== t &&
          (this.style || (this.style = {}), (this.style.width = E(t) + "em"));
      }
      toMarkup(t = 1, e = 1) {
        var s;
        let i = "",
          a = this.body || "";
        if (this.children) {
          let t = "none";
          for (const s of this.children) {
            let i = 0;
            if (t) {
              let a = s.type;
              a &&
                ("textord" === a && (a = "mord"),
                "first" === a && (a = "none"),
                (i = s.isTight ? q[t + "+" + a] || 0 : T[t + "+" + a] || 0),
                (i = Math.floor(e * i)));
            }
            (a += s.toMarkup(i, e)), (t = B(s));
          }
        }
        if (
          ("​" !== a && (a || this.svgBody)) ||
          (this.classes && "ML__selected" !== this.classes) ||
          this.cssId ||
          this.style ||
          this.svgOverlay
        ) {
          (i = "<span"),
            this.cssId && (i += ' id="' + this.cssId + '" '),
            this.attributes &&
              (i +=
                " " +
                Object.keys(this.attributes)
                  .map((t) => `${t}="${this.attributes[t]}"`)
                  .join(" "));
          const e = this.classes.split(" ");
          e.push(
            null !==
              (s = {
                command: "ML__command",
                placeholder: "ML__placeholder",
                error: "ML__error",
              }[this.type]) && void 0 !== s
              ? s
              : ""
          ),
            this.caret &&
              "command" === this.type &&
              e.push("ML__command-caret");
          let r = "";
          if (
            ((r =
              e.length > 1
                ? e
                    .filter(function (t, e, s) {
                      return t.length > 0 && s.indexOf(t) === e;
                    })
                    .join(" ")
                : e[0]),
            r.length > 0 && (i += ` class="${r}"`),
            t &&
              (this.style && this.style["margin-left"]
                ? (this.style["margin-left"] =
                    E(parseFloat(this.style["margin-left"]) + t / 18) + "em")
                : t < 0 && F[-t]
                ? (a = F[-t] + a)
                : D[t]
                ? (a = D[t] + a)
                : (this.style || (this.style = {}),
                  (this.style["margin-left"] = E(t / 18) + "em"))),
            this.style)
          ) {
            let t = "";
            const e = /ML__selected/.test(this.classes);
            for (const s in this.style)
              Object.prototype.hasOwnProperty.call(this.style, s) &&
                (("background-color" === s && e) ||
                  (t += s + ":" + this.style[s] + ";"));
            t.length > 0 && (i += ' style="' + t + '"');
          }
          (i += ">"),
            this.svgBody
              ? (i += (function (t) {
                  if (M[t]) {
                    const e = M[t][2];
                    return `<span style="height:${e}em;min-width:0">${
                      `<span class="stretchy" style="height:${e}em">` +
                      `<svg width="100%" height="${e}em"` +
                      `viewBox="0 0 ${M[t][0]} ${M[t][1]}"` +
                      'preserveAspectRatio="none">' +
                      `<path d="${A[t]}"></path>` +
                      "</svg></span>"
                    }</span>`;
                  }
                  const [e, s, i, a] = S[t];
                  let r, n;
                  const o = i / 1e3;
                  3 === e.length
                    ? ((r = ["slice-1-of-3", "slice-2-of-3", "slice-3-of-3"]),
                      (n = ["xMinYMin", "xMidYMin", "xMaxYMin"]))
                    : 2 === e.length
                    ? ((r = ["slice-1-of-2", "slice-2-of-2"]),
                      (n = ["xMinYMin", "xMaxYMin"]))
                    : ((r = ["slice-1-of-1"]), (n = [a]));
                  const l = e
                    .map(
                      (t, e) =>
                        `<span class="${r[e]}" style="height:${o}em">` +
                        `<svg width="400em" height="${o}em"` +
                        `viewBox="0 0 400000 ${i}"` +
                        `preserveAspectRatio="${n[e]} slice">` +
                        `<path d="${A[t]}"></path>` +
                        "</svg></span>"
                    )
                    .join("");
                  return `<span style="height:${o}em;min-width:${s}em">${l}</span>`;
                })(this.svgBody))
              : this.svgOverlay
              ? ((i += '<span style="'),
                (i += "display: inline-block;"),
                (i += "height:" + (this.height + this.depth) + "em;"),
                (i += "vertical-align:" + this.depth + "em;"),
                (i += '">'),
                (i += a),
                (i += "</span>"),
                (i += "<svg "),
                (i += 'style="position:absolute;'),
                (i += "overflow:overlay;"),
                (i += "height:" + (this.height + this.depth) + "em;"),
                this.style && this.style.padding
                  ? ((i += "top:" + this.style.padding + ";"),
                    (i += "left:" + this.style.padding + ";"),
                    (i +=
                      "width:calc(100% - 2 * " + this.style.padding + " );"))
                  : ((i += "top:0;"), (i += "left:0;"), (i += "width:100%;")),
                (i += "z-index:2;"),
                (i += '"'),
                this.svgStyle && (i += ' style="' + this.svgStyle + '"'),
                (i += ">"),
                (i += this.svgOverlay),
                (i += "</svg>"))
              : (i += a),
            (i += "</span>");
        } else i = "";
        return (
          this.caret &&
            "command" !== this.type &&
            ("text" === this.caret
              ? (i += '<span class="ML__text-caret"></span>')
              : (i += '<span class="ML__caret"></span>')),
          i
        );
      }
      tryCoalesceWith(t) {
        if (this.type !== t.type) return !1;
        if (
          "error" === this.type ||
          "placeholder" === this.type ||
          "command" === this.type
        )
          return !1;
        if (this.svgBody || !this.body) return !1;
        if (t.svgBody || !t.body) return !1;
        const e = this.children && this.children.length > 0,
          s = t.children && t.children.length > 0;
        if (e || s) return !1;
        if (
          (this.style ? this.style.length : 0) !==
          (t.style ? t.style.length : 0)
        )
          return !1;
        const i = this.classes.trim().replace(/\s+/g, " ").split(" "),
          a = t.classes.trim().replace(/\s+/g, " ").split(" ");
        if (i.length !== a.length) return !1;
        i.sort(), a.sort();
        for (let t = 0; t < i.length; t++) {
          if ("vertical-separator" === i[t]) return !1;
          if (i[t] !== a[t]) return !1;
        }
        if (this.style && t.style)
          for (const e in this.style)
            if (
              Object.prototype.hasOwnProperty.call(this.style, e) &&
              Object.prototype.hasOwnProperty.call(t.style, e) &&
              this.style[e] !== t.style[e]
            )
              return !1;
        return (
          (this.body += t.body),
          (this.height = Math.max(this.height, t.height)),
          (this.depth = Math.max(this.depth, t.depth)),
          (this.maxFontSize = Math.max(this.maxFontSize, t.maxFontSize)),
          (this.italic = t.italic),
          !0
        );
      }
    }

    function B(t) {
      const e = t.type;
      return "first" === e ? "none" : "textord" === e ? "mord" : e;
    }

    function K(t) {
      return t
        ? Array.isArray(t)
          ? t.reduce((t, e) => Math.max(t, e.height), 0)
          : t.height
        : 0;
    }

    function O(t) {
      return t
        ? Array.isArray(t)
          ? t.reduce((t, e) => Math.max(t, e.depth), 0)
          : t.depth
        : 0;
    }

    function R(t) {
      return t ? (Array.isArray(t) ? t[t.length - 1].italic : t.italic) : 0;
    }

    function I(t, e = "", s = "") {
      if (Array.isArray(t)) {
        const i = t.filter((t) => !!t);
        return 1 === i.length ? new P(i[0], e, s) : new P(i, e, s);
      }
      return new P(t, e, s);
    }

    function N(t, e, s = "", i = "") {
      const a = new P(e, s, i),
        r = y(e, t);
      return (
        (a.height = r.height),
        (a.depth = r.depth),
        (a.skew = r.skew),
        (a.italic = r.italic),
        a.setRight(a.italic),
        a
      );
    }

    function H(t, e = "", s = "") {
      const i = I("", "ML__strut");
      let a, r;
      return (
        i.setStyle("height", K(t), "em"),
        0 !== O(t) &&
          ((a = I("", "ML__strut--bottom")),
          a.setStyle("height", K(t) + O(t), "em"),
          a.setStyle("vertical-align", -O(t), "em")),
        (r = Array.isArray(t) ? [i, a, ...t] : [i, a, t]),
        I(r, e, s)
      );
    }

    function W(t, e, s, i, a) {
      a = a || "";
      const r = V(e, (a += " style-wrap ") + s.adjustTo(i));
      r.type = t;
      const n = i.sizeMultiplier / s.sizeMultiplier;
      return (
        (r.height *= n), (r.depth *= n), (r.maxFontSize = i.sizeMultiplier), r
      );
    }

    function V(t, e = "", s = "") {
      if (!e) {
        if (t instanceof P) return t;
        if (Array.isArray(t) && 1 === t.length) return t[0];
      }
      const i = new P(t, e, s);
      let a = 1;
      return (
        (a =
          t instanceof P
            ? t.maxFontSize
            : t.reduce((t, e) => Math.max(t, e.maxFontSize), 0)),
        (i.height *= a),
        (i.depth *= a),
        i
      );
    }

    function j(t, e, s = "shift", i = 0) {
      let a = 0,
        r = 0;
      s = s || "shift";
      for (let t = 0; t < e.length; t++)
        Array.isArray(e[t]) &&
          (1 === e[t].length ? (e[t] = e[t][0]) : (e[t] = I(e[t])));
      if ("shift" === s) a = -e[0].depth - i;
      else if ("bottom" === s) a = -i;
      else if ("top" === s) {
        let t = i;
        for (const s of e)
          s instanceof P
            ? (t -= s.height + s.depth)
            : "number" == typeof s && (t -= s);
        a = t;
      } else if ("individualShift" === s) {
        const t = e;
        (e = [t[0]]), (a = -t[1] - t[0].depth), (r = a);
        for (let s = 2; s < t.length; s += 2) {
          const i = -t[s + 1] - r - t[s].depth;
          r += i;
          const a = i - (t[s - 2].height + t[s - 2].depth);
          e.push(a), e.push(t[s]);
        }
      }
      let n = 1;
      for (const t of e) t instanceof P && (n = Math.max(n, t.maxFontSize));
      const o = (function (t, e) {
          const s = e ? e / t.mathstyle.sizeMultiplier : 0,
            i = new P("​");
          return (
            1 !== s &&
              (i.setStyle("font-size", s, s > 0 ? "em" : ""),
              (i.attributes = {
                "aria-hidden": "true",
              })),
            "size5" !== t.size
              ? new P(i, "fontsize-ensurer reset-" + t.size + " size5")
              : 0 !== s
              ? i
              : null
          );
        })(t, n),
        l = [];
      r = a;
      for (const t of e)
        if ("number" == typeof t) r += t;
        else if (t instanceof P) {
          const e = I([o, t]);
          e.setTop(-t.depth - r), l.push(e), (r += t.height + t.depth);
        }
      const c = I(l, "vlist");
      return (
        (c.depth = Math.max(a, O(c) || 0)),
        (c.height = Math.max(-r, K(c) || 0)),
        c
      );
    }

    function U(t) {
      const e = new P(null);
      return (
        (e.svgBody = t),
        (e.height =
          (function (t) {
            return S[t] ? S[t][2] / 1e3 : M[t][2];
          })(t) / 2),
        (e.depth = e.height),
        e
      );
    }
    const G = {},
      Z = {
        "<": "<",
        ">": ">",
        o: "o",
        "&": "\\&",
        "{": "\\{",
        "}": "\\}",
        "[": "\\lbrack",
        "]": "\\rbrack",
        ":": "\\colon",
        " ": "~",
        "¬": "\\neg",
        "·": "\\cdot",
        "¼": "\\frac{1}{4}",
        "½": "\\frac{1}{2}",
        "¾": "\\frac{3}{4}",
        "⁰": "^{0}",
        ⁱ: "^{i}",
        "¹": "^{1}",
        "²": "^{2}",
        "³": "^{3}",
        "†": "\\dagger",
        "‡": "\\ddagger",
        "…": "\\ldots",
        "⁴": "^{4}",
        "⁵": "^{5}",
        "⁶": "^{6}",
        "⁷": "^{7}",
        "⁸": "^{8}",
        "⁹": "^{9}",
        "⁺": "^{+}",
        "⁻": "^{-}",
        "⁼": "^{=}",
        ⁿ: "^{n}",
        "₀": "_{0}",
        "₁": "_{1}",
        "₂": "_{2}",
        "₃": "_{3}",
        "₄": "_{4}",
        "₅": "_{5}",
        "₆": "_{6}",
        "₇": "_{7}",
        "₈": "_{8}",
        "₉": "_{9}",
        "₊": "_{+}",
        "₋": "_{-}",
        "₌": "_{=}",
        ₐ: "_{a}",
        ₑ: "_{e}",
        ₒ: "_{o}",
        ₓ: "_{x}",
        "′": "\\prime",
        "'": "\\prime",
        "←": "\\gets",
        "→": "\\to",
        "△": "\\triangle",
        "▽": "\\triangledown",
        "∋": "\\owns",
        "∗": "\\ast",
        "∣": "\\vert",
        "∥": "\\Vert",
        "∧": "\\land",
        "∨": "\\lor",
        "⋅": "\\cdot",
        "⋈": "\\bowtie",
        "≠": "\\ne",
        "≤": "\\le",
        "≥": "\\ge",
        "⊥": "\\bot",
        "⟷": "\\biconditional",
        "⟸": "\\impliedby",
        "⟹": "\\implies",
        ℂ: "\\C",
        ℕ: "\\N",
        ℙ: "\\P",
        ℚ: "\\Q",
        ℝ: "\\R",
        ℤ: "\\Z",
      },
      X = {},
      Y = {},
      J = {
        iff: "\\;⟺\\;",
        nicefrac: "^{#1}\\!\\!/\\!_{#2}",
        bra: "\\mathinner{\\langle{#1}|}",
        ket: "\\mathinner{|{#1}\\rangle}",
        braket: "\\mathinner{\\langle{#1}\\rangle}",
        set: "\\mathinner{\\lbrace #1 \\rbrace}",
        Bra: "\\left\\langle #1\\right|",
        Ket: "\\left|#1\\right\\rangle",
        Braket: "\\left\\langle{#1}\\right\\rangle",
        Set: "\\left\\lbrace #1 \\right\\rbrace",
      },
      Q = {
        "(": ")",
        "{": "}",
        "[": "]",
        "|": "|",
        "\\lbrace": "\\rbrace",
        "\\{": "\\}",
        "\\langle": "\\rangle",
        "\\lfloor": "\\rfloor",
        "\\lceil": "\\rceil",
        "\\vert": "\\vert",
        "\\lvert": "\\rvert",
        "\\Vert": "\\Vert",
        "\\lVert": "\\rVert",
        "\\lbrack": "\\rbrack",
        "\\ulcorner": "\\urcorner",
        "\\llcorner": "\\lrcorner",
        "\\lgroup": "\\rgroup",
        "\\lmoustache": "\\rmoustache",
      },
      tt = {
        "\\#": "#",
        "\\&": "&",
        "\\$": "$",
        "\\%": "%",
        "\\_": "_",
        "\\euro": "€",
        "\\maltese": "✠",
        "\\{": "{",
        "\\}": "}",
        "\\nobreakspace": " ",
        "\\ldots": "…",
        "\\textellipsis": "…",
        "\\backslash": "\\",
        "`": "‘",
        "'": "’",
        "``": "“",
        "''": "”",
        "\\degree": "°",
        "\\textasciicircum": "^",
        "\\textasciitilde": "~",
        "\\textasteriskcentered": "*",
        "\\textbackslash": "\\",
        "\\textbraceleft": "{",
        "\\textbraceright": "}",
        "\\textbullet": "•",
        "\\textdollar": "$",
        "\\textsterling": "£",
        "\\textdagger": "†",
        "\\textdaggerdbl": "‡",
        "–": "–",
        "—": "—",
        "‘": "‘",
        "’": "’",
        "“": "“",
        "”": "”",
        '"': "”",
        "\\ss": "ß",
        "\\ae": "æ",
        "\\oe": "œ",
        "\\AE": "Æ",
        "\\OE": "Œ",
        "\\O": "Ø",
        "\\i": "ı",
        "\\j": "ȷ",
        "\\aa": "å",
        "\\AA": "Å",
      },
      et = /[a-zA-Z0-9!@*()-=+{}[\]\\';:?/.,~<>`|'$%#&^_" ]/,
      st =
        "undefined" != typeof navigator &&
        /firefox|edge/i.test(navigator.userAgent)
          ? /[a-zA-ZаАбБвВгГдДеЕёЁжЖзЗиИйЙкКлЛмМнНоОпПрРсСтТуУфФхХцЦчЧшШщЩъЪыЫьЬэЭюЮяĄąĆćĘęŁłŃńÓóŚśŹźŻżàâäôéèëêïîçùûüÿæœÀÂÄÔÉÈËÊÏÎŸÇÙÛÜÆŒäöüßÄÖÜẞàèéìíîòóùúÀÈÉÌÍÎÒÓÙÚáéíñóúüÁÉÍÑÓÚÜ]/
          : new RegExp("\\p{Letter}", "u"),
      it =
        "undefined" != typeof navigator &&
        /firefox|edge/i.test(navigator.userAgent)
          ? /[0-9a-zA-ZаАбБвВгГдДеЕёЁжЖзЗиИйЙкКлЛмМнНоОпПрРсСтТуУфФхХцЦчЧшШщЩъЪыЫьЬэЭюЮяĄąĆćĘęŁłŃńÓóŚśŹźŻżàâäôéèëêïîçùûüÿæœÀÂÄÔÉÈËÊÏÎŸÇÙÛÜÆŒäöüßÄÖÜẞàèéìíîòóùúÀÈÉÌÍÎÒÓÙÚáéíñóúüÁÉÍÑÓÚÜ]/
          : new RegExp("[0-9\\p{Letter}]", "u");

    function at(t, e, s = "mord", i = "") {
      (G[t] = {
        type: s,
        variant: i,
        value: e,
      }),
        Z[e] || i || (Z[e] = t);
    }

    function rt(t, e) {
      for (let s = t; s <= e; s++) {
        const t = String.fromCodePoint(s);
        at(t, t);
      }
    }

    function nt(t, e) {
      return "math" === t
        ? Z[e] || e
        : ("text" === t && Object.keys(tt).find((t) => tt[t] === e)) || e;
    }
    const ot = {
        119893: 8462,
        119965: 8492,
        119968: 8496,
        119969: 8497,
        119971: 8459,
        119972: 8464,
        119975: 8466,
        119976: 8499,
        119981: 8475,
        119994: 8495,
        119996: 8458,
        120004: 8500,
        120070: 8493,
        120075: 8460,
        120076: 8465,
        120085: 8476,
        120093: 8488,
        120122: 8450,
        120127: 8461,
        120133: 8469,
        120135: 8473,
        120136: 8474,
        120137: 8477,
        120145: 8484,
      },
      lt = [
        {
          start: 119808,
          len: 26,
          offset: 65,
          style: "bold",
        },
        {
          start: 119834,
          len: 26,
          offset: 97,
          style: "bold",
        },
        {
          start: 119860,
          len: 26,
          offset: 65,
          style: "italic",
        },
        {
          start: 119886,
          len: 26,
          offset: 97,
          style: "italic",
        },
        {
          start: 119912,
          len: 26,
          offset: 65,
          style: "bolditalic",
        },
        {
          start: 119938,
          len: 26,
          offset: 97,
          style: "bolditalic",
        },
        {
          start: 119964,
          len: 26,
          offset: 65,
          variant: "script",
        },
        {
          start: 119990,
          len: 26,
          offset: 97,
          variant: "script",
        },
        {
          start: 120016,
          len: 26,
          offset: 65,
          variant: "script",
          style: "bold",
        },
        {
          start: 120042,
          len: 26,
          offset: 97,
          variant: "script",
          style: "bold",
        },
        {
          start: 120068,
          len: 26,
          offset: 65,
          variant: "fraktur",
        },
        {
          start: 120094,
          len: 26,
          offset: 97,
          variant: "fraktur",
        },
        {
          start: 120172,
          len: 26,
          offset: 65,
          variant: "fraktur",
          style: "bold",
        },
        {
          start: 120198,
          len: 26,
          offset: 97,
          variant: "fraktur",
          style: "bold",
        },
        {
          start: 120120,
          len: 26,
          offset: 65,
          variant: "double-struck",
        },
        {
          start: 120146,
          len: 26,
          offset: 97,
          variant: "double-struck",
        },
        {
          start: 120224,
          len: 26,
          offset: 65,
          variant: "sans-serif",
        },
        {
          start: 120250,
          len: 26,
          offset: 97,
          variant: "sans-serif",
        },
        {
          start: 120276,
          len: 26,
          offset: 65,
          variant: "sans-serif",
          style: "bold",
        },
        {
          start: 120302,
          len: 26,
          offset: 97,
          variant: "sans-serif",
          style: "bold",
        },
        {
          start: 120328,
          len: 26,
          offset: 65,
          variant: "sans-serif",
          style: "italic",
        },
        {
          start: 120354,
          len: 26,
          offset: 97,
          variant: "sans-serif",
          style: "italic",
        },
        {
          start: 120380,
          len: 26,
          offset: 65,
          variant: "sans-serif",
          style: "bolditalic",
        },
        {
          start: 120406,
          len: 26,
          offset: 97,
          variant: "sans-serif",
          style: "bolditalic",
        },
        {
          start: 120432,
          len: 26,
          offset: 65,
          variant: "monospace",
        },
        {
          start: 120458,
          len: 26,
          offset: 97,
          variant: "monospace",
        },
        {
          start: 120488,
          len: 25,
          offset: 913,
          style: "bold",
        },
        {
          start: 120514,
          len: 25,
          offset: 945,
          style: "bold",
        },
        {
          start: 120546,
          len: 25,
          offset: 913,
          style: "italic",
        },
        {
          start: 120572,
          len: 25,
          offset: 945,
          style: "italic",
        },
        {
          start: 120604,
          len: 25,
          offset: 913,
          style: "bolditalic",
        },
        {
          start: 120630,
          len: 25,
          offset: 945,
          style: "bolditalic",
        },
        {
          start: 120662,
          len: 25,
          offset: 913,
          variant: "sans-serif",
          style: "bold",
        },
        {
          start: 120688,
          len: 25,
          offset: 945,
          variant: "sans-serif",
          style: "bold",
        },
        {
          start: 120720,
          len: 25,
          offset: 913,
          variant: "sans-serif",
          style: "bolditalic",
        },
        {
          start: 120746,
          len: 25,
          offset: 945,
          variant: "sans-serif",
          style: "bolditalic",
        },
        {
          start: 120782,
          len: 10,
          offset: 48,
          variant: "",
          style: "bold",
        },
        {
          start: 120792,
          len: 10,
          offset: 48,
          variant: "double-struck",
        },
        {
          start: 120803,
          len: 10,
          offset: 48,
          variant: "sans-serif",
        },
        {
          start: 120812,
          len: 10,
          offset: 48,
          variant: "sans-serif",
          style: "bold",
        },
        {
          start: 120822,
          len: 10,
          offset: 48,
          variant: "monospace",
        },
      ];

    function ct(t, e, s) {
      if (!/[A-Za-z0-9]/.test(t)) return t;
      if (!e && !s) return t;
      const i = t.codePointAt(0);
      for (let t = 0; t < lt.length; t++)
        if (
          (!e || lt[t].variant === e) &&
          (!s || lt[t].style === s) &&
          i >= lt[t].offset &&
          i < lt[t].offset + lt[t].len
        ) {
          const e = lt[t].start + i - lt[t].offset;
          return String.fromCodePoint(ot[e] || e);
        }
      return t;
    }

    function ht(t, e) {
      if ("text" === t) return nt(t, e) || e;
      let s;
      if (((s = nt(t, e)), s)) return s;
      const i = (function (t) {
        if ((t < 119808 || t > 120831) && (t < 8448 || t > 8527))
          return {
            char: String.fromCodePoint(t),
          };
        for (const e in ot)
          if (Object.prototype.hasOwnProperty.call(ot, e) && ot[e] === t) {
            t = e.codePointAt(0);
            break;
          }
        for (let e = 0; e < lt.length; e++)
          if (t >= lt[e].start && t < lt[e].start + lt[e].len)
            return {
              char: String.fromCodePoint(t - lt[e].start + lt[e].offset),
              variant: lt[e].variant,
              style: lt[e].style,
            };
        return {
          char: String.fromCodePoint(t),
        };
      })(e.codePointAt(0));
      return i.style || i.variant
        ? ((s = i.char),
          i.variant && (s = "\\" + i.variant + "{" + s + "}"),
          "bold" === i.style
            ? (s = "\\mathbf{" + s + "}")
            : "italic" === i.style
            ? (s = "\\mathit{" + s + "}")
            : "bolditalic" === i.style && (s = "\\mathbfit{" + s + "}"),
          "\\mathord{" + s + "}")
        : "";
    }

    function dt(t, e) {
      let s = "",
        i = !1;
      for (const a of e) {
        i && (s += "text" === t ? "{}" : " "), (i = !1);
        const e = ht(t, a);
        e ? ((s += e), (i = /\\[a-zA-Z0-9]+\*?$/.test(e))) : (s += a);
      }
      return s;
    }

    function mt(t, e) {
      return "math" === t
        ? G[e] && G[e].value
          ? G[e].value
          : e
        : tt[e]
        ? tt[e]
        : e;
    }

    function pt(t, e, s, i) {
      return X[t] && X[t].emit
        ? X[t].emit(t, e, s, i)
        : G[t] || tt[t]
        ? t + (/^\\.*[a-zA-Z0-9]$/.test(t) ? " " : "")
        : X[t] && X[t].params && 1 === X[t].params.length && s.body
        ? t + "{" + i(s, s.body) + "}"
        : t;
    }

    function ut(t) {
      let e = Y[t];
      return (
        e ||
          (e = {
            params: "",
            parser: null,
            mathstyle: "displaystyle",
            tabular: !0,
            colFormat: [],
            lFence: ".",
            rFence: ".",
          }),
        e
      );
    }

    function ft(t, e, s) {
      if (!t || 0 === t.length) return null;
      let i = null;
      if ("\\" === t.charAt(0)) {
        if (((i = X[t]), i)) return i.mode && !i.mode.includes(e) ? null : i;
        if (
          (i ||
            ("math" === e
              ? (i = G[t])
              : tt[t] &&
                (i = {
                  value: tt[t],
                })),
          !i)
        ) {
          const e = t.slice(1);
          if (s && s[e]) {
            let t = s[e];
            "object" == typeof t && (t = t.def);
            let a = 0;
            for (
              /(^|[^\\])#1/.test(t) && (a = 1),
                /(^|[^\\])#2/.test(t) && (a = 2),
                /(^|[^\\])#3/.test(t) && (a = 3),
                /(^|[^\\])#4/.test(t) && (a = 4),
                /(^|[^\\])#5/.test(t) && (a = 5),
                /(^|[^\\])#6/.test(t) && (a = 6),
                /(^|[^\\])#7/.test(t) && (a = 7),
                /(^|[^\\])#8/.test(t) && (a = 8),
                /(^|[^\\])#9/.test(t) && (a = 9),
                i = {
                  type: "group",
                  mode: "math",
                  params: [],
                  infix: !1,
                };
              a >= 1;

            )
              i.params.push({
                optional: !1,
                type: "math",
                defaultValue: null,
                placeholder: null,
              }),
                (a -= 1);
          }
        }
      } else
        "math" === e
          ? (i = G[t])
          : tt[t] &&
            (i = {
              value: tt[t],
            });
      return (
        !i ||
          "mord" !== i.type ||
          ("f" !== i.value && "g" !== i.value && "h" !== i.value) ||
          (i.isFunction = !0),
        i
      );
    }

    function gt(t) {
      if (t.length <= 1) return [];
      const e = [];
      for (const s in X)
        Object.prototype.hasOwnProperty.call(X, s) &&
          s.startsWith(t) &&
          !X[s].infix &&
          e.push({
            match: s,
            frequency: X[s].frequency,
          });
      for (const s in G)
        Object.prototype.hasOwnProperty.call(G, s) &&
          s.startsWith(t) &&
          e.push({
            match: s,
            frequency: G[s].frequency,
          });
      return (
        e.sort((t, e) =>
          t.frequency === e.frequency
            ? t.match.length - e.match.length
            : (e.frequency || 0) - (t.frequency || 0)
        ),
        e
      );
    }

    function yt(t, e) {
      let s = t.match(/=(.+)/);
      const i = s ? s[1] : e ? "[]" : "{}";
      let a = "auto",
        r = null;
      return (
        (s = t.match(/:([^=]+)/)),
        s && (a = s[1].trim()),
        (s = t.match(/^([^:=]+)/)),
        s && (r = s[1].trim()),
        {
          optional: e,
          type: a,
          defaultValue: i,
          placeholder: r,
        }
      );
    }

    function bt(t) {
      if (!t) return [];
      let e = [],
        s = t.split("]");
      if ("[" === s[0].charAt(0)) {
        e.push(yt(s[0].slice(1), !0));
        for (let t = 1; t <= s.length; t++) e = e.concat(bt(s[t]));
      } else if (((s = t.split("}")), "{" === s[0].charAt(0))) {
        e.push(yt(s[0].slice(1), !1));
        for (let t = 1; t <= s.length; t++) e = e.concat(bt(s[t]));
      }
      return e;
    }

    function xt(t) {
      let e = "",
        s = !0;
      return (
        t.forEach((t) => {
          "string" == typeof t.body ? (e += t.body) : (s = !1);
        }),
        s ? e : ""
      );
    }

    function vt(t, e, s, i) {
      "string" == typeof t && (t = [t]), s || (s = {});
      const a = {
        params: bt(e),
        parser: i,
        tabular: s.tabular || !0,
        colFormat: s.colFormat || [],
      };
      for (const e of t) Y[e] = a;
    }

    function kt(t, e, s, i, a) {
      "string" == typeof t && (t = [t]), s || (s = {});
      const r = {
        params: bt(e),
        mode: s.mode,
        infix: !!s.infix,
        parse: i,
        emit: a,
      };
      t.forEach((t) => {
        X["\\" + t] = r;
      });
    }
    !(function (t) {
      for (let t = 0; t < "0123456789/@.?!".length; t++) {
        const e = "0123456789/@.?!".charAt(t);
        at(e, e);
      }
    })(),
      rt(65, 90),
      rt(97, 122),
      at("\\forall", "∀"),
      at("\\exists", "∃"),
      at("\\nexists", "∄", "mord", "ams"),
      at("\\mid", "∣", "mrel"),
      at("\\top", "⊤"),
      at("\\bot", "⊥"),
      at("\\sharp", "♯"),
      at("\\flat", "♭"),
      at("\\natural", "♮"),
      at("\\#", "#"),
      at("\\&", "&"),
      at("\\clubsuit", "♣"),
      at("\\heartsuit", "♡"),
      at("\\spadesuit", "♠"),
      at("\\diamondsuit", "♢"),
      at("\\differencedelta", "∆", "mrel"),
      at("\\backslash", "\\"),
      at("\\nabla", "∇"),
      at("\\partial", "∂"),
      at("\\ell", "ℓ"),
      at("\\imaginaryI", "i", "mord", "main"),
      at("\\imaginaryJ", "j", "mord", "main"),
      at("\\hbar", "ℏ"),
      at("\\hslash", "ℏ", "mord", "ams"),
      at("\\differentialD", "d", "mord", "main"),
      at("\\rd", "d", "mord", "main"),
      at("\\capitalDifferentialD", "D", "mord", "main"),
      at("\\rD", "D", "mord", "main"),
      at("\\exponentialE", "e", "mord", "main"),
      at("\\Finv", "Ⅎ", "mord", "ams"),
      at("\\Game", "⅁", "mord", "ams"),
      at("\\wp", "℘"),
      at("\\eth", "ð", "mord", "ams"),
      at("\\mho", "℧", "mord", "ams"),
      at("\\Bbbk", "k", "mord", "ams"),
      at("\\doubleStruckCapitalN", "N", "mord", "double-struck"),
      at("\\N", "N", "mord", "double-struck"),
      at("\\doubleStruckCapitalR", "R", "mord", "double-struck"),
      at("\\R", "R", "mord", "double-struck"),
      at("\\doubleStruckCapitalQ", "Q", "mord", "double-struck"),
      at("\\Q", "Q", "mord", "double-struck"),
      at("\\doubleStruckCapitalC", "C", "mord", "double-struck"),
      at("\\C", "C", "mord", "double-struck"),
      at("\\doubleStruckCapitalZ", "Z", "mord", "double-struck"),
      at("\\Z", "Z", "mord", "double-struck"),
      at("\\doubleStruckCapitalP", "P", "mord", "double-struck"),
      at("\\P", "P", "mord", "double-struck"),
      at("\\scriptCapitalE", "E", "mord", "script"),
      at("\\scriptCapitalH", "H", "mord", "script"),
      at("\\scriptCapitalL", "L", "mord", "script"),
      at("\\gothicCapitalC", "C", "mord", "fraktur"),
      at("\\gothicCapitalH", "H", "mord", "fraktur"),
      at("\\gothicCapitalI", "I", "mord", "fraktur"),
      at("\\gothicCapitalR", "R", "mord", "fraktur"),
      at("\\pounds", "£"),
      at("\\yen", "¥", "mord", "ams"),
      at("\\euro", "€"),
      at("\\dagger", "†", "mbin"),
      at("\\dag", "†", "mbin"),
      at("\\ddag", "‡", "mbin"),
      at("\\ddagger", "‡", "mbin"),
      at("\\maltese", "✠", "mord", "ams"),
      at("\\rightarrow", "→", "mrel"),
      at("\\to", "→", "mrel"),
      at("\\leftarrow", "←", "mrel"),
      at("\\gets", "←", "mrel"),
      at("\\Rightarrow", "⇒", "mrel"),
      at("\\Leftarrow", "⇐", "mrel"),
      at("\\longrightarrow", "⟶", "mrel"),
      at("\\longleftarrow", "⟵", "mrel"),
      at("\\Longrightarrow", "⟹", "mrel"),
      at("\\implies", "⟹", "mrel"),
      at("\\Longleftarrow", "⟸", "mrel"),
      at("\\impliedby", "⟸", "mrel"),
      at("\\dashrightarrow", "⇢", "mrel", "ams"),
      at("\\dashleftarrow", "⇠", "mrel", "ams"),
      at("\\Rrightarrow", "⇛", "mrel", "ams"),
      at("\\Lleftarrow", "⇚", "mrel", "ams"),
      at("\\longleftrightarrow", "⟷", "mrel"),
      at("\\biconditional", "⟷", "mrel"),
      at("\\Longleftrightarrow", "⟺", "mrel"),
      at("\\leftrightarrows", "⇆", "mrel", "ams"),
      at("\\rightleftarrows", "⇄", "mrel", "ams"),
      at("\\mapsto", "↦", "mrel"),
      at("\\longmapsto", "⟼", "mrel"),
      at("\\uparrow", "↑", "mrel"),
      at("\\downarrow", "↓", "mrel"),
      at("\\Uparrow", "⇑", "mrel"),
      at("\\Downarrow", "⇓", "mrel"),
      at("\\updownarrow", "↕", "mrel"),
      at("\\Updownarrow", "⇕", "mrel"),
      at("\\curvearrowright", "↷", "mrel", "ams"),
      at("\\curvearrowleft", "↶", "mrel", "ams"),
      at("\\hookrightarrow", "↪", "mrel"),
      at("\\hookleftarrow", "↩", "mrel"),
      at("\\rightharpoonup", "⇀", "mrel"),
      at("\\leftharpoonup", "↼", "mrel"),
      at("\\rightharpoondown", "⇁", "mrel"),
      at("\\leftharpoondown", "↽", "mrel"),
      at("\\rightrightarrows", "⇉", "mrel", "ams"),
      at("\\leftleftarrows", "⇇", "mrel", "ams"),
      at("\\upuparrows", "⇈", "mrel", "ams"),
      at("\\downdownarrows", "⇊", "mrel", "ams"),
      at("\\leftarrowtail", "↢", "mrel", "ams"),
      at("\\rightarrowtail", "↣", "mrel", "ams"),
      at("\\looparrowright", "↬", "mrel", "ams"),
      at("\\looparrowleft", "↫", "mrel", "ams"),
      at("\\twoheadleftarrow", "↞", "mrel", "ams"),
      at("\\twoheadrightarrow", "↠", "mrel", "ams"),
      at("\\rightleftharpoons", "⇌", "mrel"),
      at("\\leftrightharpoons", "⇋", "mrel", "ams"),
      at("\\Rsh", "↱", "mrel", "ams"),
      at("\\Lsh", "↰", "mrel", "ams"),
      at("\\searrow", "↘", "mrel"),
      at("\\nearrow", "↗", "mrel"),
      at("\\swarrow", "↙", "mrel"),
      at("\\nwarrow", "↖", "mrel"),
      at("\\circlearrowright", "↻", "mrel", "ams"),
      at("\\circlearrowleft", "↺", "mrel", "ams"),
      at("\\restriction", "↾", "mrel", "ams"),
      at("\\upharpoonright", "↾", "mrel", "ams"),
      at("\\upharpoonleft", "↿", "mrel", "ams"),
      at("\\downharpoonright", "⇂", "mrel", "ams"),
      at("\\downharpoonleft", "⇃", "mrel", "ams"),
      at("\\rightsquigarrow", "⇝", "mrel", "ams"),
      at("\\leadsto", "⇝", "mrel", "ams"),
      at("\\leftrightsquigarrow", "↭", "mrel", "ams"),
      at("\\multimap", "⊸", "mrel", "ams"),
      at("\\nrightarrow", "↛", "mrel", "ams"),
      at("\\nleftarrow", "↚", "mrel", "ams"),
      at("\\nRightarrow", "⇏", "mrel", "ams"),
      at("\\nLeftarrow", "⇍", "mrel", "ams"),
      at("\\nleftrightarrow", "↮", "mrel", "ams"),
      at("\\nLeftrightarrow", "⇎", "mrel", "ams"),
      at("\\nless", "≮", "mrel", "ams"),
      at("\\nleqslant", "", "mrel", "ams"),
      at("\\lneq", "⪇", "mrel", "ams"),
      at("\\lneqq", "≨", "mrel", "ams"),
      at("\\nleqq", "", "mrel", "ams"),
      at("\\unlhd", "⊴", "mbin", "ams"),
      at("\\unrhd", "⊵", "mbin", "ams"),
      at("\\lvertneqq", "", "mrel", "ams"),
      at("\\lnsim", "⋦", "mrel", "ams"),
      at("\\lnapprox", "⪉", "mrel", "ams"),
      at("\\nprec", "⊀", "mrel", "ams"),
      at("\\npreceq", "⋠", "mrel", "ams"),
      at("\\precnsim", "⋨", "mrel", "ams"),
      at("\\precnapprox", "⪹", "mrel", "ams"),
      at("\\nsim", "≁", "mrel", "ams"),
      at("\\nshortmid", "", "mrel", "ams"),
      at("\\nmid", "∤", "mrel", "ams"),
      at("\\nvdash", "⊬", "mrel", "ams"),
      at("\\nvDash", "⊭", "mrel", "ams"),
      at("\\ngtr", "≯", "mrel", "ams"),
      at("\\ngeqslant", "", "mrel", "ams"),
      at("\\ngeqq", "", "mrel", "ams"),
      at("\\gneq", "⪈", "mrel", "ams"),
      at("\\gneqq", "≩", "mrel", "ams"),
      at("\\gvertneqq", "", "mrel", "ams"),
      at("\\gnsim", "⋧", "mrel", "ams"),
      at("\\gnapprox", "⪊", "mrel", "ams"),
      at("\\nsucc", "⊁", "mrel", "ams"),
      at("\\nsucceq", "⋡", "mrel", "ams"),
      at("\\succnsim", "⋩", "mrel", "ams"),
      at("\\succnapprox", "⪺", "mrel", "ams"),
      at("\\ncong", "≆", "mrel", "ams"),
      at("\\nshortparallel", "", "mrel", "ams"),
      at("\\nparallel", "∦", "mrel", "ams"),
      at("\\nVDash", "⊯", "mrel", "ams"),
      at("\\nsupseteqq", "", "mrel", "ams"),
      at("\\supsetneq", "⊋", "mrel", "ams"),
      at("\\varsupsetneq", "", "mrel", "ams"),
      at("\\supsetneqq", "⫌", "mrel", "ams"),
      at("\\varsupsetneqq", "", "mrel", "ams"),
      at("\\nVdash", "⊮", "mrel", "ams"),
      at("\\precneqq", "⪵", "mrel", "ams"),
      at("\\succneqq", "⪶", "mrel", "ams"),
      at("\\nsubseteqq", "", "mrel", "ams"),
      at("\\checkmark", "✓", "mord", "ams"),
      at("\\diagup", "╱", "mord", "ams"),
      at("\\diagdown", "╲", "mord", "ams"),
      at("\\measuredangle", "∡", "mord", "ams"),
      at("\\sphericalangle", "∢", "mord", "ams"),
      at("\\backprime", "‵", "mord", "ams"),
      at("\\backdoubleprime", "‶", "mord", "ams"),
      at("\\ast", "∗", "mbin"),
      at("\\star", "⋆", "mbin"),
      at("\\diamond", "⋄", "mbin"),
      at("\\Diamond", "◊", "mord", "ams"),
      at("\\lozenge", "◊", "mord", "ams"),
      at("\\blacklozenge", "⧫", "mord", "ams"),
      at("\\bigstar", "★", "mord", "ams"),
      at("\\aleph", "ℵ"),
      at("\\beth", "ℶ", "mord", "ams"),
      at("\\daleth", "ℸ", "mord", "ams"),
      at("\\gimel", "ℷ", "mord", "ams"),
      at("\\lbrace", "{", "mopen"),
      at("\\rbrace", "}", "mclose"),
      at("\\langle", "⟨", "mopen"),
      at("\\rangle", "⟩", "mclose"),
      at("\\lfloor", "⌊", "mopen"),
      at("\\rfloor", "⌋", "mclose"),
      at("\\lceil", "⌈", "mopen"),
      at("\\rceil", "⌉", "mclose"),
      at("\\vert", "∣"),
      at("\\mvert", "∣", "mrel"),
      at("\\lvert", "∣", "mopen"),
      at("\\rvert", "∣", "mclose"),
      at("\\|", "∥"),
      at("\\Vert", "∥"),
      at("\\mVert", "∥"),
      at("\\lVert", "∥", "mopen"),
      at("\\rVert", "∥", "mclose"),
      at("\\parallel", "∥", "mrel"),
      at("\\shortparallel", "∥", "mrel", "ams"),
      at("\\lbrack", "[", "mopen"),
      at("\\rbrack", "]", "mclose"),
      at("\\{", "{", "mopen"),
      at("\\}", "}", "mclose"),
      at("(", "(", "mopen"),
      at(")", ")", "mclose"),
      at("[", "[", "mopen"),
      at("]", "]", "mclose"),
      at("\\ulcorner", "┌", "mopen", "ams"),
      at("\\urcorner", "┐", "mclose", "ams"),
      at("\\llcorner", "└", "mopen", "ams"),
      at("\\lrcorner", "┘", "mclose", "ams"),
      at("\\lgroup", "⟮", "mopen"),
      at("\\rgroup", "⟯", "mclose"),
      at("\\lmoustache", "⎰", "mopen"),
      at("\\rmoustache", "⎱", "mclose"),
      at("=", "=", "mrel"),
      at("\\ne", "≠", "mrel"),
      at("\\neq", "≠", "mrel"),
      at("<", "<", "mrel"),
      at("\\lt", "<", "mrel"),
      at(">", ">", "mrel"),
      at("\\gt", ">", "mrel"),
      at("\\le", "≤", "mrel"),
      at("\\leq", "≤", "mrel"),
      at("\\ge", "≥", "mrel"),
      at("\\geq", "≥", "mrel"),
      at("\\leqslant", "⩽", "mrel", "ams"),
      at("\\geqslant", "⩾", "mrel", "ams"),
      at("\\ll", "≪", "mrel"),
      at("\\gg", "≫", "mrel"),
      at("\\coloneq", "≔", "mrel"),
      at("\\measeq", "≝", "mrel"),
      at("\\eqdef", "≞", "mrel"),
      at("\\questeq", "≟", "mrel"),
      at(":", ":", "mrel"),
      at("\\cong", "≅", "mrel"),
      at("\\equiv", "≡", "mrel"),
      at("\\prec", "≺", "mrel"),
      at("\\preceq", "⪯", "mrel"),
      at("\\succ", "≻", "mrel"),
      at("\\succeq", "⪰", "mrel"),
      at("\\perp", "⊥", "mrel"),
      at("\\propto", "∝", "mrel"),
      at("\\Colon", "∷", "mrel"),
      at("\\smile", "⌣", "mrel"),
      at("\\frown", "⌢", "mrel"),
      at("\\sim", "∼", "mrel"),
      at("\\gtrsim", "≳", "mrel", "ams"),
      at("\\approx", "≈", "mrel"),
      at("\\approxeq", "≊", "mrel", "ams"),
      at("\\thickapprox", "≈", "mrel", "ams"),
      at("\\lessapprox", "⪅", "mrel", "ams"),
      at("\\gtrapprox", "⪆", "mrel", "ams"),
      at("\\precapprox", "⪷", "mrel", "ams"),
      at("\\succapprox", "⪸", "mrel", "ams"),
      at("\\thicksim", "∼", "mrel", "ams"),
      at("\\succsim", "≿", "mrel", "ams"),
      at("\\precsim", "≾", "mrel", "ams"),
      at("\\backsim", "∽", "mrel", "ams"),
      at("\\eqsim", "≂", "mrel", "ams"),
      at("\\backsimeq", "⋍", "mrel", "ams"),
      at("\\simeq", "≃", "mrel"),
      at("\\lesssim", "≲", "mrel", "ams"),
      at("\\nleq", "≰", "mrel", "ams"),
      at("\\ngeq", "≱", "mrel", "ams"),
      at("\\smallsmile", "⌣", "mrel", "ams"),
      at("\\smallfrown", "⌢", "mrel", "ams"),
      at("\\bowtie", "⋈", "mrel"),
      at("\\Join", "⋈", "mrel"),
      at("\\asymp", "≍", "mrel"),
      at("\\sqsubseteq", "⊑", "mrel"),
      at("\\sqsupseteq", "⊒", "mrel"),
      at("\\leqq", "≦", "mrel", "ams"),
      at("\\eqslantless", "⪕", "mrel", "ams"),
      at("\\lll", "⋘", "mrel", "ams"),
      at("\\lessgtr", "≶", "mrel", "ams"),
      at("\\lesseqgtr", "⋚", "mrel", "ams"),
      at("\\lesseqqgtr", "⪋", "mrel", "ams"),
      at("\\risingdotseq", "≓", "mrel", "ams"),
      at("\\fallingdotseq", "≒", "mrel", "ams"),
      at("\\subseteqq", "⫅", "mrel", "ams"),
      at("\\Subset", "⋐", "mrel", "ams"),
      at("\\sqsubset", "⊏", "mrel", "ams"),
      at("\\preccurlyeq", "≼", "mrel", "ams"),
      at("\\curlyeqprec", "⋞", "mrel", "ams"),
      at("\\vDash", "⊨", "mrel", "ams"),
      at("\\Vvdash", "⊪", "mrel", "ams"),
      at("\\bumpeq", "≏", "mrel", "ams"),
      at("\\Bumpeq", "≎", "mrel", "ams"),
      at("\\geqq", "≧", "mrel", "ams"),
      at("\\eqslantgtr", "⪖", "mrel", "ams"),
      at("\\ggg", "⋙", "mrel", "ams"),
      at("\\gtrless", "≷", "mrel", "ams"),
      at("\\gtreqless", "⋛", "mrel", "ams"),
      at("\\gtreqqless", "⪌", "mrel", "ams"),
      at("\\supseteqq", "⫆", "mrel", "ams"),
      at("\\Supset", "⋑", "mrel", "ams"),
      at("\\sqsupset", "⊐", "mrel", "ams"),
      at("\\succcurlyeq", "≽", "mrel", "ams"),
      at("\\curlyeqsucc", "⋟", "mrel", "ams"),
      at("\\Vdash", "⊩", "mrel", "ams"),
      at("\\shortmid", "∣", "mrel", "ams"),
      at("\\between", "≬", "mrel", "ams"),
      at("\\pitchfork", "⋔", "mrel", "ams"),
      at("\\varpropto", "∝", "mrel", "ams"),
      at("\\backepsilon", "∍", "mrel", "ams"),
      at("\\llless", "⋘", "mrel", "ams"),
      at("\\gggtr", "⋙", "mrel", "ams"),
      at("\\lhd", "⊲", "mbin", "ams"),
      at("\\rhd", "⊳", "mbin", "ams"),
      at("\\doteq", "≐", "mrel"),
      at("\\doteqdot", "≑", "mrel", "ams"),
      at("\\Doteq", "≑", "mrel", "ams"),
      at("\\eqcirc", "≖", "mrel", "ams"),
      at("\\circeq", "≗", "mrel", "ams"),
      at("\\lessdot", "⋖", "mbin", "ams"),
      at("\\gtrdot", "⋗", "mbin", "ams"),
      at("\\~", "~", "mrel"),
      at("\\leftrightarrow", "↔", "mrel"),
      at("\\Leftrightarrow", "⇔", "mrel"),
      at("\\models", "⊨", "mrel"),
      at("\\vdash", "⊢", "mrel"),
      at("\\therefore", "∴", "mrel", "ams"),
      at("\\because", "∵", "mrel", "ams"),
      at("\\dashv", "⊣", "mrel"),
      at("\\roundimplies", "⥰", "mrel"),
      at("+", "+", "mbin"),
      at("-", "−", "mbin"),
      at("−", "−", "mbin"),
      at("\\pm", "±", "mbin"),
      at("\\mp", "∓", "mbin"),
      at("*", "∗", "mbin"),
      at("\\times", "×", "mbin"),
      at("\\div", "÷", "mbin"),
      at("\\surd", "√"),
      at("\\divides", "∣", "mbin"),
      at("\\ltimes", "⋉", "mbin", "ams"),
      at("\\rtimes", "⋊", "mbin", "ams"),
      at("\\leftthreetimes", "⋋", "mbin", "ams"),
      at("\\rightthreetimes", "⋌", "mbin", "ams"),
      at("\\intercal", "⊺", "mbin", "ams"),
      at("\\dotplus", "∔", "mbin", "ams"),
      at("\\doublebarwedge", "⩞", "mbin", "ams"),
      at("\\divideontimes", "⋇", "mbin", "ams"),
      at("\\centerdot", "⋅", "mbin", "ams"),
      at("\\cdot", "⋅", "mbin"),
      at("\\infty", "∞"),
      at("\\prime", "′"),
      at("\\doubleprime", "″"),
      at("\\angle", "∠"),
      at("`", "‘"),
      at("\\$", "$"),
      at("\\%", "%"),
      at("\\_", "_"),
      at("\\alpha", "α"),
      at("\\beta", "β"),
      at("\\gamma", "γ"),
      at("\\delta", "δ"),
      at("\\epsilon", "ϵ"),
      at("\\varepsilon", "ε"),
      at("\\zeta", "ζ"),
      at("\\eta", "η"),
      at("\\theta", "θ"),
      at("\\vartheta", "ϑ"),
      at("\\iota", "ι"),
      at("\\kappa", "κ"),
      at("\\varkappa", "ϰ", "mord", "ams"),
      at("\\lambda", "λ"),
      at("\\mu", "μ"),
      at("\\nu", "ν"),
      at("\\xi", "ξ"),
      at("\\omicron", "o"),
      at("\\pi", "π"),
      at("\\varpi", "ϖ"),
      at("\\rho", "ρ"),
      at("\\varrho", "ϱ"),
      at("\\sigma", "σ"),
      at("\\varsigma", "ς"),
      at("\\tau", "τ"),
      at("\\phi", "ϕ"),
      at("\\varphi", "φ"),
      at("\\upsilon", "υ"),
      at("\\chi", "χ"),
      at("\\psi", "ψ"),
      at("\\omega", "ω"),
      at("\\Gamma", "Γ"),
      at("\\Delta", "Δ"),
      at("\\Theta", "Θ"),
      at("\\Lambda", "Λ"),
      at("\\Xi", "Ξ"),
      at("\\Pi", "Π"),
      at("\\Sigma", "Σ"),
      at("\\Upsilon", "Υ"),
      at("\\Phi", "Φ"),
      at("\\Psi", "Ψ"),
      at("\\Omega", "Ω"),
      at("\\digamma", "ϝ", "mord", "ams"),
      at("\\emptyset", "∅"),
      at("\\varnothing", "∅", "mord", "ams"),
      at("\\cap", "∩", "mbin"),
      at("\\cup", "∪", "mbin"),
      at("\\setminus", "∖", "mbin"),
      at("\\smallsetminus", "∖", "mbin", "ams"),
      at("\\complement", "∁", "mord", "ams"),
      at("\\in", "∈", "mrel"),
      at("\\notin", "∉", "mrel"),
      at("\\not", "̸", "mrel"),
      at("\\ni", "∋", "mrel"),
      at("\\owns", "∋", "mrel"),
      at("\\subset", "⊂", "mrel"),
      at("\\supset", "⊃", "mrel"),
      at("\\subseteq", "⊆", "mrel"),
      at("\\supseteq", "⊇", "mrel"),
      at("\\subsetneq", "⊊", "mrel", "ams"),
      at("\\varsubsetneq", "", "mrel", "ams"),
      at("\\subsetneqq", "⫋", "mrel", "ams"),
      at("\\varsubsetneqq", "", "mrel", "ams"),
      at("\\nsubset", "⊄", "mrel", "ams"),
      at("\\nsupset", "⊅", "mrel", "ams"),
      at("\\nsubseteq", "⊈", "mrel", "ams"),
      at("\\nsupseteq", "⊉", "mrel", "ams"),
      at("\\ ", " ", "spacing"),
      at("~", " ", "spacing"),
      at("\\space", " ", "spacing"),
      at("\\!", null, "spacing"),
      at("\\,", null, "spacing"),
      at("\\:", null, "spacing"),
      at("\\;", null, "spacing"),
      at("\\enskip", null, "spacing"),
      at("\\enspace", null, "spacing"),
      at("\\quad", null, "spacing"),
      at("\\qquad", null, "spacing"),
      at("\\colon", ":", "mpunct"),
      at("\\cdotp", "⋅", "mpunct"),
      at("\\cdots", "⋯", "minner"),
      at("\\ddots", "⋱", "minner"),
      at("\\ldots", "…", "minner"),
      at("\\mathellipsis", "…", "minner"),
      at("\\vdots", "⋮"),
      at("\\ldotp", ".", "mpunct"),
      at(",", ",", "mpunct"),
      at(";", ";", "mpunct"),
      at("\\land", "∧", "mbin"),
      at("\\wedge", "∧", "mbin"),
      at("\\lor", "∨", "mbin"),
      at("\\vee", "∨", "mbin"),
      at("\\lnot", "¬"),
      at("\\neg", "¬"),
      at("\\barwedge", "⊼", "mbin", "ams"),
      at("\\veebar", "⊻", "mbin", "ams"),
      at("\\nor", "⊻", "mbin", "ams"),
      at("\\curlywedge", "⋏", "mbin", "ams"),
      at("\\curlyvee", "⋎", "mbin", "ams"),
      at("\\square", "□", "mord", "ams"),
      at("\\Box", "□", "mord", "ams"),
      at("\\blacksquare", "■", "mord", "ams"),
      at("\\boxminus", "⊟", "mbin", "ams"),
      at("\\boxplus", "⊞", "mbin", "ams"),
      at("\\boxtimes", "⊠", "mbin", "ams"),
      at("\\boxdot", "⊡", "mbin", "ams"),
      at("\\circ", "∘", "mbin"),
      at("\\bigcirc", "◯", "mbin"),
      at("\\bullet", "∙", "mbin"),
      at("\\circleddash", "⊝", "mbin", "ams"),
      at("\\circledast", "⊛", "mbin", "ams"),
      at("\\oplus", "⊕", "mbin"),
      at("\\ominus", "⊖", "mbin"),
      at("\\otimes", "⊗", "mbin"),
      at("\\odot", "⊙", "mbin"),
      at("\\circledcirc", "⊚", "mbin", "ams"),
      at("\\oslash", "⊘", "mbin"),
      at("\\circledS", "Ⓢ", "mord", "ams"),
      at("\\circledR", "®", "mord", "ams"),
      at("\\triangle", "△"),
      at("\\bigtriangleup", "△", "mbin"),
      at("\\vartriangle", "△", "mrel", "ams"),
      at("\\triangleq", "≜", "mrel", "ams"),
      at("\\triangledown", "▽", "mord", "ams"),
      at("\\bigtriangledown", "▽", "mbin"),
      at("\\triangleleft", "◃", "mbin"),
      at("\\vartriangleleft", "⊲", "mrel", "ams"),
      at("\\trianglelefteq", "⊴", "mrel", "ams"),
      at("\\ntriangleleft", "⋪", "mrel", "ams"),
      at("\\ntrianglelefteq", "⋬", "mrel", "ams"),
      at("\\triangleright", "▹", "mbin"),
      at("\\vartriangleright", "⊳", "mrel", "ams"),
      at("\\trianglerighteq", "⊵", "mrel", "ams"),
      at("\\ntriangleright", "⋫", "mrel", "ams"),
      at("\\ntrianglerighteq", "⋭", "mrel", "ams"),
      at("\\blacktriangle", "▲", "mord", "ams"),
      at("\\blacktriangledown", "▼", "mord", "ams"),
      at("\\blacktriangleleft", "◀", "mrel", "ams"),
      at("\\blacktriangleright", "▶", "mrel", "ams"),
      at("\\/", "/"),
      at("|", "∣", "textord"),
      at("\\And", "&", "mbin"),
      at("\\imath", "ı"),
      at("\\jmath", "ȷ"),
      at("\\degree", "°"),
      at("'", "′"),
      at('"', "”");
    const wt = {
      acute: "ˊ",
      grave: "ˋ",
      dot: "˙",
      ddot: "¨",
      mathring: "˚",
      tilde: "~",
      bar: "ˉ",
      breve: "˘",
      check: "ˇ",
      hat: "^",
      vec: "⃗",
    };
    kt(Object.keys(wt), "{body:auto}", null, function (t, e) {
      return {
        type: "accent",
        accent: wt[t.slice(1)],
        limits: "accent",
        skipBoundary: !0,
        body: e[0],
      };
    }),
      kt(["widehat", "widecheck", "widetilde"], "{body:auto}", null, (t, e) => {
        const s = xt(e[0]);
        return {
          type: "accent",
          svgAccent:
            t.slice(1) +
            (s.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][s.length]),
          limits: "accent",
          skipBoundary: !0,
          body: e[0],
        };
      }),
      kt(
        "utilde",
        "{body:auto}",
        null,
        (t, e) => {
          const s = xt(e[0]),
            i =
              "widetilde" +
              (s.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][s.length]);
          return {
            type: "overunder",
            body: e[0],
            svgBelow: i,
            skipBoundary: !0,
          };
        },
        (t, e, s, i) => `\\utilde{${i(s, s.body)}}`
      ),
      kt("^", "{:string}", {}, (t, e) => ({
        type: "mord",
        limits: "nolimits",
        isSymbol: !0,
        isFunction: !1,
        body:
          (e[0] &&
            {
              a: "â",
              e: "ê",
              i: "î",
              o: "ô",
              u: "û",
              A: "Â",
              E: "Ê",
              I: "Î",
              O: "Ô",
              U: "Û",
            }[e[0]]) ||
          "^",
      })),
      kt("`", "{:string}", {}, (t, e) => ({
        type: "mord",
        limits: "nolimits",
        isSymbol: !0,
        isFunction: !1,
        body:
          (e[0] &&
            {
              a: "à",
              e: "è",
              i: "ì",
              o: "ò",
              u: "ù",
              A: "À",
              E: "È",
              I: "Ì",
              O: "Ò",
              U: "Ù",
            }[e[0]]) ||
          "`",
      })),
      kt("'", "{:string}", {}, function (t, e) {
        return {
          type: "mord",
          limits: "nolimits",
          isSymbol: !0,
          isFunction: !1,
          body:
            (e[0] &&
              {
                a: "á",
                e: "é",
                i: "í",
                o: "ó",
                u: "ú",
                A: "Á",
                E: "É",
                I: "Í",
                O: "Ó",
                U: "Ú",
              }[e[0]]) ||
            "^",
        };
      }),
      kt("~", "{:string}", {}, function (t, e) {
        return {
          type: "mord",
          limits: "nolimits",
          isSymbol: !0,
          isFunction: !1,
          body:
            (e[0] &&
              {
                n: "ñ",
                N: "Ñ",
                a: "ã",
                o: "õ",
                A: "Ã",
                O: "Õ",
              }[e[0]]) ||
            "´",
        };
      }),
      kt("c", "{:string}", {}, function (t, e) {
        return {
          type: "mord",
          limits: "nolimits",
          isSymbol: !0,
          isFunction: !1,
          body:
            (e[0] &&
              {
                c: "ç",
                C: "Ç",
              }[e[0]]) ||
            "",
        };
      }),
      kt(
        [
          "overrightarrow",
          "overleftarrow",
          "Overrightarrow",
          "overleftharpoon",
          "overrightharpoon",
          "overleftrightarrow",
          "overbrace",
          "overlinesegment",
          "overgroup",
        ],
        "{:auto}",
        null,
        (t, e) => ({
          type: "overunder",
          body: e[0],
          svgAbove: t.slice(1),
          skipBoundary: !0,
        }),
        (t, e, s, i) => `${t}{${i(s, s.body)}}`
      ),
      kt(
        [
          "underrightarrow",
          "underleftarrow",
          "underleftrightarrow",
          "underbrace",
          "underlinesegment",
          "undergroup",
        ],
        "{:auto}",
        null,
        (t, e) => ({
          type: "overunder",
          body: e[0],
          svgBelow: t.slice(1),
          skipBoundary: !0,
        }),
        (t, e, s, i) => `${t}{${i(s, s.body)}}`
      ),
      kt(
        [
          "xrightarrow",
          "xleftarrow",
          "xRightarrow",
          "xLeftarrow",
          "xleftharpoonup",
          "xleftharpoondown",
          "xrightharpoonup",
          "xrightharpoondown",
          "xlongequal",
          "xtwoheadleftarrow",
          "xtwoheadrightarrow",
          "xleftrightarrow",
          "xLeftrightarrow",
          "xrightleftharpoons",
          "xleftrightharpoons",
          "xhookleftarrow",
          "xhookrightarrow",
          "xmapsto",
          "xtofrom",
          "xrightleftarrows",
          "xrightequilibrium",
          "xleftequilibrium",
        ],
        "[:auto]{:auto}",
        null,
        (t, e) => ({
          type: "overunder",
          mathtype: "mrel",
          svgBody: t.slice(1),
          overscript: e[1],
          underscript: e[0],
          skipBoundary: !0,
        }),
        (t, e, s, i) =>
          t +
          (s.underscript ? `[${i(s, s.underscript)}]` : "") +
          `{${i(s, s.overscript)}}`
      ),
      vt("math", "", {}, function () {
        return {
          mathstyle: "textstyle",
        };
      }),
      vt("displaymath", "", {}, function () {
        return {
          mathstyle: "displaystyle",
        };
      }),
      vt("array", "{columns:colspec}", {}, function (t, e) {
        return {
          colFormat: e[0],
          mathstyle: "textstyle",
        };
      }),
      vt("eqnarray", "", {}, function () {
        return {};
      }),
      vt("equation", "", {}, function () {
        return {
          colFormat: [
            {
              align: "c",
            },
          ],
        };
      }),
      vt("subequations", "", {}, function () {
        return {
          colFormat: [
            {
              align: "c",
            },
          ],
        };
      }),
      vt("multline", "", {}, function () {
        return {
          firstRowFormat: [
            {
              align: "l",
            },
          ],
          colFormat: [
            {
              align: "c",
            },
          ],
          lastRowFormat: [
            {
              align: "r",
            },
          ],
        };
      }),
      vt(["align", "align*", "aligned"], "", {}, function (t, e, s) {
        let i = 0;
        for (const t of s) i = Math.max(i, t.length);
        const a = [
          {
            gap: 0,
          },
          {
            align: "r",
          },
          {
            gap: 0,
          },
          {
            align: "l",
          },
        ];
        let r = 2;
        for (; r < i; )
          a.push({
            gap: 1,
          }),
            a.push({
              align: "r",
            }),
            a.push({
              gap: 0,
            }),
            a.push({
              align: "l",
            }),
            (r += 2);
        return (
          a.push({
            gap: 0,
          }),
          {
            arraycolsep: 0,
            colFormat: a,
            jot: 0.3,
          }
        );
      }),
      vt("split", "", {}, function () {
        return {};
      }),
      vt(["gather", "gathered"], "", {}, function () {
        return {
          colFormat: [
            {
              gap: 0.25,
            },
            {
              align: "c",
            },
            {
              gap: 0,
            },
          ],
          jot: 0.3,
        };
      }),
      vt(
        [
          "matrix",
          "pmatrix",
          "bmatrix",
          "Bmatrix",
          "vmatrix",
          "Vmatrix",
          "smallmatrix",
          "matrix*",
          "pmatrix*",
          "bmatrix*",
          "Bmatrix*",
          "vmatrix*",
          "Vmatrix*",
          "smallmatrix*",
        ],
        "[columns:colspec]",
        {},
        function (t, e) {
          const s = {
            mathstyle: "textstyle",
          };
          switch (t) {
            case "pmatrix":
            case "pmatrix*":
              (s.lFence = "("), (s.rFence = ")");
              break;
            case "bmatrix":
            case "bmatrix*":
              (s.lFence = "["), (s.rFence = "]");
              break;
            case "Bmatrix":
            case "Bmatrix*":
              (s.lFence = "\\lbrace"), (s.rFence = "\\rbrace");
              break;
            case "vmatrix":
            case "vmatrix*":
              (s.lFence = "\\vert"), (s.rFence = "\\vert");
              break;
            case "Vmatrix":
            case "Vmatrix*":
              (s.lFence = "\\Vert"), (s.rFence = "\\Vert");
              break;
            case "smallmatrix":
            case "smallmatrix*":
              s.mathstyle = "scriptstyle";
              break;
            case "matrix":
            case "matrix*":
              (s.lFence = "."), (s.rFence = ".");
          }
          return (
            (s.colFormat = e[0] || [
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
              {
                align: "c",
              },
            ]),
            s
          );
        }
      ),
      vt("cases", "", {}, function () {
        return {
          arraystretch: 1.2,
          lFence: "\\lbrace",
          rFence: ".",
          colFormat: [
            {
              align: "l",
            },
            {
              gap: 1,
            },
            {
              align: "l",
            },
          ],
        };
      }),
      vt("theorem", "", {}, function () {
        return {};
      }),
      vt("center", "", {}, function () {
        return {
          colFormat: [
            {
              align: "c",
            },
          ],
        };
      }),
      kt(
        "enclose",
        "{notation:string}[style:string]{body:auto}",
        null,
        (t, e) => {
          const s = {
            type: "enclose",
            strokeColor: "currentColor",
            strokeWidth: 1,
            strokeStyle: "solid",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            captureSelection: !0,
            body: e[2],
          };
          if (e[1]) {
            const t = e[1].split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
            for (const e of t) {
              const t = e.match(/\s*(\S+)\s+(\S+)\s+(.*)/);
              if (t)
                (s.strokeWidth = x(t[1], "px")),
                  isFinite(s.strokeWidth) || (s.strokeWidth = 1),
                  (s.strokeStyle = t[2]),
                  (s.strokeColor = t[3]);
              else {
                const t = e.match(/\s*([a-z]*)\s*=\s*"(.*)"/);
                t &&
                  ("mathbackground" === t[1]
                    ? (s.backgroundcolor = t[2])
                    : "mathcolor" === t[1]
                    ? (s.strokeColor = t[2])
                    : "padding" === t[1]
                    ? (s.padding = x(t[2], "px"))
                    : "shadow" === t[1] && (s.shadow = t[2]));
              }
            }
            "dashed" === s.strokeStyle
              ? (s.svgStrokeStyle = "5,5")
              : "dotted" === s.strokeStyle && (s.svgStrokeStyle = "1,5");
          }
          return (
            (s.borderStyle =
              s.strokeWidth + "px " + s.strokeStyle + " " + s.strokeColor),
            (s.notation = {}),
            e[0]
              .split(/[, ]/)
              .filter((t) => t.length > 0)
              .forEach((t) => {
                s.notation[t.toLowerCase()] = !0;
              }),
            s.notation.updiagonalarrow && (s.notation.updiagonalstrike = !1),
            s.notation.box &&
              ((s.notation.left = !1),
              (s.notation.right = !1),
              (s.notation.bottom = !1),
              (s.notation.top = !1)),
            s
          );
        }
      ),
      kt("cancel", "{body:auto}", null, function (t, e) {
        return {
          type: "enclose",
          strokeColor: "currentColor",
          strokeWidth: 1,
          strokeStyle: "solid",
          borderStyle: "1px solid currentColor",
          backgroundcolor: "transparent",
          padding: "auto",
          shadow: "auto",
          notation: {
            updiagonalstrike: !0,
          },
          body: e[0],
        };
      }),
      kt("bcancel", "{body:auto}", null, function (t, e) {
        return {
          type: "enclose",
          strokeColor: "currentColor",
          strokeWidth: 1,
          strokeStyle: "solid",
          borderStyle: "1px solid currentColor",
          backgroundcolor: "transparent",
          padding: "auto",
          shadow: "auto",
          notation: {
            downdiagonalstrike: !0,
          },
          body: e[0],
        };
      }),
      kt("xcancel", "{body:auto}", null, function (t, e) {
        return {
          type: "enclose",
          strokeColor: "currentColor",
          strokeWidth: 1,
          strokeStyle: "solid",
          borderStyle: "1px solid currentColor",
          backgroundcolor: "transparent",
          padding: "auto",
          shadow: "auto",
          notation: {
            updiagonalstrike: !0,
            downdiagonalstrike: !0,
          },
          body: e[0],
        };
      });
    const St = {
        m0: "#3f3d99",
        m1: "#993d71",
        m2: "#998b3d",
        m3: "#3d9956",
        m4: "#3d5a99",
        m5: "#993d90",
        m6: "#996d3d",
        m7: "#43993d",
        m8: "#3d7999",
        m9: "#843d99",
      },
      Mt = [
        "#d35d60",
        "#7293cb",
        "#e1974d",
        "#84bb5d",
        "#9066a7",
        "#aD6a58",
        "#f5a4ce",
        "#fff590",
        "#212121",
        "#818787",
        "#d4d5d2",
        "#ffffff",
      ],
      At = [
        "#cc2428",
        "#3769b1",
        "#da7e30",
        "#409852",
        "#6b4c9a",
        "#922426",
        "#e7298a",
        "#ffe907",
        "#000000",
        "#525055",
        "#adafaa",
        "#ffffff",
      ],
      _t = {
        apricot: "#FBB982",
        aquamarine: "#00B5BE",
        bittersweet: "#C04F17",
        black: "#221E1F",
        blue: "#2D2F92",
        bluegreen: "#00B3B8",
        blueviolet: "#473992",
        brickred: "#B6321C",
        brown: "#792500",
        burntorange: "#F7921D",
        cadetblue: "#74729A",
        carnationpink: "#F282B4",
        cerulean: "#00A2E3",
        cornflowerblue: "#41B0E4",
        cyan: "#00AEEF",
        dandelion: "#FDBC42",
        darkorchid: "#A4538A",
        emerald: "#00A99D",
        forestgreen: "#009B55",
        fuchsia: "#8C368C",
        goldenrod: "#FFDF42",
        gray: "#949698",
        green: "#00A64F",
        greenyellow: "#DFE674",
        junglegreen: "#00A99A",
        lavender: "#F49EC4",
        limegreen: "#8DC73E",
        magenta: "#EC008C",
        mahogany: "#A9341F",
        maroon: "#AF3235",
        melon: "#F89E7B",
        midnightblue: "#006795",
        mulberry: "#A93C93",
        navyblue: "#006EB8",
        olivegreen: "#3C8031",
        orange: "#F58137",
        orangered: "#ED135A",
        orchid: "#AF72B0",
        peach: "#F7965A",
        periwinkle: "#7977B8",
        pinegreen: "#008B72",
        plum: "#92268F",
        processblue: "#00B0F0",
        purple: "#99479B",
        rawsienna: "#974006",
        red: "#ED1B23",
        redorange: "#F26035",
        redviolet: "#A1246B",
        rhodamine: "#EF559F",
        royalblue: "#0071BC",
        royalpurple: "#613F99",
        rubinered: "#ED017D",
        salmon: "#F69289",
        seagreen: "#3FBC9D",
        sepia: "#671800",
        skyblue: "#46C5DD",
        springgreen: "#C6DC67",
        tan: "#DA9D76",
        tealblue: "#00AEB3",
        thistle: "#D883B7",
        turquoise: "#00B4CE",
        violet: "#58429B",
        violetred: "#EF58A0",
        white: "#FFFFFF",
        wildstrawberry: "#EE2967",
        yellow: "#FFF200",
        yellowgreen: "#98CC70",
        yelloworange: "#FAA21A",
      };

    function Ct(t) {
      var e;
      const s = t.toLowerCase().split("!");
      let i,
        a,
        r,
        n = 255,
        o = 255,
        l = 255,
        c = -1;
      const h = s.length > 0 && "-" === s[0].charAt(0);
      h && (s[0] = s[0].slice(1));
      for (let t = 0; t < s.length; t++) {
        (i = n), (a = o), (r = l);
        const h =
          null === (e = s[t].match(/([a-z0-9]*)/)) || void 0 === e
            ? void 0
            : e[1];
        let d = _t[h] || St[h];
        d || (d = s[t]);
        let m = d.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
        if (m && m[1] && m[2] && m[3])
          (n = Math.max(0, Math.min(255, parseInt(m[1], 16)))),
            (o = Math.max(0, Math.min(255, parseInt(m[2], 16)))),
            (l = Math.max(0, Math.min(255, parseInt(m[3], 16))));
        else if (((m = d.match(/^#([0-9a-f]{3})$/i)), m && m[1])) {
          const t = parseInt(m[1][0], 16),
            e = parseInt(m[1][1], 16),
            s = parseInt(m[1][2], 16);
          (n = Math.max(0, Math.min(255, 16 * t + t))),
            (o = Math.max(0, Math.min(255, 16 * e + e))),
            (l = Math.max(0, Math.min(255, 16 * s + s)));
        } else {
          if (
            ((m = d.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i)),
            !(m && m[1] && m[2] && m[3]))
          )
            return null;
          (n = Math.max(0, Math.min(255, parseInt(m[1])))),
            (o = Math.max(0, Math.min(255, parseInt(m[2])))),
            (l = Math.max(0, Math.min(255, parseInt(m[3]))));
        }
        c >= 0 &&
          ((n = (1 - c) * n + c * i),
          (o = (1 - c) * o + c * a),
          (l = (1 - c) * l + c * r),
          (c = -1)),
          t + 1 < s.length &&
            (c = Math.max(0, Math.min(100, parseInt(s[++t]))) / 100);
      }
      return (
        c >= 0 &&
          ((n = c * n + (1 - c) * i),
          (o = c * o + (1 - c) * a),
          (l = c * l + (1 - c) * r)),
        h && ((n = 255 - n), (o = 255 - o), (l = 255 - l)),
        "#" +
          ("00" + Math.round(n).toString(16)).slice(-2) +
          ("00" + Math.round(o).toString(16)).slice(-2) +
          ("00" + Math.round(l).toString(16)).slice(-2)
      );
    }

    function Lt(t) {
      let e = t.toUpperCase();
      for (const t in _t)
        if (_t[t] === e) {
          e = t;
          break;
        }
      for (const t in St)
        if (St[t] === e) {
          e = t;
          break;
        }
      return e;
    }
    kt(
      "ensuremath",
      "{:math}",
      {},
      (t, e) => ({
        type: "group",
        mode: "math",
        body: e[0],
        skipBoundary: !0,
        latexOpen: "\\ensuremath{",
        latexClose: "}",
      }),
      (t, e, s, i) => i(s, s.body)
    ),
      kt("color", "{:color}", {}, (t, e) => ({
        color: e[0],
      })),
      kt("textcolor", "{:color}{content:auto*}", {}, (t, e) => ({
        color: e[0],
      })),
      kt("boxed", "{content:math}", null, (t, e) => ({
        type: "box",
        framecolor: "black",
        skipBoundary: !0,
        body: e[0],
      })),
      kt(
        "colorbox",
        "{background-color:string}{content:auto}",
        {},
        (t, e) => ({
          type: "box",
          backgroundcolor: Ct(e[0]),
          skipBoundary: !0,
          body: e[1],
          verbatimBackgroundcolor: e[0],
        }),
        (t, e, s, i) =>
          `${t}{${s.verbatimBackgroundcolor || Lt(s.backgroundcolor)}}{${i(
            s,
            s.body
          )}}`
      ),
      kt(
        "fcolorbox",
        "{frame-color:string}{background-color:string}{content:auto}",
        {},
        (t, e) => ({
          type: "box",
          framecolor: Ct(e[0]),
          backgroundcolor: Ct(e[1]),
          skipBoundary: !0,
          body: e[2],
          verbatimBackgroundcolor: e[1],
          verbatimFramecolor: e[0],
        }),
        (t, e, s, i) =>
          `${t}{${s.verbatimFramecolor || Lt(s.framecolor)}{${
            s.verbatimBackgroundcolor || Lt(s.backgroundcolor)
          }}{${i(s, s.body)}}`
      ),
      kt(
        "bbox",
        "[:bbox]{body:auto}",
        {},
        (t, e) => {
          if (e[0]) {
            const t = e[0];
            return {
              type: "box",
              padding: t.padding,
              border: t.border,
              backgroundcolor: t.backgroundcolor,
              skipBoundary: !0,
              body: e[1],
            };
          }
          return {
            type: "box",
            skipBoundary: !0,
            body: e[1],
          };
        },
        (t, e, s, i) => {
          let a = t;
          if (
            isFinite(s.padding) ||
            void 0 !== s.border ||
            void 0 !== s.backgroundcolor
          ) {
            const t = [];
            isFinite(s.padding) &&
              t.push(Math.floor(100 * s.padding) / 100 + "em"),
              s.border && t.push("border:" + s.border),
              s.backgroundcolor && t.push(Lt(s.backgroundcolor)),
              (a += `[${t.join(",")}]`);
          }
          return a + `{${i(s, s.body)}}`;
        }
      ),
      kt(
        [
          "tiny",
          "scriptsize",
          "footnotesize",
          "small",
          "normalsize",
          "large",
          "Large",
          "LARGE",
          "huge",
          "Huge",
        ],
        "",
        {},
        (t, e) => ({
          fontSize: {
            tiny: "size1",
            scriptsize: "size2",
            footnotesize: "size3",
            small: "size4",
            normalsize: "size5",
            large: "size6",
            Large: "size7",
            LARGE: "size8",
            huge: "size9",
            Huge: "size10",
          }[t.slice(1)],
        })
      ),
      kt(
        "fontseries",
        "{:string}",
        {
          mode: "text",
        },
        (t, e) => ({
          fontSeries: e[0],
        })
      ),
      kt(
        "fontshape",
        "{:string}",
        {
          mode: "text",
        },
        (t, e) => ({
          fontShape: e[0],
        })
      ),
      kt(
        "fontfamily",
        "{:string}",
        {
          mode: "text",
        },
        (t, e) => ({
          fontFamily: e[0],
        })
      ),
      kt(
        "selectfont",
        "",
        {
          mode: "text",
        },
        (t, e) => ({})
      ),
      kt("bf", "", {}, (t, e) => ({
        fontSeries: "b",
        fontShape: "n",
        fontFamily: "cmr",
      })),
      kt(["boldsymbol", "bm"], "{:math*}", {}, (t, e) => ({
        mode: "math",
        cssClass: "ML__boldsymbol",
      })),
      kt("bold", "{:math*}", {}, (t, e) => ({
        mode: "math",
        variantStyle: "bold",
      })),
      kt(
        "bfseries",
        "",
        {
          mode: "text",
        },
        (t, e) => ({
          fontSeries: "b",
        })
      ),
      kt(
        "mdseries",
        "",
        {
          mode: "text",
        },
        (t, e) => ({
          fontSeries: "m",
        })
      ),
      kt(
        "upshape",
        "",
        {
          mode: "text",
        },
        (t, e) => ({
          fontShape: "n",
        })
      ),
      kt(
        "slshape",
        "",
        {
          mode: "text",
        },
        (t, e) => ({
          fontShape: "sl",
        })
      ),
      kt(
        "scshape",
        "",
        {
          mode: "text",
        },
        (t, e) => ({
          fontShape: "sc",
        })
      ),
      kt("textbf", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontSeries: "b",
      })),
      kt("textmd", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontSeries: "m",
      })),
      kt("textup", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontShape: "n",
      })),
      kt("textnormal", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontShape: "n",
        fontSeries: "m",
      })),
      kt("textsl", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontShape: "sl",
      })),
      kt("textit", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontShape: "it",
      })),
      kt("textsc", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontShape: "sc",
      })),
      kt("textrm", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontFamily: "roman",
      })),
      kt("textsf", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontFamily: "sans-serif",
      })),
      kt("texttt", "{:text*}", {}, (t, e) => ({
        mode: "text",
        fontFamily: "monospace",
      })),
      kt("mathbf", "{:math*}", {}, (t, e) => ({
        mode: "math",
        variant: "normal",
        variantStyle: "bold",
      })),
      kt("mathit", "{:math*}", {}, (t, e) => ({
        mode: "math",
        variant: "normal",
        variantStyle: "italic",
      })),
      kt("mathbfit", "{:math*}", {}, (t, e) => ({
        mode: "math",
        variant: "normal",
        variantStyle: "bolditalic",
      })),
      kt("mathrm", "{:math*}", {}, (t, e) => ({
        mode: "math",
        variant: "normal",
        variantStyle: "up",
      })),
      kt("mathsf", "{:math*}", {}, (t, e) => ({
        mode: "math",
        variant: "sans-serif",
        variantStyle: "up",
      })),
      kt("mathtt", "{:math*}", {}, (t, e) => ({
        mode: "math",
        variant: "monospace",
        variantStyle: "up",
      })),
      kt("it", "", {}, (t, e) => ({
        fontSeries: "m",
        fontShape: "it",
        fontFamily: "cmr",
        variantStyle: "italic",
      })),
      kt("rmfamily", "", {}, (t, e) => ({
        fontFamily: "roman",
      })),
      kt("sffamily", "", {}, (t, e) => ({
        fontFamily: "sans-serif",
      })),
      kt("ttfamily", "", {}, (t, e) => ({
        fontFamily: "monospace",
      })),
      kt(["Bbb", "mathbb"], "{:math*}", {}, (t, e) => ({
        variant: "double-struck",
        variantStyle: "up",
      })),
      kt(["frak", "mathfrak"], "{:math*}", {}, (t, e) => ({
        variant: "fraktur",
        variantStyle: "up",
      })),
      kt("mathcal", "{:math*}", {}, (t, e) => ({
        variant: "calligraphic",
        variantStyle: "up",
      })),
      kt("mathscr", "{:math*}", {}, (t, e) => ({
        variant: "script",
        variantStyle: "up",
      })),
      kt("mbox", "{:text}", null, (t, e) => ({
        type: "group",
        mode: "math",
        body: e[0],
      })),
      kt("text", "{:text*}", null, (t, e) => ({
        mode: "text",
      })),
      kt("class", "{name:string}{content:auto*}", null, (t, e) => ({
        cssClass: e[0],
      })),
      kt("cssId", "{id:string}{content:auto}", null, (t, e) => ({
        type: "group",
        body: e[1],
        cssId: e[0],
      })),
      kt("em", "", null, (t, e) => ({
        cssClass: "ML__emph",
      })),
      kt("emph", "{:auto}", null, (t, e) => ({
        cssClass: "ML__emph",
        body: e[0],
        type: "group",
        skipBoundary: !0,
      }));
    const zt = {
      "\\bigl": {
        mclass: "mopen",
        size: 1,
      },
      "\\Bigl": {
        mclass: "mopen",
        size: 2,
      },
      "\\biggl": {
        mclass: "mopen",
        size: 3,
      },
      "\\Biggl": {
        mclass: "mopen",
        size: 4,
      },
      "\\bigr": {
        mclass: "mclose",
        size: 1,
      },
      "\\Bigr": {
        mclass: "mclose",
        size: 2,
      },
      "\\biggr": {
        mclass: "mclose",
        size: 3,
      },
      "\\Biggr": {
        mclass: "mclose",
        size: 4,
      },
      "\\bigm": {
        mclass: "mrel",
        size: 1,
      },
      "\\Bigm": {
        mclass: "mrel",
        size: 2,
      },
      "\\biggm": {
        mclass: "mrel",
        size: 3,
      },
      "\\Biggm": {
        mclass: "mrel",
        size: 4,
      },
      "\\big": {
        mclass: "mord",
        size: 1,
      },
      "\\Big": {
        mclass: "mord",
        size: 2,
      },
      "\\bigg": {
        mclass: "mord",
        size: 3,
      },
      "\\Bigg": {
        mclass: "mord",
        size: 4,
      },
    };
    kt(
      [
        "bigl",
        "Bigl",
        "biggl",
        "Biggl",
        "bigr",
        "Bigr",
        "biggr",
        "Biggr",
        "bigm",
        "Bigm",
        "biggm",
        "Biggm",
        "big",
        "Big",
        "bigg",
        "Bigg",
      ],
      "{:delim}",
      null,
      function (t, e) {
        return {
          type: "sizeddelim",
          size: zt[t].size,
          cls: zt[t].mclass,
          delim: e[0],
        };
      }
    ),
      kt(["hspace", "hspace*"], "{width:skip}", {}, function (t, e) {
        return {
          type: "spacing",
          width: e[0] || 0,
        };
      }),
      kt(
        [
          "mathop",
          "mathbin",
          "mathrel",
          "mathopen",
          "mathclose",
          "mathpunct",
          "mathord",
          "mathinner",
        ],
        "{:auto}",
        null,
        (t, e) => {
          const s = {
            type: {
              "\\mathop": "mop",
              "\\mathbin": "mbin",
              "\\mathrel": "mrel",
              "\\mathopen": "mopen",
              "\\mathclose": "mclose",
              "\\mathpunct": "mpunct",
              "\\mathord": "mord",
              "\\mathinner": "minner",
            }[t],
            body: e[0],
            captureSelection: !0,
          };
          return (
            "\\mathop" === t && ((s.limits = "limits"), (s.isFunction = !0)), s
          );
        },
        (t, e, s, i) => `${t}{${i(s, s.body)}}`
      ),
      kt(
        ["operatorname", "operatorname*"],
        "{operator:math}",
        null,
        function (t, e) {
          const s = {
            type: "mop",
            captureSelection: !0,
            body: e[0],
            isFunction: !0,
          };
          return (
            s.body.forEach((t) => {
              (t.isFunction = !1),
                t.variant ||
                  t.variantStyle ||
                  ((t.variant = "main"), (t.variantStyle = "up")),
                (t.type = "mord"),
                (t.body =
                  {
                    "∗": "*",
                    "−": "-",
                  }[t.body] || t.body);
            }),
            "\\operatorname" === t
              ? (s.limits = "nolimits")
              : "\\operatorname*" === t && (s.limits = "limits"),
            s
          );
        }
      ),
      kt(
        "unicode",
        "{charcode:number}",
        null,
        (t, e) => {
          let s = parseInt(e[0]);
          return (
            isFinite(s) || (s = 10067),
            {
              type: "mord",
              body: String.fromCodePoint(s),
              codepoint: s,
            }
          );
        },
        (t, e, s, i) =>
          `${t}{"${("000000" + s.codepoint.toString(16))
            .toUpperCase()
            .substr(-6)}}`
      ),
      kt(
        "rule",
        "[raise:dimen]{width:dimen}{thickness:dimen}",
        null,
        function (t, e) {
          return {
            type: "rule",
            shift: e[0],
            width: e[1],
            height: e[2],
          };
        }
      ),
      kt("overline", "{:auto}", null, (t, e) => ({
        type: "line",
        position: "overline",
        skipBoundary: !0,
        body: e[0],
      })),
      kt("underline", "{:auto}", null, (t, e) => ({
        type: "line",
        position: "underline",
        skipBoundary: !0,
        body: e[0],
      })),
      kt(
        "overset",
        "{annotation:auto}{symbol:auto}",
        null,
        function (t, e) {
          return {
            type: "overunder",
            overscript: e[0],
            skipBoundary: !0,
            body: e[1],
          };
        },
        (t, e, s, i) => `${t}{${i(s, s.overscript)}}{${i(s, s.body)}}`
      ),
      kt(
        "underset",
        "{annotation:auto}{symbol:auto}",
        null,
        function (t, e) {
          return {
            type: "overunder",
            underscript: e[0],
            skipBoundary: !0,
            body: e[1],
          };
        },
        (t, e, s, i) => `${t}{${i(s, s.overscript)}}{${i(s, s.body)}}`
      ),
      kt(
        ["overwithdelims", "atopwithdelims"],
        "{numer:auto}{denom:auto}{left-delim:delim}{right-delim:delim}",
        {
          infix: !0,
        },
        function (t, e) {
          return {
            type: "genfrac",
            numer: e[0],
            denom: e[1],
            hasBarLine: !1,
            leftDelim: e[2],
            rightDelim: e[3],
            mathstyle: "auto",
          };
        },
        (t, e, s, i) =>
          `${i(s, s.numer)} ${t}${s.leftDelim}${s.rightDelim}${i(s, s.denom)}`
      ),
      kt(
        ["stackrel", "stackbin"],
        "{annotation:auto}{symbol:auto}",
        null,
        function (t, e) {
          return {
            type: "overunder",
            overscript: e[0],
            skipBoundary: !0,
            body: e[1],
            mathtype: "\\stackrel" === t ? "mrel" : "mbin",
          };
        },
        (t, e, s, i) => `${t}{${i(s, s.overscript)}}{${i(s, s.body)}}`
      ),
      kt("rlap", "{:auto}", null, function (t, e) {
        return {
          type: "overlap",
          align: "right",
          skipBoundary: !0,
          body: e[0],
        };
      }),
      kt("llap", "{:auto}", null, function (t, e) {
        return {
          type: "overlap",
          align: "left",
          skipBoundary: !0,
          body: e[0],
        };
      }),
      kt("mathrlap", "{:auto}", null, function (t, e) {
        return {
          type: "overlap",
          mode: "math",
          align: "right",
          skipBoundary: !0,
          body: e[0],
        };
      }),
      kt("mathllap", "{:auto}", null, function (t, e) {
        return {
          type: "overlap",
          mode: "math",
          align: "left",
          skipBoundary: !0,
          body: e[0],
        };
      }),
      kt(
        [
          "arcsin",
          "arccos",
          "arctan",
          "arctg",
          "arcctg",
          "arg",
          "ch",
          "cos",
          "cosec",
          "cosh",
          "cot",
          "cotg",
          "coth",
          "csc",
          "ctg",
          "cth",
          "sec",
          "sin",
          "sinh",
          "sh",
          "tan",
          "tanh",
          "tg",
          "th",
        ],
        "",
        null,
        function (t) {
          return {
            type: "mop",
            limits: "nolimits",
            isSymbol: !1,
            isFunction: !0,
            body: t.slice(1),
            variant: "main",
            variantStyle: "up",
          };
        }
      ),
      kt(
        ["deg", "dim", "exp", "hom", "ker", "lb", "lg", "ln", "log"],
        "",
        null,
        function (t) {
          return {
            type: "mop",
            limits: "nolimits",
            isSymbol: !1,
            isFunction: !0,
            body: t.slice(1),
            variant: "main",
            variantStyle: "up",
          };
        }
      ),
      kt(["lim", "mod"], "", null, function (t) {
        return {
          type: "mop",
          limits: "limits",
          isSymbol: !1,
          body: t.slice(1),
          variant: "main",
        };
      }),
      kt(["det", "max", "min"], "", null, function (t) {
        return {
          type: "mop",
          limits: "limits",
          isSymbol: !1,
          isFunction: !0,
          body: t.slice(1),
          variant: "main",
        };
      }),
      kt(
        "sqrt",
        "[index:auto]{radicand:auto}",
        null,
        (t, e) => ({
          type: "surd",
          body: e[1],
          index: e[0],
        }),
        (t, e, s, i) => {
          let a = "";
          return (
            s.index && (a += `[${i(s, s.index)}]`),
            (a += `{${i(s, s.body)}}`),
            t + a
          );
        }
      ),
      kt(
        ["frac", "dfrac", "tfrac", "cfrac", "binom", "dbinom", "tbinom"],
        "{numerator}{denominator}",
        null,
        (t, e) => {
          const s = {
            type: "genfrac",
            numer: e[0],
            denom: e[1],
            mathstyle: "auto",
          };
          switch (t) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
            case "\\cfrac":
              s.hasBarLine = !0;
              break;
            case "\\\\atopfrac":
              s.hasBarLine = !1;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              (s.hasBarLine = !1), (s.leftDelim = "("), (s.rightDelim = ")");
          }
          switch (t) {
            case "\\dfrac":
            case "\\dbinom":
              s.mathstyle = "displaystyle";
              break;
            case "\\tfrac":
            case "\\tbinom":
              s.mathstyle = "textstyle";
          }
          return "\\cfrac" === t && (s.continuousFraction = !0), s;
        },
        (t, e, s, i) => `${t}{${i(s, s.numer)}}{${i(s, s.denom)}}`
      ),
      kt(
        ["over", "atop", "choose"],
        "",
        {
          infix: !0,
        },
        (t, e) => {
          const s = e[0],
            i = e[1];
          let a = !1,
            r = null,
            n = null;
          switch (t) {
            case "\\atop":
              break;
            case "\\over":
              a = !0;
              break;
            case "\\choose":
              (a = !1), (r = "("), (n = ")");
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          return {
            type: "genfrac",
            numer: s,
            denom: i,
            hasBarLine: a,
            leftDelim: r,
            rightDelim: n,
            mathstyle: "auto",
          };
        },
        (t, e, s, i) => `{${i(s, s.numer)}${t} ${i(s, s.denom)}}`
      ),
      kt(
        "pdiff",
        "{numerator}{denominator}",
        null,
        (t, e) => ({
          type: "genfrac",
          numer: e[0],
          denom: e[1],
          numerPrefix: "∂",
          denomPrefix: "∂",
          hasBarLine: !0,
          leftDelim: null,
          rightDelim: null,
          mathstyle: "auto",
        }),
        (t, e, s, i) => `${t}{${i(s, s.numer)}}{${i(s, s.denom)}}`
      ),
      kt(
        [
          "sum",
          "prod",
          "bigcup",
          "bigcap",
          "coprod",
          "bigvee",
          "bigwedge",
          "biguplus",
          "bigotimes",
          "bigoplus",
          "bigodot",
          "bigsqcup",
          "smallint",
          "intop",
        ],
        "",
        null,
        (t) => ({
          type: "mop",
          limits: "auto",
          isSymbol: !0,
          variant: "main",
          body: {
            coprod: "∐",
            bigvee: "⋁",
            bigwedge: "⋀",
            biguplus: "⨄",
            bigcap: "⋂",
            bigcup: "⋃",
            intop: "∫",
            prod: "∏",
            sum: "∑",
            bigotimes: "⨂",
            bigoplus: "⨁",
            bigodot: "⨀",
            bigsqcup: "⨆",
            smallint: "∫",
          }[t.slice(1)],
        })
      );
    const $t = {
      int: "∫",
      iint: "∬",
      iiint: "∭",
      oint: "∮",
      oiint: "∯",
      oiiint: "∰",
      intclockwise: "∱",
      varointclockwise: "∲",
      ointctrclockwise: "∳",
      intctrclockwise: "⨑",
      sqcup: "⊔",
      sqcap: "⊓",
      uplus: "⊎",
      wr: "≀",
      amalg: "⨿",
      Cap: "⋒",
      Cup: "⋓",
      doublecap: "⋒",
      doublecup: "⋓",
    };

    function Tt(t, e, s, i, a, r = "") {
      const n = W(
        t,
        N("Size" + s + "-Regular", mt("math", e), "delimsizing size" + s),
        a.mathstyle,
        k.textstyle,
        r
      );
      return (
        i &&
          n.setTop(
            (1 - a.mathstyle.sizeMultiplier) * a.mathstyle.metrics.axisHeight
          ),
        n.setStyle("color", a.color),
        "number" == typeof a.opacity && n.setStyle("opacity", a.opacity),
        n
      );
    }

    function Dt(t, e) {
      let s = "";
      return (
        "Size1-Regular" === e
          ? (s = " delim-size1")
          : "Size4-Regular" === e && (s = " delim-size4"),
        N(e, mt("math", t), "delimsizinginner" + s)
      );
    }

    function Ft(t, e, s, i, a, r = "") {
      let n, o, l, c;
      (n = l = c = mt("math", e)), (o = null);
      let h = "Size1-Regular";
      "\\vert" === e ||
      "\\lvert" === e ||
      "\\rvert" === e ||
      "\\mvert" === e ||
      "\\mid" === e
        ? (l = n = c = "∣")
        : "\\Vert" === e ||
          "\\lVert" === e ||
          "\\rVert" === e ||
          "\\mVert" === e ||
          "\\|" === e
        ? (l = n = c = "∥")
        : "\\uparrow" === e
        ? (l = c = "⏐")
        : "\\Uparrow" === e
        ? (l = c = "‖")
        : "\\downarrow" === e
        ? (n = l = "⏐")
        : "\\Downarrow" === e
        ? (n = l = "‖")
        : "\\updownarrow" === e
        ? ((n = "↑"), (l = "⏐"), (c = "↓"))
        : "\\Updownarrow" === e
        ? ((n = "⇑"), (l = "‖"), (c = "⇓"))
        : "[" === e || "\\lbrack" === e
        ? ((n = "⎡"), (l = "⎢"), (c = "⎣"), (h = "Size4-Regular"))
        : "]" === e || "\\rbrack" === e
        ? ((n = "⎤"), (l = "⎥"), (c = "⎦"), (h = "Size4-Regular"))
        : "\\lfloor" === e
        ? ((l = n = "⎢"), (c = "⎣"), (h = "Size4-Regular"))
        : "\\lceil" === e
        ? ((n = "⎡"), (l = c = "⎢"), (h = "Size4-Regular"))
        : "\\rfloor" === e
        ? ((l = n = "⎥"), (c = "⎦"), (h = "Size4-Regular"))
        : "\\rceil" === e
        ? ((n = "⎤"), (l = c = "⎥"), (h = "Size4-Regular"))
        : "(" === e
        ? ((n = "⎛"), (l = "⎜"), (c = "⎝"), (h = "Size4-Regular"))
        : ")" === e
        ? ((n = "⎞"), (l = "⎟"), (c = "⎠"), (h = "Size4-Regular"))
        : "\\{" === e || "\\lbrace" === e
        ? ((n = "⎧"), (o = "⎨"), (c = "⎩"), (l = "⎪"), (h = "Size4-Regular"))
        : "\\}" === e || "\\rbrace" === e
        ? ((n = "⎫"), (o = "⎬"), (c = "⎭"), (l = "⎪"), (h = "Size4-Regular"))
        : "\\lgroup" === e
        ? ((n = "⎧"), (c = "⎩"), (l = "⎪"), (h = "Size4-Regular"))
        : "\\rgroup" === e
        ? ((n = "⎫"), (c = "⎭"), (l = "⎪"), (h = "Size4-Regular"))
        : "\\lmoustache" === e
        ? ((n = "⎧"), (c = "⎭"), (l = "⎪"), (h = "Size4-Regular"))
        : "\\rmoustache" === e
        ? ((n = "⎫"), (c = "⎩"), (l = "⎪"), (h = "Size4-Regular"))
        : "\\surd" === e
        ? ((n = ""), (c = "⎷"), (l = ""), (h = "Size4-Regular"))
        : "\\ulcorner" === e
        ? ((n = "┌"), (l = c = " "))
        : "\\urcorner" === e
        ? ((n = "┐"), (l = c = " "))
        : "\\llcorner" === e
        ? ((c = "└"), (l = n = " "))
        : "\\lrcorner" === e && ((n = "┘"), (l = n = " "));
      const d = y(mt("math", n), h),
        m = d.height + d.depth,
        p = y(mt("math", l), h),
        u = p.height + p.depth,
        f = y(mt("math", c), h),
        g = f.height + f.depth;
      let b = 0,
        x = 1;
      if (null !== o) {
        const t = y(mt("math", o), h);
        (b = t.height + t.depth), (x = 2);
      }
      const v = m + g + b,
        w = Math.ceil((s - v) / (x * u)),
        S = v + w * x * u;
      let M = a.mathstyle.metrics.axisHeight;
      i && (M *= a.mathstyle.sizeMultiplier);
      const A = S / 2 - M,
        _ = [];
      if ((_.push(Dt(c, h)), null === o))
        for (let t = 0; t < w; t++) _.push(Dt(l, h));
      else {
        for (let t = 0; t < w; t++) _.push(Dt(l, h));
        _.push(Dt(o, h));
        for (let t = 0; t < w; t++) _.push(Dt(l, h));
      }
      _.push(Dt(n, h));
      const C = j(a, _, "bottom", A);
      return (
        C.setStyle("color", a.color),
        "number" == typeof a.opacity && C.setStyle("opacity", a.opacity),
        W(t, I(C, "delimsizing mult"), a.mathstyle, k.textstyle, r)
      );
    }
    kt(Object.keys($t), "", null, function (t) {
      return {
        type: "mop",
        limits: "nolimits",
        isSymbol: !0,
        body: $t[t.slice(1)],
        variant: {
          "⋒": "ams",
          "⋓": "ams",
        }[$t[t.slice(1)]],
      };
    }),
      kt(["Re", "Im"], "", null, function (t) {
        return {
          type: "mop",
          limits: "nolimits",
          isSymbol: !1,
          isFunction: !0,
          body: {
            "\\Re": "ℜ",
            "\\Im": "ℑ",
          }[t],
          variant: "fraktur",
        };
      }),
      kt("middle", "{:delim}", null, function (t, e) {
        return {
          type: "delim",
          delim: e[0],
        };
      });
    const qt = [
        "(",
        ")",
        "[",
        "\\lbrack",
        "]",
        "\\rbrack",
        "\\{",
        "\\lbrace",
        "\\}",
        "\\rbrace",
        "\\lfloor",
        "\\rfloor",
        "\\lceil",
        "\\rceil",
        "\\surd",
      ],
      Et = [
        "\\uparrow",
        "\\downarrow",
        "\\updownarrow",
        "\\Uparrow",
        "\\Downarrow",
        "\\Updownarrow",
        "|",
        "\\|",
        "\\vert",
        "\\Vert",
        "\\lvert",
        "\\rvert",
        "\\lVert",
        "\\rVert",
        "\\mvert",
        "\\mid",
        "\\lgroup",
        "\\rgroup",
        "\\lmoustache",
        "\\rmoustache",
      ],
      Pt = [
        "<",
        ">",
        "\\langle",
        "\\rangle",
        "/",
        "\\backslash",
        "\\lt",
        "\\gt",
      ],
      Bt = [0, 1.2, 1.8, 2.4, 3],
      Kt = [
        {
          type: "small",
          mathstyle: k.scriptscriptstyle,
        },
        {
          type: "small",
          mathstyle: k.scriptstyle,
        },
        {
          type: "small",
          mathstyle: k.textstyle,
        },
        {
          type: "large",
          size: 1,
        },
        {
          type: "large",
          size: 2,
        },
        {
          type: "large",
          size: 3,
        },
        {
          type: "large",
          size: 4,
        },
      ],
      Ot = [
        {
          type: "small",
          mathstyle: k.scriptscriptstyle,
        },
        {
          type: "small",
          mathstyle: k.scriptstyle,
        },
        {
          type: "small",
          mathstyle: k.textstyle,
        },
        {
          type: "stack",
        },
      ],
      Rt = [
        {
          type: "small",
          mathstyle: k.scriptscriptstyle,
        },
        {
          type: "small",
          mathstyle: k.scriptstyle,
        },
        {
          type: "small",
          mathstyle: k.textstyle,
        },
        {
          type: "large",
          size: 1,
        },
        {
          type: "large",
          size: 2,
        },
        {
          type: "large",
          size: 3,
        },
        {
          type: "large",
          size: 4,
        },
        {
          type: "stack",
        },
      ];

    function It(t, e, s, i, a, r = "") {
      if (!e || 0 === e.length || "." === e) return Ht(t, a, t);
      let n;
      "<" === e || "\\lt" === e
        ? (e = "\\langle")
        : (">" !== e && "\\gt" !== e) || (e = "\\rangle"),
        (n = Pt.includes(e) ? Kt : qt.includes(e) ? Rt : Ot);
      const o = (function (t, e, s, i) {
        for (
          let r = Math.min(2, 3 - i.mathstyle.size);
          r < s.length && "stack" !== s[r].type;
          r++
        ) {
          const i = y(
            t,
            "small" === (a = s[r]).type
              ? "Main-Regular"
              : "large" === a.type
              ? "Size" + a.size + "-Regular"
              : "Size4-Regular"
          );
          if (i.defaultMetrics)
            return {
              type: "small",
              mathstyle: k.scriptstyle,
            };
          let n = i.height + i.depth;
          if (
            ("small" === s[r].type && (n *= s[r].mathstyle.sizeMultiplier),
            n > e)
          )
            return s[r];
        }
        var a;
        return s[s.length - 1];
      })(mt("math", e), s, n, a);
      return "small" === o.type
        ? (function (t, e, s, i, a, r = "") {
            const n = W(t, N("AMS-Regular", mt("math", e)), a.mathstyle, s, r);
            return (
              i &&
                n.setTop(
                  (1 - a.mathstyle.sizeMultiplier / s.sizeMultiplier) *
                    a.mathstyle.metrics.axisHeight
                ),
              n.setStyle("color", a.color),
              "number" == typeof a.opacity && n.setStyle("opacity", a.opacity),
              n
            );
          })(t, e, o.mathstyle, i, a, r)
        : "large" === o.type
        ? Tt(t, e, o.size, i, a, r)
        : Ft(t, e, s, i, a, r);
    }

    function Nt(t, e, s, i, a, r = "") {
      if ("." === e) return Ht(t, a, r);
      const n = a.mathstyle.metrics.axisHeight * a.mathstyle.sizeMultiplier,
        o = 5 / c;
      let l = i + n,
        h = s - n;
      h = Math.max(l, h);
      let d = (901 * h) / 500;
      return (l = 2 * h - o), (d = Math.max(d, l)), It(t, e, d, !0, a, r);
    }

    function Ht(t, e, s) {
      return I(
        "",
        "sizing" +
          e.mathstyle.adjustTo(k.textstyle) +
          " nulldelimiter " +
          (s || ""),
        t
      );
    }

    function Wt(t, e) {
      if (!(e = void 0 !== e && e) && t.latex) return t.latex;
      let s = "",
        i = 0,
        a = 0,
        r = 0;
      const n = t.symbol,
        o = (t, s) =>
          (function (t, e, s) {
            let i = "";
            return (
              Array.isArray(e)
                ? (i = (function (t, e, s) {
                    if (0 === e.length) return "";
                    if ("first" === e[0].type) {
                      if (1 === e.length) return "";
                      e = e.slice(1);
                    }
                    return 0 === e.length
                      ? ""
                      : _(e, "cssClass")
                          .map((e) => {
                            const i = _(e, "color")
                              .map((e) =>
                                (function (t) {
                                  const e = [];
                                  let s = [],
                                    i = "NONE";
                                  return (
                                    t.forEach((t) => {
                                      "first" !== t.type &&
                                        (t.mode !== i
                                          ? (s.length > 0 && e.push(s),
                                            (s = [t]),
                                            (i = t.mode))
                                          : s.push(t));
                                    }),
                                    s.length > 0 && e.push(s),
                                    e
                                  );
                                })(e)
                                  .map((e) =>
                                    (function (t, e, s) {
                                      return C[e[0].mode] &&
                                        C[e[0].mode].emitLatexRun
                                        ? C[e[0].mode].emitLatexRun(t, e, s)
                                        : "";
                                    })(t, e, s)
                                  )
                                  .join("")
                              )
                              .join("");
                            return !e[0].cssClass ||
                              (t && t.cssClass === e[0].cssClass)
                              ? i
                              : "ML__boldsymbol" === e[0].cssClass
                              ? "\\boldsymbol{" + i + "}"
                              : "ML__emph" === e[0].cssClass
                              ? "\\emph{" + i + "}"
                              : "\\class{" + e[0].cssClass + "}{" + i + "}";
                          })
                          .join("");
                  })(t, e, s))
                : "number" == typeof e || "boolean" == typeof e
                ? (i = e.toString())
                : "string" == typeof e
                ? (i = e.replace(/\s/g, "~"))
                : e && "function" == typeof e.toLatex && (i = e.toLatex(s)),
              i
            );
          })(t, s, e);
      switch (t.type) {
        case "group":
          n
            ? (s = e ? o(t, t.body) : t.latex)
            : ((s = t.latexOpen || (t.cssId || t.cssClass ? "" : "{")),
              t.cssId && (s += "\\cssId{" + t.cssId + "}{"),
              "ML__emph" === t.cssClass
                ? (s += `\\emph{${o(t, t.body)}`)
                : (t.cssClass && (s += "\\class{" + t.cssClass + "}{"),
                  (s += o(t, t.body)),
                  t.cssClass && (s += "}")),
              t.cssId && (s += "}"),
              (s += t.latexClose || (t.cssId || t.cssClass ? "" : "}")));
          break;
        case "array":
          if (((s += "\\begin{" + t.env.name + "}"), "array" === t.env.name)) {
            if (((s += "{"), t.colFormat))
              for (r = 0; r < t.colFormat.length; r++)
                t.colFormat[r].align
                  ? (s += t.colFormat[r].align)
                  : t.colFormat[r].rule && (s += "|");
            s += "}";
          }
          for (a = 0; a < t.array.length; a++) {
            for (i = 0; i < t.array[a].length; i++)
              i > 0 && (s += " & "), (s += o(t, t.array[a][i]));
            a < t.array.length - 1 && (s += " \\\\ ");
          }
          s += "\\end{" + t.env.name + "}";
          break;
        case "root":
          s = o(t, t.body);
          break;
        case "leftright":
          t.inner
            ? ((s += "\\left" + (t.leftDelim || ".")),
              t.leftDelim && t.leftDelim.length > 1 && (s += " "),
              (s += o(t, t.body)),
              (s += "\\right" + (t.rightDelim || ".")),
              t.rightDelim && t.rightDelim.length > 1 && (s += " "))
            : e && "(" === t.leftDelim && ")" === t.rightDelim
            ? (s += `(${o(t, t.body)})`)
            : ((s += "\\mleft" + (t.leftDelim || ".")),
              t.leftDelim && t.leftDelim.length > 1 && (s += " "),
              (s += o(t, t.body)),
              (s += "\\mright" + (t.rightDelim || ".")),
              t.rightDelim && t.rightDelim.length > 1 && (s += " "));
          break;
        case "delim":
        case "sizeddelim":
          s += n + "{" + t.delim + "}";
          break;
        case "rule":
          (s += n),
            t.shift && (s += `[${o(t, t.shift)}em]`),
            (s += `{${o(t, t.width)}em}{${o(t, t.height)}em}`);
          break;
        case "mord":
        case "minner":
        case "mbin":
        case "mrel":
        case "mpunct":
        case "mopen":
        case "mclose":
        case "textord":
          s += '\\char"' === n ? t.latex + " " : pt(n, null, t, o);
          break;
        case "mop":
          "​" !== t.body &&
            ("\\mathop" === n || "\\operatorname" === n
              ? (s += n + "{" + o(t, t.body) + "}")
              : ((s += n), /^\\.*[a-zA-Z0-9]$/.test(n) && (s += " "))),
            t.explicitLimits &&
              ("limits" === t.limits && (s += "\\limits "),
              "nolimits" === t.limits && (s += "\\nolimits "));
          break;
        case "spacing":
          (s += n),
            "\\hspace" === n || "\\hspace*" === n
              ? ((s += "{"),
                t.width ? (s += t.width + "em") : (s += "0em"),
                (s += "}"))
              : ((s += " "), t.width && (s += t.width + "em "));
          break;
        case "enclose":
          if (((s += n), "\\enclose" === n)) {
            s += "{" + Object.keys(t.notation).join(" ") + "}";
            let e = "",
              i = "";
            t.backgroundColor &&
              "transparent" !== t.backgroundColor &&
              ((e += i + 'mathbackground="' + Lt(t.backgroundColor) + '"'),
              (i = ",")),
              t.shadow &&
                "auto" !== t.shadow &&
                ((e += i + 'shadow="' + t.shadow + '"'), (i = ",")),
              1 !== t.strokeWidth || "solid" !== t.strokeStyle
                ? ((e += i + t.borderStyle), (i = ","))
                : t.strokeColor &&
                  "currentColor" !== t.strokeColor &&
                  ((e += i + 'mathcolor="' + Lt(t.strokeColor) + '"'),
                  (i = ",")),
              e && (s += `[${e}]`);
          }
          s += `{${o(t, t.body)}}`;
          break;
        case "mathstyle":
          s += "\\" + t.mathstyle + " ";
          break;
        case "space":
          s += t.symbol;
          break;
        case "placeholder":
          s += "\\placeholder{}";
          break;
        case "first":
        case "command":
        case "msubsup":
          break;
        case "error":
          s += t.latex;
          break;
        case "":
          break;
        default:
          (s = pt(n, parent, t, o)), s || (s += n);
      }
      if (t.superscript) {
        let e = o(t, t.superscript);
        1 === e.length
          ? ("′" === e ? (e = "\\prime ") : "″" === e && (e = "\\doubleprime "),
            (s += "^" + e))
          : (s += "^{" + e + "}");
      }
      if (t.subscript) {
        const e = o(t, t.subscript);
        1 === e.length ? (s += "_" + e) : (s += "_{" + e + "}");
      }
      return s;
    }
    const Vt = {},
      jt = {
        size1: 0.5,
        size2: 0.7,
        size3: 0.8,
        size4: 0.9,
        size5: 1,
        size6: 1.2,
        size7: 1.44,
        size8: 1.73,
        size9: 2.07,
        size10: 2.49,
      };

    function Ut(t, e) {
      Vt[t] = {
        decompose: e,
      };
    }

    function Gt(t, e) {
      var s, i;

      function a(t) {
        return "mord" === t.type && !!t.symbol && /^[0-9,.]$/.test(t.symbol);
      }

      function r(t) {
        return "text" === t.mode;
      }
      t instanceof w || (t = new w(t));
      const n = !t.atomIdsSettings || !t.atomIdsSettings.groupNumbers;
      let o = [];
      if (Array.isArray(e)) {
        if (0 === e.length) return [];
        if (1 === e.length)
          (o = e[0].decompose(t)),
            o && n && e[0].isSelected && o.forEach((t) => t.selected(!0));
        else {
          let l = "none",
            c = e[1].type,
            h = [],
            d = "",
            m = !0,
            p = null;
          for (let u = 0; u < e.length; u++) {
            "mbin" === e[u].type &&
              (/first|none|mrel|mpunct|mopen|mbin|mop/.test(l) ||
                /none|mrel|mpunct|mclose/.test(c)) &&
              (e[u].type = "mord"),
              ("​" === e[u].body && (e[u].superscript || e[u].subscript)) ||
                (p = null),
              (null === (s = t.atomIdsSettings) || void 0 === s
                ? void 0
                : s.groupNumbers) &&
                d &&
                ((m && a(e[u])) || (!m && r(e[u]))) &&
                (t.atomIdsSettings.overrideID = d);
            const f = e[u].decompose(t, p);
            if (
              (t.atomIdsSettings && (t.atomIdsSettings.overrideID = null), f)
            ) {
              const s = [].concat(...f);
              (p = s),
                (null === (i = t.atomIdsSettings) || void 0 === i
                  ? void 0
                  : i.groupNumbers) &&
                  ((a(e[u]) || r(e[u])) &&
                    ((d && m === a(e[u])) || ((m = a(e[u])), (d = e[u].id))),
                  ((!a(e[u]) && !r(e[u])) ||
                    e[u].superscript ||
                    e[u].subscript) &&
                    d &&
                    (d = "")),
                n && e[u].isSelected
                  ? ((h = h.concat(s)), h.forEach((t) => t.selected(!0)))
                  : (h.length > 0 && ((o = [...o, ...h]), (h = [])),
                    (o = o.concat(s)));
            }
            (l = e[u].getFinalBaseElement().type),
              (c = e[u + 1] ? e[u + 1].getInitialBaseElement().type : "none");
          }
          h.length > 0 && ((o = [...o, ...h]), (h = []));
        }
      } else
        e &&
          ((o = e.decompose(t)),
          o && n && e.isSelected && o.forEach((t) => t.selected(!0)));
      if (!o || 0 === o.length) return null;
      if (t.mathstyle !== t.parentMathstyle) {
        const e = t.mathstyle.sizeMultiplier / t.parentMathstyle.sizeMultiplier;
        for (const t of o) (t.height *= e), (t.depth *= e);
      }
      if (t.size !== t.parentSize) {
        const e = jt[t.size] / jt[t.parentSize];
        for (const t of o) (t.height *= e), (t.depth *= e);
      }
      return o;
    }
    class Zt {
      constructor(t, e, s = "", i = {}) {
        (this.mode = t), (this.type = e), (this.body = s), this.applyStyle(i);
      }
      toLatex(t) {
        return Wt(this, t);
      }
      getStyle() {
        return {
          mode: this.mode,
          color: this.phantom ? "transparent" : this.color,
          backgroundColor: this.phantom ? "transparent" : this.backgroundColor,
          variant: this.variant,
          variantStyle: this.variantStyle,
          fontFamily: this.fontFamily,
          fontShape: this.fontShape,
          fontSeries: this.fontSeries,
          fontSize: this.fontSize,
          cssId: this.cssId,
          cssClass: this.cssClass,
        };
      }
      applyStyle(t) {
        Object.assign(this, t),
          "none" === this.fontFamily && (this.fontFamily = ""),
          "auto" === this.fontShape && (this.fontShape = ""),
          "auto" === this.fontSeries && (this.fontSeries = ""),
          "none" === this.color && (this.color = ""),
          "none" === this.backgroundColor && (this.backgroundColor = ""),
          "auto" === this.fontSize && (this.fontSize = ""),
          this.fontSize && (this.maxFontSize = jt[this.fontSize]),
          "text" === this.mode && "root" !== this.type && (this.type = "");
      }
      getInitialBaseElement() {
        let t;
        return (
          Array.isArray(this.body) &&
            this.body.length > 0 &&
            ("first" !== this.body[0].type
              ? (t = this.body[0].getInitialBaseElement())
              : this.body[1] && (t = this.body[1].getInitialBaseElement())),
          t || this
        );
      }
      getFinalBaseElement() {
        return Array.isArray(this.body) && this.body.length > 0
          ? this.body[this.body.length - 1].getFinalBaseElement()
          : this;
      }
      isCharacterBox() {
        const t = this.getInitialBaseElement();
        return /minner|mbin|mrel|mpunct|mopen|mclose|textord/.test(t.type);
      }
      forEach(t) {
        if ((t(this), Array.isArray(this.body)))
          for (const e of this.body) e && e.forEach(t);
        else this.body && "object" == typeof this.body && t(this.body);
        if (this.superscript)
          for (const e of this.superscript) e && e.forEach(t);
        if (this.subscript) for (const e of this.subscript) e && e.forEach(t);
        if (this.overscript) for (const e of this.overscript) e && e.forEach(t);
        if (this.underscript)
          for (const e of this.underscript) e && e.forEach(t);
        if (this.numer) for (const e of this.numer) e && e.forEach(t);
        if (this.denom) for (const e of this.denom) e && e.forEach(t);
        if (this.index) for (const e of this.index) e && e.forEach(t);
        if (this.array)
          for (const e of this.array)
            for (const s of e) for (const e of s) e.forEach(t);
      }
      filter(t) {
        let e = [];
        t(this) && e.push(this);
        for (const s of [
          "body",
          "superscript",
          "subscript",
          "overscript",
          "underscript",
          "numer",
          "denom",
          "index",
        ])
          if (Array.isArray(this[s]))
            for (const i of this[s]) i && (e = e.concat(i.filter(t)));
        if (Array.isArray(this.array))
          for (const s of this.array)
            for (const i of s) i && (e = e.concat(i.filter(t)));
        return e;
      }
      decomposeGroup(t) {
        const e = I(
          Gt(
            t.clone({
              mathstyle: this.mathstyle ? k[this.mathstyle] : void 0,
            }),
            this.body
          ),
          "",
          "mord"
        );
        return (
          this.cssId && (e.cssId = this.cssId),
          e.applyStyle({
            backgroundColor: this.backgroundColor,
            cssClass: this.cssClass,
          }),
          e
        );
      }
      decomposeOverlap(t) {
        const e = I(Gt(t, this.body), "inner");
        return I(
          [e, I(null, "fix")],
          "left" === this.align ? "llap" : "rlap",
          "mord"
        );
      }
      decomposeRule(t) {
        const e = t.mathstyle,
          s = I("", "rule", "mord");
        let i = this.shift && !isNaN(this.shift) ? this.shift : 0;
        i /= e.sizeMultiplier;
        const a = this.width / e.sizeMultiplier,
          r = this.height / e.sizeMultiplier;
        return (
          s.setStyle("border-right-width", a, "em"),
          s.setStyle("border-top-width", r, "em"),
          s.setStyle("margin-top", -(r - i), "em"),
          s.setStyle("border-color", t.color),
          (s.width = a),
          (s.height = r + i),
          (s.depth = -i),
          s
        );
      }
      decompose(t, e = null) {
        let s = null;
        if (
          (!this.type ||
          /mord|minner|mbin|mrel|mpunct|mopen|mclose|textord/.test(this.type)
            ? ((s =
                "string" == typeof this.body
                  ? this.makeSpan(t, this.body)
                  : this.makeSpan(t, Gt(t, this.body))),
              (s.type = $(this.type) ? this.type : ""))
            : "group" === this.type || "root" === this.type
            ? (s = this.decomposeGroup(t))
            : "delim" === this.type
            ? ((s = I(null, "")), (s.delim = this.delim))
            : "sizeddelim" === this.type
            ? (s = this.bind(
                t,
                (function (t, e, s, i, a = "") {
                  return "." === e
                    ? Ht(t, i, a)
                    : ("<" === e || "\\lt" === e
                        ? (e = "\\langle")
                        : (">" !== e && "\\gt" !== e) || (e = "\\rangle"),
                      qt.includes(e) || Pt.includes(e)
                        ? Tt(t, e, s, !1, i, a)
                        : Et.includes(e)
                        ? Ft(t, e, Bt[s], !1, i, a)
                        : null);
                })(this.cls, this.delim, this.size, t)
              ))
            : "overlap" === this.type
            ? (s = this.decomposeOverlap(t))
            : "rule" === this.type
            ? (s = this.decomposeRule(t))
            : "msubsup" === this.type
            ? ((s = I("​", "", "mord")),
              e && ((s.height = e[0].height), (s.depth = e[0].depth)))
            : "space" === this.type
            ? (s = this.makeSpan(t, " "))
            : "spacing" === this.type
            ? "​" === this.body
              ? (s = this.makeSpan(t, "​"))
              : " " === this.body
              ? (s =
                  "math" === this.mode
                    ? this.makeSpan(t, " ")
                    : this.makeSpan(t, " "))
              : this.width
              ? ((s = I("​", "mspace ")),
                this.width > 0
                  ? s.setWidth(this.width)
                  : s.setStyle("margin-left", this.width, "em"))
              : (s = I(
                  "​",
                  "mspace " +
                    ({
                      qquad: "qquad",
                      quad: "quad",
                      enspace: "enspace",
                      ";": "thickspace",
                      ":": "mediumspace",
                      ",": "thinspace",
                      "!": "negativethinspace",
                    }[this.body] || "quad")
                ))
            : "mathstyle" === this.type
            ? t.setMathstyle(this.mathstyle)
            : "command" === this.type || "error" === this.type
            ? ((s = this.makeSpan(t, this.body)),
              (s.classes = ""),
              this.error && (s.classes += " ML__error"),
              this.suggestion && (s.classes += " ML__suggestion"))
            : (s =
                "placeholder" === this.type
                  ? this.makeSpan(t, "⬚")
                  : "first" === this.type
                  ? this.makeSpan(t, "​")
                  : Vt[this.type].decompose(t, this)),
          !s)
        )
          return null;
        if (
          (this.caret &&
            "msubsup" !== this.type &&
            "command" !== this.type &&
            "placeholder" !== this.type &&
            "first" !== this.type &&
            (Array.isArray(s)
              ? (s[s.length - 1].caret = this.caret)
              : (s.caret = this.caret)),
          this.containsCaret &&
            (Array.isArray(s)
              ? ((s[0].classes = (s[0].classes || "") + " ML__contains-caret"),
                (s[s.length - 1].classes =
                  (s[s.length - 1].classes || "") + " ML__contains-caret"))
              : (s.classes = (s.classes || "") + " ML__contains-caret")),
          !this.limits && (this.superscript || this.subscript))
        )
          if (Array.isArray(s)) {
            const e = s[s.length - 1];
            s[s.length - 1] = this.attachSupsub(t, e, e.type);
          } else s = [this.attachSupsub(t, s, s.type)];
        return Array.isArray(s) ? s : [s];
      }
      attachSupsub(t, e, s) {
        if (!this.superscript && !this.subscript) return e;
        const a = t.mathstyle;
        let r = null,
          n = null;
        this.superscript &&
          (r = I(Gt(t.sup(), this.superscript), a.adjustTo(a.sup()))),
          this.subscript &&
            (n = I(Gt(t.sub(), this.subscript), a.adjustTo(a.sub())));
        let o,
          l = 0,
          h = 0;
        this.isCharacterBox() ||
          ((l = K(e) - a.metrics.supDrop), (h = O(e) + a.metrics.subDrop)),
          (o =
            a === k.displaystyle
              ? a.metrics.sup1
              : a.cramped
              ? a.metrics.sup3
              : a.metrics.sup2);
        const d = k.textstyle.sizeMultiplier * a.sizeMultiplier,
          m = 0.5 / c / d;
        let p = null;
        if (n && r) {
          (l = Math.max(l, o, r.depth + 0.25 * a.metrics.xHeight)),
            (h = Math.max(h, a.metrics.sub2));
          const s = i;
          if (l - O(r) - (K(n) - h) < 4 * s) {
            h = 4 * s - (l - r.depth) + K(n);
            const t = 0.8 * a.metrics.xHeight - (l - O(r));
            t > 0 && ((l += t), (h -= t));
          }
          (p = j(t, [n, h, r, -l], "individualShift")),
            this.isSymbol && p.children[0].setLeft(-R(e));
        } else
          n && !r
            ? ((h = Math.max(
                h,
                a.metrics.sub1,
                K(n) - 0.8 * a.metrics.xHeight
              )),
              (p = j(t, [n], "shift", h)),
              p.children[0].setRight(m),
              this.isCharacterBox() && p.children[0].setLeft(-R(e)))
            : !n &&
              r &&
              ((l = Math.max(l, o, r.depth + 0.25 * a.metrics.xHeight)),
              (p = j(t, [r], "shift", -l)),
              p.children[0].setRight(m));
        const u = I(p, "msubsup");
        return (
          this.caret && ((u.caret = this.caret), (this.caret = "")),
          I([e, u], "", s)
        );
      }
      attachLimits(t, e, s, i) {
        const c = this.superscript
            ? I(
                Gt(t.sup(), this.superscript),
                t.mathstyle.adjustTo(t.mathstyle.sup())
              )
            : null,
          h = this.subscript
            ? I(
                Gt(t.sub(), this.subscript),
                t.mathstyle.adjustTo(t.mathstyle.sub())
              )
            : null;
        return (function (t, e, s, i, c, h) {
          if (!c && !h) return e;
          e = I(e);
          let d = 0,
            m = 0;
          c && (d = Math.max(a, n - O(c))), h && (m = Math.max(r, o - K(h)));
          let p = null;
          if (h && c) {
            const a = l + K(h) + O(h) + m + O(e) + s;
            (p = j(t, [l, h, m, e, d, c, l], "bottom", a)),
              p.children[0].setLeft(-i),
              p.children[2].setLeft(i);
          } else if (h && !c) {
            const a = K(e) - s;
            (p = j(t, [l, h, m, e], "top", a)), p.children[0].setLeft(-i);
          } else if (!h && c) {
            const a = O(e) + s;
            (p = j(t, [e, d, c, l], "bottom", a)), p.children[1].setLeft(i);
          }
          return I(p, "op-limits", "mop");
        })(t, e, s, i, c, h);
      }
      bind(t, e) {
        return (
          "first" !== this.type &&
            "​" !== this.body &&
            ((this.id = (function (t) {
              let e;
              return (
                t.atomIdsSettings &&
                  ("number" == typeof t.atomIdsSettings.seed
                    ? ((e = t.atomIdsSettings.overrideID
                        ? t.atomIdsSettings.overrideID
                        : t.atomIdsSettings.seed.toString(36)),
                      (t.atomIdsSettings.seed += 1))
                    : (e =
                        Date.now().toString(36).slice(-2) +
                        Math.floor(1e5 * Math.random()).toString(36))),
                e
              );
            })(t)),
            this.id &&
              (e.attributes || (e.attributes = {}),
              (e.attributes["data-atom-id"] = this.id))),
          e
        );
      }
      makeSpan(t, e) {
        const s = I(
            e,
            "",
            "textord" === this.type ? "mord" : $(this.type) ? this.type : ""
          ),
          i = this.getStyle();
        (i.letterShapeStyle = t.letterShapeStyle), s.applyStyle(i);
        const a = (null == i ? void 0 : i.fontSize) ? i.fontSize : "size5";
        return (
          a !== t.parentSize
            ? ((s.classes += " sizing reset-" + t.parentSize),
              (s.classes += " " + a))
            : t.parentSize !== t.size &&
              ((s.classes += " sizing reset-" + t.parentSize),
              (s.classes += " " + t.size)),
          (s.maxFontSize = Math.max(
            s.maxFontSize,
            t.mathstyle.sizeMultiplier || 1
          )),
          "text" === this.mode && (s.classes += " ML__text"),
          t.mathstyle.isTight() && (s.isTight = !0),
          "math" !== this.mode && (s.italic = 0),
          s.setRight(s.italic),
          "number" == typeof t.opacity && s.setStyle("opacity", t.opacity),
          this.bind(t, s),
          this.caret &&
            (this.superscript ||
              this.subscript ||
              ((s.caret = this.caret),
              (this.caret = ""),
              t.mathstyle.isTight() && (s.isTight = !0))),
          s
        );
      }
    }

    function Xt(t, e) {
      const s = new Zt((t = t || "math"), "root", e || []);
      return (
        !Array.isArray(s.body) ||
          (0 !== s.body.length && "first" === s.body[0].type) ||
          s.body.unshift(new Zt("", "first")),
        s
      );
    }

    function Yt(t) {
      const e = I("​", "arraycolsep");
      return e.setWidth(t), e;
    }

    function Jt(t, e, s, i) {
      const a = [];
      for (const r of e) {
        const e = I(Gt(t, i));
        (e.depth = r.depth),
          (e.height = r.height),
          a.push(e),
          a.push(r.pos - s);
      }
      return j(t, a, "individualShift");
    }
    Ut("genfrac", (t, e) => {
      const s = "auto" === e.mathstyle ? t.mathstyle : k[e.mathstyle],
        a = t.clone({
          mathstyle: s,
        });
      let r = [];
      e.numerPrefix && r.push(I(e.numerPrefix, "mord"));
      const n = e.continuousFraction ? s : s.fracNum();
      r = r.concat(
        Gt(
          a.clone({
            mathstyle: n,
          }),
          e.numer
        )
      );
      const o = V(r, t.mathstyle.adjustTo(n));
      let l = [];
      e.denomPrefix && l.push(I(e.denomPrefix, "mord"));
      const c = e.continuousFraction ? s : s.fracDen();
      l = l.concat(
        Gt(
          a.clone({
            mathstyle: c,
          }),
          e.denom
        )
      );
      const h = V(l, t.mathstyle.adjustTo(c)),
        d = e.hasBarLine ? i / s.sizeMultiplier : 0;
      let m,
        p,
        u = 0;
      s.size === k.displaystyle.size
        ? ((m = s.metrics.num1),
          (u = d > 0 ? 3 * d : 7 * i),
          (p = s.metrics.denom1))
        : (d > 0
            ? ((m = s.metrics.num2), (u = d))
            : ((m = s.metrics.num3), (u = 3 * i)),
          (p = s.metrics.denom2));
      const f = o ? O(o) : 0,
        g = h ? K(h) : 0;
      let y;
      if (0 === d) {
        const t = m - f - (g - p);
        t < u && ((m += 0.5 * (u - t)), (p += 0.5 * (u - t))),
          (y = j(a, [o, -m, h, p], "individualShift"));
      } else {
        const t = s.metrics.axisHeight,
          i = t + 0.5 * d,
          r = t - 0.5 * d;
        m - f - i < u && (m += u - (m - f - i)),
          r - (g - p) < u && (p += u - (r - (g - p)));
        const n = I(null, " frac-line");
        n.applyStyle(e.getStyle()), (n.height = d / 2), (n.depth = d / 2);
        const l = [];
        o && (l.push(o), l.push(-m)),
          l.push(n),
          l.push(d / 2 - t),
          h && (l.push(h), l.push(p)),
          (y = j(a, l, "individualShift"));
      }
      (y.classes += " mfrac"),
        (y.height *= s.sizeMultiplier / t.mathstyle.sizeMultiplier),
        (y.depth *= s.sizeMultiplier / t.mathstyle.sizeMultiplier);
      const b =
          s.size === k.displaystyle.size ? s.metrics.delim1 : s.metrics.delim2,
        x = e.bind(
          t,
          It(
            "mopen",
            e.leftDelim,
            b,
            !0,
            t.clone({
              mathstyle: s,
            })
          )
        ),
        v = e.bind(
          t,
          It(
            "mclose",
            e.rightDelim,
            b,
            !0,
            t.clone({
              mathstyle: s,
            })
          )
        );
      return (
        x.applyStyle(e.getStyle()),
        v.applyStyle(e.getStyle()),
        [
          e.bind(
            t,
            I(
              [x, y, v],
              t.parentSize !== t.size
                ? "sizing reset-" + t.parentSize + " " + t.size
                : "",
              "mord"
            )
          ),
        ]
      );
    }),
      Ut("array", (t, e) => {
        let s = e.colFormat;
        s &&
          0 === s.length &&
          (s = [
            {
              align: "l",
            },
          ]),
          s ||
            (s = [
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
              {
                align: "l",
              },
            ]);
        const i = [];
        let a = 0;
        for (const t of s) t.align && a++;
        for (const t of e.array) {
          let e = 0;
          for (; e < t.length; ) {
            const s = [],
              r = Math.min(t.length, e + a);
            for (; e < r; ) s.push(t[e++]);
            i.push(s);
          }
        }
        1 === i[i.length - 1].length &&
          0 === i[i.length - 1][0].length &&
          i.pop();
        const r = k[e.mathstyle] || t.mathstyle,
          n = e.arraystretch || 1,
          o = "number" == typeof e.arraycolsep ? e.arraycolsep : d,
          l = n * m,
          c = 0.7 * l,
          u = 0.3 * l;
        let f = 0,
          g = 0;
        const y = [],
          b = i.length;
        for (let s = 0; s < b; ++s) {
          const a = i[s];
          g = Math.max(g, a.length);
          let r = c,
            n = u;
          const o = {
            cells: [],
            height: 0,
            depth: 0,
            pos: 0,
          };
          for (let s = 0; s < a.length; ++s) {
            const i =
                Gt(
                  t.clone({
                    mathstyle: k[e.mathstyle],
                  }),
                  a[s]
                ) || [],
              l = [I(null, "", "mord")].concat(i);
            (n = Math.max(n, O(l))), (r = Math.max(r, K(l))), o.cells.push(l);
          }
          let l = s === b - 1 ? 0 : e.jot || 0;
          e.rowGaps &&
            e.rowGaps[s] &&
            ((l = e.rowGaps[s]),
            l > 0 && ((l += u), n < l && (n = l), (l = 0))),
            (o.height = r),
            (o.depth = n),
            (f += r),
            (o.pos = f),
            (f += n + l),
            y.push(o);
        }
        const x = f / 2 + r.metrics.axisHeight,
          v = [];
        for (let e = 0; e < g; e++) {
          const s = [];
          for (const t of y) {
            const i = t.cells[e];
            i &&
              ((i.depth = t.depth),
              (i.height = t.height),
              s.push(i),
              s.push(t.pos - x));
          }
          s.length > 0 && v.push(j(t, s, "individualShift"));
        }
        const w = [];
        let S = !1,
          M = !1,
          A = 0,
          _ = !e.lFence;
        for (const e of s) {
          if (e.align && A >= v.length) break;
          if (e.align && A < v.length)
            S ? w.push(Yt(2 * o)) : (M || _) && w.push(Yt(o)),
              w.push(I(v[A], "col-align-" + e.align)),
              A++,
              (S = !0),
              (M = !1),
              (_ = !1);
          else if (void 0 !== e.gap)
            "number" == typeof e.gap
              ? w.push(Yt(e.gap))
              : w.push(Jt(t, y, x, e.gap)),
              (S = !1),
              (M = !1),
              (_ = !1);
          else if (e.rule) {
            const e = I(null, "vertical-separator");
            e.setStyle("height", f, "em"),
              e.setStyle(
                "margin-top",
                3 * t.mathstyle.metrics.axisHeight - x,
                "em"
              ),
              e.setStyle("vertical-align", "top");
            let s = 0;
            M ? (s = h - p) : S && (s = o - p),
              e.setLeft(s),
              w.push(e),
              (S = !1),
              (M = !0),
              (_ = !1);
          }
        }
        if (
          (S && !e.rFence && w.push(Yt(o)),
          !((e.lFence && "." !== e.lFence) || (e.rFence && "." !== e.rFence)))
        )
          return [I(w, "mtable", "mord")];
        const C = I(w, "mtable"),
          L = K(C),
          z = O(C);
        return [
          I(
            [
              e.bind(t, Nt("mopen", e.lFence, L, z, t)),
              C,
              e.bind(t, Nt("mclose", e.rFence, L, z, t)),
            ],
            "",
            "mord"
          ),
        ];
      }),
      Ut("overunder", (t, e) => {
        const s = e.svgBody ? U(e.svgBody) : Gt(t, e.body),
          i = t.clone({
            mathstyle: k.scriptstyle,
          });
        let l, c;
        return (
          e.svgAbove
            ? (l = U(e.svgAbove))
            : e.overscript &&
              (l = I(Gt(i, e.overscript), t.mathstyle.adjustTo(i.mathstyle))),
          e.svgBelow
            ? (c = U(e.svgBelow))
            : e.underscript &&
              (c = I(Gt(i, e.underscript), t.mathstyle.adjustTo(i.mathstyle))),
          l &&
            c &&
            (c.setLeft(0.3), c.setRight(0.3), l.setLeft(0.3), l.setRight(0.3)),
          (function (t, e, s, i, l) {
            if (!s && !i) return Array.isArray(e) ? e : [e];
            let c = 0,
              h = 0;
            s && (c = Math.max(a, n - O(s))), i && (h = Math.max(r, o - K(i)));
            let d = null;
            if (i && s) {
              const a = K(i) + O(i) + O(e);
              d = j(t, [0, i, n + O(e), e, -c, s, r], "bottom", a);
            } else if (i && !s) {
              d = j(t, [0, i, h, e], "top", K(e));
            } else
              s &&
                !i &&
                (d = j(t, [e, Math.max(r, c - O(s)), s, 0], "bottom", O(e)));
            return [I(d, "op-over-under", l)];
          })(t, s, l, c, $(e.type) ? e.type : "mord")
        );
      }),
      Ut("accent", (t, e) => {
        const s = t.mathstyle;
        let i = Gt(t.cramp(), e.body);
        (e.superscript || e.subscript) &&
          (i = [e.attachSupsub(t, I(i, "", "mord"), "mord")]);
        let r = 0;
        Array.isArray(e.body) &&
          1 === e.body.length &&
          e.body[0].isCharacterBox() &&
          (r = (function (t) {
            if (!t) return 0;
            if (Array.isArray(t)) {
              let e = 0;
              for (const s of t) e += s.skew || 0;
              return e;
            }
            return t.skew;
          })(i));
        let n,
          o = Math.min(K(i), s.metrics.xHeight);
        if (e.svgAccent) (n = U(e.svgAccent)), (o = -o + a);
        else {
          const t = N("Main-Regular", e.accent, "math");
          t.italic = 0;
          const s = "⃗" === e.accent ? " accent-vec" : "";
          n = I(I(t), "accent-body" + s);
        }
        return (
          (n = j(t, [i, -o, n])),
          n.children[1].setLeft(2 * r),
          [I([n], "accent", "mord")]
        );
      }),
      Ut("enclose", (t, e) => {
        const s = I(Gt(t, e.body), "", "mord"),
          i = "number" == typeof e.padding ? e.padding : u,
          a = I("", "ML__notation");
        a.setStyle("position", "absolute"),
          a.setStyle("height", K(s) + O(s) + 2 * i, "em"),
          (a.height = K(s) + i),
          (a.depth = O(s) + i),
          0 !== i
            ? a.setStyle("width", "calc(100% + " + 2 * i + "em)")
            : a.setStyle("width", "100%"),
          a.setStyle("top", "0"),
          a.setStyle("left", -i, "em"),
          a.setStyle("z-index", "-1"),
          e.backgroundcolor &&
            a.setStyle("background-color", e.backgroundcolor),
          e.notation.box && a.setStyle("border", e.borderStyle),
          e.notation.actuarial &&
            (a.setStyle("border-top", e.borderStyle),
            a.setStyle("border-right", e.borderStyle)),
          e.notation.madruwb &&
            (a.setStyle("border-bottom", e.borderStyle),
            a.setStyle("border-right", e.borderStyle)),
          e.notation.roundedbox &&
            (a.setStyle("border-radius", (K(s) + O(s)) / 2, "em"),
            a.setStyle("border", e.borderStyle)),
          e.notation.circle &&
            (a.setStyle("border-radius", "50%"),
            a.setStyle("border", e.borderStyle)),
          e.notation.top && a.setStyle("border-top", e.borderStyle),
          e.notation.left && a.setStyle("border-left", e.borderStyle),
          e.notation.right && a.setStyle("border-right", e.borderStyle),
          e.notation.bottom && a.setStyle("border-bottom", e.borderStyle);
        let r = "";
        if (
          (e.notation.horizontalstrike &&
            ((r += '<line x1="3%"  y1="50%" x2="97%" y2="50%"'),
            (r += ` stroke-width="${e.strokeWidth}" stroke="${e.strokeColor}"`),
            (r += ' stroke-linecap="round"'),
            e.svgStrokeStyle &&
              (r += ` stroke-dasharray="${e.svgStrokeStyle}"`),
            (r += "/>")),
          e.notation.verticalstrike &&
            ((r += '<line x1="50%"  y1="3%" x2="50%" y2="97%"'),
            (r += ` stroke-width="${e.strokeWidth}" stroke="${e.strokeColor}"`),
            (r += ' stroke-linecap="round"'),
            e.svgStrokeStyle &&
              (r += ` stroke-dasharray="${e.svgStrokeStyle}"`),
            (r += "/>")),
          e.notation.updiagonalstrike &&
            ((r += '<line x1="3%"  y1="97%" x2="97%" y2="3%"'),
            (r += ` stroke-width="${e.strokeWidth}" stroke="${e.strokeColor}"`),
            (r += ' stroke-linecap="round"'),
            e.svgStrokeStyle &&
              (r += ` stroke-dasharray="${e.svgStrokeStyle}"`),
            (r += "/>")),
          e.notation.downdiagonalstrike &&
            ((r += '<line x1="3%"  y1="3%" x2="97%" y2="97%"'),
            (r += ` stroke-width="${e.strokeWidth}" stroke="${e.strokeColor}"`),
            (r += ' stroke-linecap="round"'),
            e.svgStrokeStyle &&
              (r += ` stroke-dasharray="${e.svgStrokeStyle}"`),
            (r += "/>")),
          r)
        ) {
          let t;
          "none" !== e.shadow &&
            (t =
              "auto" === e.shadow
                ? "filter: drop-shadow(0 0 .5px rgba(255, 255, 255, .7)) drop-shadow(1px 1px 2px #333)"
                : "filter: drop-shadow(" + e.shadow + ")"),
            (function (t, e, s) {
              (t.svgOverlay = e), (t.svgStyle = s);
            })(a, r, t);
        }
        const n = I([a, s]);
        return (
          n.setStyle("position", "relative"),
          n.setStyle("display", "inline"),
          (n.height = K(s) + i),
          (n.depth = O(s) + i),
          n.setLeft(i),
          n.setRight(i),
          [n]
        );
      }),
      Ut("box", (t, e) => {
        const s = "number" == typeof e.padding ? e.padding : u,
          i = I(Gt(t, e.body), "", "mord");
        i.setStyle("vertical-align", -O(i), "em"), i.setStyle("height", 0);
        const a = I(i, "", "mord"),
          r = I("", "ML__box");
        r.setStyle("position", "absolute"),
          r.setStyle("height", K(a) + O(a) + 2 * s, "em"),
          0 !== s
            ? r.setStyle("width", "calc(100% + " + 2 * s + "em)")
            : r.setStyle("width", "100%"),
          r.setStyle("top", -s, "em"),
          r.setStyle("left", -s, "em"),
          r.setStyle("z-index", "-1"),
          r.setStyle("box-sizing", "border-box"),
          e.backgroundcolor &&
            r.setStyle("background-color", e.backgroundcolor),
          e.framecolor && r.setStyle("border", f + "em solid " + e.framecolor),
          e.border && r.setStyle("border", e.border),
          a.setStyle("display", "inline-block"),
          a.setStyle("height", K(a) + O(a), "em");
        const n = I([r, a]);
        return (
          n.setStyle("position", "relative"),
          n.setStyle("vertical-align", -s + O(a), "em"),
          (n.height = K(a) + s),
          (n.depth = O(a) + s),
          n.setLeft(s),
          n.setRight(s),
          n.setStyle("height", n.height + n.depth - 2 * s, "em"),
          n.setStyle("top", -s, "em"),
          n.setStyle("display", "inline-block"),
          [n]
        );
      }),
      Ut("mop", (t, e) => {
        const s = t.mathstyle;
        let i,
          a = 0,
          r = 0;
        if (e.isSymbol) {
          const n = s.size === k.displaystyle.size && "\\smallint" !== e.symbol;
          (i = N(
            n ? "Size2-Regular" : "Size1-Regular",
            e.body,
            "op-symbol " + (n ? "large-op" : "small-op"),
            "mop"
          )),
            (a =
              (i.height - i.depth) / 2 -
              s.metrics.axisHeight * s.sizeMultiplier),
            (r = i.italic),
            i.applyStyle({
              color: e.phantom ? "transparent" : e.color,
              backgroundColor: e.phantom ? "transparent" : e.backgroundColor,
              cssId: e.cssId,
              cssClass: e.cssClass,
              letterShapeStyle: t.letterShapeStyle,
            });
        } else
          i = Array.isArray(e.body)
            ? I(Gt(t, e.body), "", "mop")
            : e.makeSpan(t, e.body);
        e.bind(t, i), e.isSymbol && i.setTop(a);
        let n = i;
        if (e.superscript || e.subscript) {
          const o = e.limits || "auto";
          n =
            e.alwaysHandleSupSub ||
            "limits" === o ||
            ("auto" === o && s.size === k.displaystyle.size)
              ? e.attachLimits(t, i, a, r)
              : e.attachSupsub(t, i, "mop");
        }
        return n;
      }),
      Ut("line", (t, e) => {
        const s = t.mathstyle,
          a = Gt(t.cramp(), e.body),
          r = i / s.sizeMultiplier,
          n = I(
            null,
            t.mathstyle.adjustTo(k.textstyle) + " " + e.position + "-line"
          );
        let o;
        if (((n.height = r), (n.maxFontSize = 1), "overline" === e.position))
          o = j(t, [a, 3 * r, n, r]);
        else {
          const e = I(a);
          o = j(t, [r, n, 3 * r, e], "top", K(e));
        }
        return [I(o, e.position, "mord")];
      }),
      Ut("leftright", (t, e) => {
        if (!e.body)
          return e.leftDelim
            ? new Zt("math", "mopen", e.leftDelim).decompose(t)
            : e.rightDelim
            ? new Zt("math", "mclose", e.rightDelim).decompose(t)
            : null;
        const s = t.clone(),
          i = Gt(s, e.body),
          a = s.mathstyle;
        let r = 0,
          n = 0,
          o = [];
        if (
          ((r = K(i) * a.sizeMultiplier),
          (n = O(i) * a.sizeMultiplier),
          e.leftDelim &&
            (o.push(e.bind(t, Nt("mopen", e.leftDelim, r, n, s, "ML__open"))),
            o[o.length - 1].applyStyle(e.getStyle())),
          i)
        ) {
          for (let a = 0; a < i.length; a++)
            if (i[a].delim) {
              const o = i[a].caret,
                l = /ML__selected/.test(i[a].classes);
              (i[a] = e.bind(t, Nt("minner", i[a].delim, r, n, s))),
                (i[a].caret = o),
                i[a].selected(l);
            }
          o = o.concat(i);
        }
        if (e.rightDelim) {
          let i,
            a = e.rightDelim;
          "?" === a &&
            (t.smartFence
              ? ((a = {
                  "(": ")",
                  "\\{": "\\}",
                  "\\[": "\\]",
                  "\\lbrace": "\\rbrace",
                  "\\langle": "\\rangle",
                  "\\lfloor": "\\rfloor",
                  "\\lceil": "\\rceil",
                  "\\vert": "\\vert",
                  "\\lvert": "\\rvert",
                  "\\Vert": "\\Vert",
                  "\\lVert": "\\rVert",
                  "\\lbrack": "\\rbrack",
                  "\\ulcorner": "\\urcorner",
                  "\\llcorner": "\\lrcorner",
                  "\\lgroup": "\\rgroup",
                  "\\lmoustache": "\\rmoustache",
                }[e.leftDelim]),
                (a = a || e.leftDelim),
                (i = "ML__smart-fence__close"))
              : (a = ".")),
            o.push(
              e.bind(t, Nt("mclose", a, r, n, s, (i || "") + " ML__close"))
            ),
            o[o.length - 1].applyStyle(e.getStyle());
        }
        return e.inner ? [I(o, a.cls(), "minner")] : o;
      }),
      Ut("surd", (t, e) => {
        const s = t.mathstyle,
          a = Gt(t.cramp(), e.body),
          r = i / s.sizeMultiplier;
        let n = r;
        s.id < k.textstyle.id && (n = s.metrics.xHeight);
        let o = r + n / 4;
        const l = I(
          It(
            "",
            "\\surd",
            Math.max(2 * n, (K(a) + O(a)) * s.sizeMultiplier) + (o + r),
            !1,
            t
          ),
          "sqrt-sign"
        );
        l.applyStyle(e.getStyle());
        const c = l.height + l.depth - r;
        c > K(a) + O(a) + o && (o = (o + c - (K(a) + O(a))) / 2),
          l.setTop(l.height - K(a) - (o + r));
        const h = I(null, t.mathstyle.adjustTo(k.textstyle) + " sqrt-line");
        h.applyStyle(e.getStyle()), (h.height = r);
        const d = j(t, [a, o, h, r]);
        if (!e.index) return [e.bind(t, I([l, d], "sqrt", "mord"))];
        const m = t.clone({
            mathstyle: k.scriptscriptstyle,
          }),
          p = j(
            t,
            [I(Gt(m, e.index), s.adjustTo(k.scriptscriptstyle))],
            "shift",
            -0.6 * (Math.max(l.height, d.height) - Math.max(l.depth, d.depth))
          );
        return [e.bind(t, I([I(p, "root"), l, d], "sqrt", "mord"))];
      });
    const Qt = [
      [8205, 1],
      [65038, 2],
      [127995, 5],
      [129456, 4],
      [917536, 96],
    ];
    let te;
    const ee = [127462, 127487];

    function se(t) {
      var e;
      return (
        te ||
          ((te = {}),
          Qt.forEach((t) => {
            for (let e = t[0]; e <= t[0] + t[1] - 1; e++) te[e] = !0;
          })),
        null !== (e = te[t]) && void 0 !== e && e
      );
    }

    function ie(t) {
      return t >= ee[0] && t <= ee[1];
    }

    function ae(t) {
      if (/^[\x20-\xFF]*$/.test(t)) return t;
      const e = [],
        s = (function (t) {
          const e = [];
          for (let s = 0; s < t.length; s++) {
            let i = t.charCodeAt(s);
            if (
              (13 === i && 10 === t.charCodeAt(s + 1) && ((i = 10), s++),
              (13 !== i && 12 !== i) || (i = 10),
              0 === i && (i = 65533),
              i >= 55296 && i <= 56319)
            ) {
              const e = t.charCodeAt(s + 1);
              if (e >= 56320 && e <= 57343) {
                const t = i - 55296,
                  a = e - 56320;
                (i = Math.pow(2, 16) + t * Math.pow(2, 10) + a), s++;
              }
            }
            e.push(i);
          }
          return e;
        })(t);
      let i = 0;
      for (; i < s.length; ) {
        const t = s[i++],
          a = s[i];
        if (8205 === a) {
          const t = i - 1;
          for (i += 2; 8205 === s[i]; ) i += 2;
          e.push(String.fromCodePoint(...s.slice(t, i - t + 1)));
        } else if (se(a)) {
          const t = i - 1;
          for (; se(s[i]); ) i += 8205 === s[i] ? 2 : 1;
          e.push(String.fromCodePoint(...s.slice(t, i - t)));
        } else
          ie(t)
            ? ((i += 1), e.push(String.fromCodePoint(...s.slice(i - 2, 2))))
            : e.push(String.fromCodePoint(t));
      }
      return e;
    }
    class re {
      constructor(t, e = "") {
        (this.type = t), (this.value = e);
      }
    }
    class ne {
      constructor(t) {
        (this.s = ae(t)), (this.pos = 0);
      }
      end() {
        return this.pos >= this.s.length;
      }
      get() {
        return this.pos < this.s.length ? this.s[this.pos++] : "";
      }
      peek() {
        return this.s[this.pos];
      }
      scan(t) {
        let e;
        return (
          (e =
            "string" == typeof this.s
              ? t.exec(this.s.slice(this.pos))
              : t.exec(this.s.slice(this.pos).join(""))),
          (null == e ? void 0 : e[0]) ? ((this.pos += e[0].length), e[0]) : null
        );
      }
      isWhiteSpace() {
        return /[ \f\n\r\t\v\xA0\u2028\u2029]/.test(this.s[this.pos]);
      }
      makeToken() {
        if (this.end()) return null;
        if (this.isWhiteSpace()) return this.get(), new re("space");
        let t = null;
        if ("\\" === this.peek()) {
          if ((this.get(), !this.end())) {
            let e = this.scan(/^[a-zA-Z*]+/);
            "bgroup" === e
              ? (t = new re("{"))
              : "egroup" === e
              ? (t = new re("}"))
              : (e || (e = this.get()), (t = new re("command", e)));
          }
        } else if ("{" === this.peek() || "}" === this.peek())
          t = new re(this.get());
        else if ("#" === this.peek()) {
          if ((this.get(), !this.end())) {
            let e = !1,
              s = this.peek();
            if (/[0-9?]/.test(s) && ((e = !0), this.pos + 1 < this.s.length)) {
              const t = this.s[this.pos + 1];
              e = /[^0-9A-Za-z]/.test(t);
            }
            e
              ? ((t = new re("#")),
                (s = this.get()),
                (t.value = s >= "0" && s <= "9" ? parseInt(s) : "?"))
              : (t = new re("literal", "#"));
          }
        } else
          "$" === this.peek()
            ? (this.get(),
              "$" === this.peek()
                ? (this.get(), (t = new re("$$")))
                : (t = new re("$")))
            : (t = new re("literal", this.get()));
        return t;
      }
    }
    const oe = {
        main: ["Main-Regular", "ML__cmr"],
        "main-italic": ["Main-Italic", "ML__cmr ML__it"],
        "main-bold": ["Main-Bold", "ML__cmr ML__bold"],
        "main-bolditalic": ["Main-BoldItalic", "ML__cmr ML_bold ML__it"],
        normal: ["Main-Regular", "ML__cmr"],
        "normal-bold": ["Main-Bold", "ML__mathbf"],
        "normal-italic": ["Math-Italic", "ML__mathit"],
        "normal-bolditalic": ["Math-BoldItalic", "ML__mathbfit"],
        ams: ["AMS-Regular", "ML__ams"],
        "ams-bold": ["AMS-Regular", "ML__ams"],
        "ams-italic": ["AMS-Regular", "ML__ams"],
        "ams-bolditalic": ["AMS-Regular", "ML__ams"],
        "sans-serif": ["SansSerif-Regular", "ML__sans"],
        "sans-serif-bold": ["SansSerif-Regular", "ML__sans ML__bold"],
        "sans-serif-italic": ["SansSerif-Regular", "ML__sans"],
        "sans-serif-bolditalic": ["SansSerif-Regular", "ML__sans"],
        calligraphic: ["Caligraphic-Regular", "ML__cal"],
        "calligraphic-bold": ["Caligraphic-Regular", "ML__cal ML__bold"],
        "calligraphic-italic": ["Caligraphic-Regular", "ML__cal ML__it"],
        "calligraphic-bolditalic": [
          "Caligraphic-Regular",
          "ML__cal ML__bold ML__it",
        ],
        script: ["Script-Regular", "ML__script"],
        "script-bold": ["Script-Regular", "ML__script ML__bold"],
        "script-italic": ["Script-Regular", "ML__script ML__it"],
        "script-bolditalic": ["Script-Regular", "ML__script ML__bold ML__it"],
        fraktur: ["Fraktur-Regular", "ML__frak"],
        "fraktur-bold": ["Fraktur-Regular", "ML__frak"],
        "fraktur-italic": ["Fraktur-Regular", "ML__frak"],
        "fraktur-bolditalic": ["Fraktur-Regular", "ML__frak"],
        monospace: ["Typewriter-Regular", "ML__tt"],
        "monospace-bold": ["Typewriter-Regular", "ML__tt ML__bold"],
        "monospace-italic": ["Typewriter-Regular", "ML__tt ML__it"],
        "monospace-bolditalic": [
          "Typewriter-Regular",
          "ML__tt ML__bold ML__it",
        ],
        "double-struck": ["AMS-Regular", "ML__bb"],
        "double-struck-bold": ["AMS-Regular", "ML__bb"],
        "double-struck-italic": ["AMS-Regular", "ML__bb"],
        "double-struck-bolditalic": ["AMS-Regular", "ML__bb"],
      },
      le = {
        "double-struck": /^[A-Z ]$/,
        script: /^[A-Z ]$/,
        calligraphic: /^[0-9A-Z ]$/,
        fraktur: /^[0-9A-Za-z ]$|^[!"#$%&'()*+,\-./:;=?[]^’‘]$/,
        monospace:
          /^[0-9A-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039b\u039e\u03A0\u03A3\u03A5\u03A8\u03a9]$/,
        "sans-serif":
          /^[0-9A-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039b\u039e\u03A0\u03A3\u03A5\u03A8\u03a9]$/,
      },
      ce = /^[\u03b1-\u03c9]|\u03d1|\u03d5|\u03d6|\u03f1|\u03f5]$/,
      he = [
        /^[a-z]$/,
        /^[A-Z]$/,
        ce,
        /^[\u0393|\u0394|\u0398|\u039b|\u039E|\u03A0|\u03A3|\u03a5|\u03a6|\u03a8|\u03a9]$/,
      ],
      de = {
        iso: ["it", "it", "it", "it"],
        tex: ["it", "it", "it", "up"],
        french: ["it", "up", "up", "up"],
        upright: ["up", "up", "up", "up"],
      };

    function me(t, e, s) {
      return _(e, "fontSize")
        .map((t) => {
          const e = (function (t, e, s) {
              return _(e, "fontSeries")
                .map((t) => {
                  const e = (function (t, e, s) {
                    return _(e, "fontShape")
                      .map((t) => {
                        const e = (function (t, e, s) {
                          let i = !1;
                          return e
                            .map((t) => {
                              let e = "",
                                s = "";
                              return (
                                t.latex
                                  ? (e = t.latex)
                                  : "string" == typeof t.body
                                  ? (e = dt("text", t.body))
                                  : t.symbol &&
                                    (e = t.symbol.replace(
                                      /\\/g,
                                      "\\backslash "
                                    )),
                                !i ||
                                  (e && !/^[a-zA-Z0-9*]/.test(e)) ||
                                  (s = "{}"),
                                (i = /\\[a-zA-Z0-9]+\*?$/.test(e)),
                                s + e
                              );
                            })
                            .join("");
                        })(0, t);
                        return "it" === t[0].fontShape
                          ? "\\textit{" + e + "}"
                          : "sl" === t[0].fontShape
                          ? "\\textsl{" + e + "}"
                          : "sc" === t[0].fontShape
                          ? "\\textsc{" + e + "}"
                          : "n" === t[0].fontShape
                          ? "\\textup{" + e + "}"
                          : t[0].fontShape
                          ? "\\fontshape{" + t[0].fontShape + "}" + e
                          : e;
                      })
                      .join("");
                  })(0, t);
                  return "b" === t[0].fontSeries
                    ? "\\textbf{" + e + "}"
                    : "l" === t[0].fontSeries
                    ? "\\textlf{" + e + "}"
                    : "m" === t[0].fontSeries
                    ? "\\textmd{" + e + "}"
                    : t[0].fontSeries
                    ? "\\fontseries{" + t[0].fontSeries + "}" + e
                    : e;
                })
                .join("");
            })(0, t),
            s =
              {
                size1: "tiny",
                size2: "scriptsize",
                size3: "footnotesize",
                size4: "small",
                size5: "normalsize",
                size6: "large",
                size7: "Large",
                size8: "LARGE",
                size9: "huge",
                size10: "Huge",
              }[t[0].fontSize] || "";
          return s ? "\\" + s + " " + e : e;
        })
        .join("");
    }
    L("math", {
      emitLatexRun: function (t, e, s) {
        let i = t.variant;
        return (
          t.variantStyle &&
            "up" !== t.variantStyle &&
            (i += "-" + t.variantStyle),
          _(e, "color")
            .map((e) => {
              const a = _(e, "variant")
                .map((e) => {
                  let a = e[0].variant;
                  if (
                    (e[0].variantStyle &&
                      "up" !== e[0].variantStyle &&
                      (a += "-" + e[0].variantStyle),
                    e.every((e) => {
                      const s = ft(e.symbol, t.mode, null);
                      if (!s || (!s.variant && !s.variantStyle)) return !1;
                      let i = e.variant;
                      return (
                        e.variantStyle &&
                          "up" !== e.variantStyle &&
                          (i += "-" + e.variantStyle),
                        i === a
                      );
                    }))
                  )
                    return e.map((t) => t.toLatex(s)).join("");
                  let r = "";
                  return (
                    a &&
                      a !== i &&
                      (r = {
                        calligraphic: "\\mathcal{",
                        fraktur: "\\mathfrak{",
                        "double-struck": "\\mathbb{",
                        script: "\\mathscr{",
                        monospace: "\\mathtt{",
                        "sans-serif": "\\mathsf{",
                        normal: "\\mathrm{",
                        "normal-italic": "\\mathit{",
                        "normal-bold": "\\mathbf{",
                        "normal-bolditalic": "\\mathbfit{",
                        ams: "",
                        "ams-italic": "\\mathit{",
                        "ams-bold": "\\mathbf{",
                        "ams-bolditalic": "\\mathbfit{",
                        main: "",
                        "main-italic": "\\mathit{",
                        "main-bold": "\\mathbf{",
                        "main-bolditalic": "\\mathbfit{",
                      }[a]),
                    r + e.map((t) => t.toLatex(s)).join("") + (r ? "}" : "")
                  );
                })
                .join("");
              return !e[0].color || (t && t.color === e[0].color)
                ? a
                : "\\textcolor{" + Lt(e[0].color) + "}{" + a + "}";
            })
            .join("")
        );
      },
      applyStyle: function (t, e) {
        const s =
          "auto" !== e.letterShapeStyle && e.letterShapeStyle
            ? e.letterShapeStyle
            : "tex";
        let i = e.variant || "normal",
          a = e.variantStyle || "";
        "normal" === i &&
          !a &&
          /\u00a3|\u0131|\u0237/.test(t.body) &&
          ((i = "main"), (a = "italic")),
          "normal" !== i ||
            a ||
            1 !== t.body.length ||
            he.forEach((e, i) => {
              e.test(t.body) && "it" === de[s][i] && (a = "italic");
            }),
          "up" === a && (a = "");
        const r = a ? i + "-" + a : i,
          [n, o] = oe[r];
        return le[i] && !le[i].test(t.body)
          ? ((t.body = ct(t.body, i, a)),
            (t.variant = ""),
            (t.variantStyle = ""),
            null)
          : (ce.test(t.body) && (t.classes += " lcGreek"),
            o && (t.classes += " " + o),
            n);
      },
    });
    const pe = {
      roman: "",
      "sans-serif": "ML__sans",
      monospace: "ML__tt",
    };

    function ue(t) {
      let e = !1;
      const s = t
        .map((t) =>
          "literal" === t.type
            ? t.value
            : "{" === t.type
            ? "{"
            : "}" === t.type
            ? "}"
            : "command" === t.type
            ? "\\" + t.value
            : "placeholder" === t.type
            ? "#?"
            : "#" === t.type
            ? ((e = !0), "#" + t.value)
            : "space" === t.type
            ? " "
            : "$" === t.type
            ? "$"
            : "$$" === t.type
            ? "$$"
            : ""
        )
        .join("");
      return e ? "" : s;
    }
    L("text", {
      emitLatexRun: function (t, e, s) {
        const i = (function (t, e, s) {
          return _(e, "color")
            .map((e) => {
              const s = (function (t, e, s) {
                return (function (t, e, s) {
                  return _(e, "fontFamily")
                    .map((t) => {
                      const e = me(0, t),
                        s =
                          {
                            roman: "textrm",
                            monospace: "texttt",
                            "sans-serif": "textsf",
                          }[t[0].fontFamily] || "";
                      return s
                        ? "\\" + s + "{" + e + "}"
                        : t[0].fontFamily
                        ? "\\fontfamily{" + t[0].fontFamily + "}" + e
                        : e;
                    })
                    .join("");
                })(0, e);
              })(0, e);
              return !e[0].color ||
                "none" === e[0].color ||
                (t && t.color === e[0].color)
                ? s
                : "\\textcolor{" + Lt(e[0].color) + "}{" + s + "}";
            })
            .join("");
        })(t, e);
        return e.every((t) => t.fontSeries || t.fontShape || t.fontFamily) &&
          e[0].mode === t.mode
          ? i
          : `\\text{${i}}`;
      },
      applyStyle: function (t, e) {
        const s = e.fontFamily;
        if (
          (pe[s]
            ? (t.classes += " " + pe[s])
            : s && t.setStyle("font-family", s),
          e.fontShape &&
            (t.classes +=
              " " +
              ({
                it: "ML__it",
                sl: "ML__shape_sl",
                sc: "ML__shape_sc",
                ol: "ML__shape_ol",
              }[e.fontShape] || "")),
          e.fontSeries)
        ) {
          const s = e.fontSeries.match(/(.?[lbm])?(.?[cx])?/);
          s &&
            ((t.classes +=
              " " +
              ({
                ul: "ML__series_ul",
                el: "ML__series_el",
                l: "ML__series_l",
                sl: "ML__series_sl",
                m: "",
                sb: "ML__series_sb",
                b: "ML__bold",
                eb: "ML__series_eb",
                ub: "ML__series_ub",
              }[s[1] || ""] || "")),
            (t.classes +=
              " " +
              ({
                uc: "ML__series_uc",
                ec: "ML__series_ec",
                c: "ML__series_c",
                sc: "ML__series_sc",
                n: "",
                sx: "ML__series_sx",
                x: "ML__series_x",
                ex: "ML__series_ex",
                ux: "ML__series_ux",
              }[s[2] || ""] || "")));
        }
        return "Main-Regular";
      },
      parse: (t, e) =>
        (function (t, e) {
          let s,
            i = [];
          for (; t.length > 0; ) {
            const a = t.shift();
            if ("space" === a.type)
              (s = new Zt("text", "", " ", e.style)),
                (s.symbol = " "),
                i.push(s);
            else if ("placeholder" === a.type)
              (s = new Zt("text", "placeholder", a.value)),
                (s.captureSelection = !0),
                i.push(s);
            else if ("command" === a.type) {
              let s;
              t.unshift(a),
                ([s, t] = e.parse("text", t, e)),
                (i = [...i, ...s]);
            } else if ("literal" === a.type) {
              const t = ft(a.value, "text", e.macros);
              (s = new Zt(
                "text",
                t ? t.type : "",
                t ? t.value : a.value,
                e.style
              )),
                (s.symbol = a.value),
                (s.latex = nt("text", a.value)),
                i.push(s);
            } else if ("$" === a.type || "$$" === a.type) {
              const s = t.slice(
                0,
                t.findIndex((t) => t.type === a.type)
              );
              t = t.slice(s.length + 1);
              const [r] = e.parse("math", s, e);
              i = [...i, ...r];
            } else "{" === a.type || a.type;
          }
          return [i, t];
        })(t, e)[0],
    });
    class fe {
      constructor(t, e, s) {
        (this.tokens = t),
          (this.index = 0),
          (this.args = e),
          (this.macros = s),
          (this.mathList = []),
          (this.style = {}),
          (this.parseMode = "math"),
          (this.tabularMode = !1),
          (this.smartFence = !1),
          (this.endCount = 0);
      }
      swapMathList(t = []) {
        const e = this.mathList;
        return (this.mathList = t), e;
      }
      swapParseMode(t) {
        const e = this.parseMode;
        return (this.parseMode = t), e;
      }
      end() {
        return (
          this.endCount++,
          this.index >= this.tokens.length || this.endCount > 1e3
        );
      }
      get() {
        return (
          (this.endCount = 0),
          this.index < this.tokens.length ? this.tokens[this.index++] : null
        );
      }
      peek(t = 0) {
        const e = this.index + t;
        return e < this.tokens.length ? this.tokens[e] : null;
      }
      lastMathAtom() {
        const t =
          0 === this.mathList.length
            ? "none"
            : this.mathList[this.mathList.length - 1].type;
        if ("mop" !== t && "msubsup" !== t) {
          const t = new Zt(this.parseMode, "msubsup", "​");
          this.mathList.push(t);
        }
        return this.mathList[this.mathList.length - 1];
      }
      hasToken(t) {
        const e = this.index;
        return e < this.tokens.length && this.tokens[e].type === t;
      }
      hasLiteral(t = "") {
        const e = this.index;
        return (
          e < this.tokens.length &&
          "literal" === this.tokens[e].type &&
          (!t || this.tokens[e].value === t)
        );
      }
      hasLiteralPattern(t) {
        return (
          this.hasToken("literal") && t.test(this.tokens[this.index].value)
        );
      }
      hasCommand(t) {
        const e = this.index;
        return (
          e < this.tokens.length &&
          "command" === this.tokens[e].type &&
          this.tokens[e].value === t
        );
      }
      hasInfixCommand() {
        const t = this.index;
        if (t < this.tokens.length && "command" === this.tokens[t].type) {
          const e = ft(
            "\\" + this.tokens[t].value,
            this.parseMode,
            this.macros
          );
          return null == e ? void 0 : e.infix;
        }
        return !1;
      }
      hasColumnSeparator() {
        const t = this.index;
        return (
          !!(this.tabularMode && t < this.tokens.length) &&
          "literal" === this.tokens[t].type &&
          "&" === this.tokens[t].value
        );
      }
      hasRowSeparator() {
        const t = this.index;
        return (
          !!(this.tabularMode && t < this.tokens.length) &&
          "command" === this.tokens[t].type &&
          ("\\" === this.tokens[t].value || "cr" === this.tokens[t].value)
        );
      }
      parseColumnSeparator() {
        return !!this.hasColumnSeparator() && (this.index++, !0);
      }
      placeholder() {
        if (this.args && "string" == typeof this.args["?"])
          return ge(this.args["?"], this.parseMode, null, this.macros);
        const t = new Zt(this.parseMode, "placeholder", "?", this.style);
        return (t.captureSelection = !0), [t];
      }
      hasImplicitCommand(t) {
        if (this.index < this.tokens.length) {
          const e = this.tokens[this.index];
          if ("command" === e.type) return t.includes(e.value);
        }
        return !1;
      }
      parseRowSeparator() {
        return !!this.hasRowSeparator() && (this.index++, !0);
      }
      parseToken(t) {
        return !!this.hasToken(t) && (this.index++, !0);
      }
      skipWhitespace() {
        let t = !1;
        for (; this.hasToken("space"); ) this.index++, (t = !0);
        return t;
      }
      skipUntilToken(t) {
        for (; !this.end() && !this.parseToken(t); ) this.get();
      }
      parseArguments(t) {
        if (!t || !t.params) return ["", []];
        let e = "";
        const s = [];
        let i = t.infix ? 2 : 0;
        for (; i < t.params.length; ) {
          const a = t.params[i];
          a.optional
            ? s.push(this.scanOptionalArg(a.type))
            : a.type.endsWith("*")
            ? (e = a.type.slice(0, -1))
            : s.push(this.scanArg(a.type) || this.placeholder()),
            (i += 1);
        }
        return [e, s];
      }
      parseCommand(t) {
        return !!this.hasCommand(t) && (this.index++, !0);
      }
      parseLiteral(t) {
        return !!this.hasLiteral(t) && (this.index++, !0);
      }
      parseFiller() {
        let t = !1,
          e = !1;
        do {
          const s = this.skipWhitespace(),
            i = this.parseCommand("relax");
          (t = t || s || i), (e = !s && !i);
        } while (!e);
        return t;
      }
      parseKeyword(t) {
        const e = this.index;
        let s = this.end(),
          i = "";
        for (; !s; ) {
          const e = this.get();
          "literal" === (null == e ? void 0 : e.type) && (i += e.value),
            (s =
              this.end() ||
              "literal" !== (null == e ? void 0 : e.type) ||
              i.length >= t.length);
        }
        const a = t.toUpperCase() === i.toUpperCase();
        return a || (this.index = e), a;
      }
      scanString() {
        let t = "",
          e = this.end();
        for (; !e; ) {
          if (this.hasLiteral("]")) e = !0;
          else if (this.hasToken("literal")) t += this.get().value;
          else if (this.skipWhitespace()) t += " ";
          else if (this.hasToken("command")) {
            const e = this.get();
            "space" === e.value ? (t += " ") : (t += e.value);
          } else e = !0;
          e = e || this.end();
        }
        return t;
      }
      scanLiteralArg() {
        let t = "";
        if (this.hasToken("{")) {
          this.get();
          let e = 1;
          for (; e > 0 && !this.end(); ) {
            const s = this.get();
            "space" === s.type
              ? (t += " ")
              : "#" === s.type
              ? (t += "#" + s.value)
              : "command" === s.type
              ? (t += "\\" + s.value)
              : "}" === s.type
              ? ((e -= 1), e > 0 && (t += "}"))
              : "{" === s.type
              ? ((e += 1), (t += "{"))
              : (t += s.value);
          }
        }
        return t;
      }
      scanColor() {
        return Ct(this.scanString());
      }
      scanNumber(t = !0) {
        const e = this.parseLiteral("-");
        e || this.parseLiteral("+"), this.skipWhitespace(), (t = !!t);
        let s = 10,
          i = /[0-9]/;
        this.parseLiteral("'")
          ? ((s = 8), (i = /[0-7]/), (t = !0))
          : (this.parseLiteral('"') || this.parseLiteral("x")) &&
            ((s = 16), (i = /[0-9A-F]/), (t = !0));
        let a = "";
        for (; this.hasLiteralPattern(i); ) a += this.get().value;
        if (!t && (this.parseLiteral(".") || this.parseLiteral(",")))
          for (a += "."; this.hasLiteralPattern(i); ) a += this.get().value;
        const r = t ? parseInt(a, s) : parseFloat(a);
        return e ? -r : r;
      }
      scanDimen() {
        const t = this.scanNumber(!1);
        let e;
        return (
          this.skipWhitespace(),
          (e = this.parseKeyword("pt")
            ? b(t, "pt")
            : this.parseKeyword("mm")
            ? b(t, "mm")
            : this.parseKeyword("cm")
            ? b(t, "cm")
            : this.parseKeyword("ex")
            ? b(t, "ex")
            : this.parseKeyword("px")
            ? b(t, "px")
            : this.parseKeyword("em")
            ? b(t, "em")
            : this.parseKeyword("bp")
            ? b(t, "bp")
            : this.parseKeyword("dd")
            ? b(t, "dd")
            : this.parseKeyword("pc")
            ? b(t, "pc")
            : this.parseKeyword("in")
            ? b(t, "in")
            : this.parseKeyword("mu")
            ? b(t, "mu")
            : b(t, "pt")),
          e
        );
      }
      scanSkip() {
        const t = this.scanDimen();
        return (
          this.skipWhitespace(),
          this.parseKeyword("plus") && this.scanDimen(),
          this.skipWhitespace(),
          this.parseKeyword("minus") && this.scanDimen(),
          t
        );
      }
      scanColspec() {
        this.skipWhitespace();
        const t = [];
        for (; !this.end() && !this.hasToken("}") && !this.hasLiteral("]"); )
          if (this.hasLiteral()) {
            const e = this.get().value;
            if ("lcr".includes(e))
              t.push({
                align: e,
              });
            else if ("|" === e)
              t.push({
                rule: !0,
              });
            else if ("@" === e) {
              if (this.parseToken("{")) {
                const e = this.swapParseMode("math");
                t.push({
                  gap: this.scanImplicitGroup((t) => "}" === t.type),
                }),
                  this.swapParseMode(e);
              }
              this.parseToken("}");
            }
          }
        return t;
      }
      scanModeSet() {
        let t;
        if (
          (this.parseCommand("(") && (t = ")"),
          !t && this.parseCommand("[") && (t = "]"),
          !t)
        )
          return null;
        const e = this.swapParseMode("math"),
          s = new Zt("math", "group");
        return (
          (s.mathstyle = ")" === t ? "textstyle" : "displaystyle"),
          (s.body = this.scanImplicitGroup(
            (e) => "command" === e.type && e.value === t
          )),
          this.parseCommand(t),
          this.swapParseMode(e),
          s.body && 0 !== s.body.length ? s : null
        );
      }
      scanModeShift() {
        if (!this.hasToken("$") && !this.hasToken("$$")) return null;
        const t = this.get().type,
          e = new Zt("math", "group");
        (e.mathstyle = "$" === t ? "textstyle" : "displaystyle"),
          (e.latexOpen = "textstyle" === e.mathstyle ? "$" : "$$"),
          (e.latexClose = e.latexOpen);
        const s = this.swapParseMode("math");
        return (
          (e.body = this.scanImplicitGroup((e) => e.type === t)),
          this.parseToken(t),
          this.swapParseMode(s),
          e.body && 0 !== e.body.length ? e : null
        );
      }
      scanEnvironment() {
        if (!this.parseCommand("begin")) return null;
        const t = this.scanArg("string"),
          e = ut(t),
          s = [];
        if (null == e ? void 0 : e.params)
          for (const t of e.params)
            if (t.optional) {
              const e = this.scanOptionalArg(t.type);
              s.push(e);
            } else s.push(this.scanArg(t.type));
        const i = this.parseMode,
          a = this.tabularMode,
          r = this.swapMathList([]);
        this.tabularMode = e.tabular;
        const n = [],
          o = [];
        let l = [],
          c = !1;
        do {
          if (
            ((c = this.end()),
            !c &&
              this.parseCommand("end") &&
              (c = this.scanArg("string") === t),
            !c)
          )
            if (this.parseColumnSeparator()) l.push(this.swapMathList([]));
            else if (this.parseRowSeparator()) {
              l.push(this.swapMathList([]));
              let t = 0;
              this.skipWhitespace(),
                this.parseLiteral("[") &&
                  ((t = this.scanDimen()),
                  this.skipWhitespace(),
                  this.parseLiteral("]")),
                o.push(t || 0),
                n.push(l),
                (l = []);
            } else
              this.mathList = this.mathList.concat(
                this.scanImplicitGroup(
                  (t) =>
                    "}" === t.type ||
                    ("literal" === t.type && "&" === t.value) ||
                    ("command" === t.type && /^(end|cr|\\)$/.test(t.value))
                )
              );
        } while (!c);
        l.push(this.swapMathList([])), l.length > 0 && n.push(l);
        const h = this.swapMathList(r);
        if (
          ((this.parseMode = i),
          (this.tabularMode = a),
          !e.tabular && 0 === h.length)
        )
          return null;
        if (e.tabular && 0 === n.length) return null;
        const d = new Zt(
          this.parseMode,
          "array",
          h,
          e.parser ? e.parser(t, s, n) : {}
        );
        return (
          (d.array = n),
          (d.rowGaps = o),
          (d.env = {
            ...e,
          }),
          (d.env.name = t),
          d
        );
      }
      scanImplicitGroup(t) {
        const e = this.style;
        t || (t = (t) => "}" === t.type);
        let s = null,
          i = null,
          a = [],
          r = null;
        const n = this.swapMathList([]);
        for (; !this.end() && !t(this.peek()); )
          if (
            this.hasImplicitCommand([
              "displaystyle",
              "textstyle",
              "scriptstyle",
              "scriptscriptstyle",
            ])
          ) {
            this.parseMode = "math";
            const t = new Zt("math", "mathstyle");
            (t.mathstyle = this.get().value), this.mathList.push(t);
          } else
            this.hasInfixCommand() && !s
              ? ((s = this.get()),
                (i = ft("\\" + s.value, "math", this.macros)),
                i && ([, a] = this.parseArguments(i)),
                (r = this.swapMathList([])))
              : this.parseAtom();
        let o;
        return (
          s
            ? (a.unshift(this.swapMathList(n)),
              a.unshift(r),
              (o = [
                new Zt(
                  this.parseMode,
                  i.type,
                  i.value || s.value,
                  i.parse ? i.parse("\\" + s.value, a) : null
                ),
              ]),
              (o[0].symbol = "\\" + s.value))
            : (o = this.swapMathList(n)),
          (this.style = e),
          o
        );
      }
      scanGroup() {
        if (!this.parseToken("{")) return null;
        const t = new Zt(this.parseMode, "group");
        return (
          (t.body = this.scanImplicitGroup((t) => "}" === t.type)),
          this.parseToken("}"),
          (t.latexOpen = "{"),
          (t.latexClose = "}"),
          t
        );
      }
      scanSmartFence() {
        if ((this.skipWhitespace(), !this.parseLiteral("("))) return null;
        const t = new Zt(this.parseMode, "leftright");
        (t.leftDelim = "("), (t.inner = !1);
        const e = this.swapMathList([]);
        let s = 1;
        for (; !this.end() && 0 !== s; )
          this.hasLiteral("(") && (s += 1),
            this.hasLiteral(")") && (s -= 1),
            0 !== s && this.parseAtom();
        return (
          0 === s && this.parseLiteral(")"),
          (t.rightDelim = 0 === s ? ")" : "?"),
          (t.body = this.swapMathList(e)),
          t
        );
      }
      scanDelim() {
        this.skipWhitespace();
        const t = this.get();
        if (!t) return null;
        let e = ".";
        "command" === t.type
          ? (e = "\\" + t.value)
          : "literal" === t.type && (e = t.value);
        const s = ft(e, "math", this.macros);
        return s &&
          ("mopen" === s.type ||
            "mclose" === s.type ||
            /^(\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
              e
            ))
          ? e
          : null;
      }
      scanLeftRight() {
        if (this.parseCommand("right") || this.parseCommand("mright"))
          return null;
        const t = this.style;
        let e = "right";
        if (!this.parseCommand("left")) {
          if (!this.parseCommand("mleft")) return null;
          e = "mright";
        }
        const s = this.scanDelim();
        if (!s) return null;
        const i = this.swapMathList([]);
        for (; !this.end() && !this.parseCommand(e); ) this.parseAtom();
        this.style = t;
        const a = this.scanDelim(),
          r = new Zt(this.parseMode, "leftright");
        return (
          (r.leftDelim = s),
          (r.rightDelim = a),
          (r.inner = "right" === e),
          (r.body = this.swapMathList(i)),
          r
        );
      }
      parseSupSub() {
        if ("math" !== this.parseMode) return !1;
        let t = !1;
        for (
          ;
          this.hasLiteral("^") || this.hasLiteral("_") || this.hasLiteral("'");

        ) {
          const e = this.hasLiteral("^") ? "superscript" : "subscript";
          if (this.parseLiteral("^") || this.parseLiteral("_")) {
            const s = this.scanArg();
            if (s) {
              const i = this.lastMathAtom();
              (i[e] = i[e] || []), (i[e] = i[e].concat(s)), (t = !0);
            }
          } else if (this.parseLiteral("'")) {
            const e = this.lastMathAtom(),
              s = new Zt(e.mode, "mord", "′");
            (s.symbol = "\\prime"),
              (e.superscript = e.superscript || []),
              e.superscript.push(s),
              (t = !0);
          }
        }
        return t;
      }
      parseLimits() {
        if (this.parseCommand("limits")) {
          const t = this.lastMathAtom();
          return (t.limits = "limits"), (t.explicitLimits = !0), !0;
        }
        if (this.parseCommand("nolimits")) {
          const t = this.lastMathAtom();
          return (t.limits = "nolimits"), (t.explicitLimits = !0), !0;
        }
        return !1;
      }
      scanOptionalArg(t) {
        if (
          ((t = t && "auto" !== t ? t : this.parseMode),
          this.skipWhitespace(),
          !this.parseLiteral("["))
        )
          return null;
        const e = this.parseMode;
        this.parseMode = t;
        const s = this.swapMathList();
        let i;
        for (; !this.end() && !this.parseLiteral("]"); )
          if ("string" === t) i = this.scanString();
          else if ("number" === t) i = this.scanNumber();
          else if ("dimen" === t) i = this.scanDimen();
          else if ("skip" === t) i = this.scanSkip();
          else if ("colspec" === t) i = this.scanColspec();
          else if ("color" === t) i = this.scanColor() || "#ffffff";
          else if ("bbox" === t) {
            const t = this.scanString()
                .toLowerCase()
                .trim()
                .split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/),
              e = {};
            for (const s of t) {
              const t = Ct(s);
              if (t) e.backgroundcolor = t;
              else {
                const t = s.match(/^\s*([0-9.]+)\s*([a-z][a-z])/);
                if (t) e.padding = b(t[1], t[2]);
                else {
                  const t = s.match(/^\s*border\s*:\s*(.*)/);
                  t && (e.border = t[1]);
                }
              }
            }
            i = e;
          } else
            this.mathList = this.mathList.concat(
              this.scanImplicitGroup(
                (t) => "literal" === t.type && "]" === t.value
              )
            );
        this.parseMode = e;
        const a = this.swapMathList(s);
        return i || a;
      }
      scanArg(t) {
        let e;
        if (
          ((t = t && "auto" !== t ? t : this.parseMode),
          this.parseFiller(),
          !this.parseToken("{"))
        ) {
          if ("delim" === t) return this.scanDelim() || ".";
          if (/^(math|text)$/.test(t)) {
            const e = this.parseMode;
            this.parseMode = t;
            const s = this.scanToken();
            return (this.parseMode = e), s;
          }
        }
        if (this.hasToken("#")) {
          const t = this.get();
          return (
            this.skipUntilToken("}"),
            "?" === t.value
              ? this.placeholder()
              : this.args
              ? !this.args[t.value] && this.args["?"]
                ? this.placeholder()
                : "string" == typeof this.args[t.value]
                ? ge(this.args[t.value], this.parseMode, null, this.macros)
                : this.args[t.value] || null
              : null
          );
        }
        const s = this.parseMode;
        this.parseMode = t;
        const i = this.swapMathList([]);
        if ("string" === t) (e = this.scanString()), this.skipUntilToken("}");
        else if ("number" === t)
          (e = this.scanNumber()), this.skipUntilToken("}");
        else if ("dimen" === t)
          (e = this.scanDimen()), this.skipUntilToken("}");
        else if ("skip" === t) (e = this.scanSkip()), this.skipUntilToken("}");
        else if ("colspec" === t)
          (e = this.scanColspec()), this.skipUntilToken("}");
        else if ("color" === t)
          (e = this.scanColor() || "#ffffff"), this.skipUntilToken("}");
        else if ("delim" === t)
          (e = this.scanDelim() || "."), this.skipUntilToken("}");
        else {
          const s = this.index;
          let i = 1;
          do {
            const t = this.get();
            "}" === t.type && (i -= 1), "{" === t.type && (i += 1);
          } while (i > 0 && !this.end());
          if (
            ((e = (function (t, e, s) {
              return C[t] && C[t].parse ? C[t].parse(e, s) : null;
            })(t, this.tokens.slice(s, this.index - 1), {
              args: this.args,
              macros: this.macros,
              smartFence: this.smartFence,
              style: this.style,
              parse: (t, s, i) => {
                const a = new fe(s, i.args, i.macros);
                return (
                  (a.parseMode = t),
                  (a.style = i.style),
                  (e = a.scanImplicitGroup()),
                  [e, s.slice(a.index)]
                );
              },
            })),
            !e)
          ) {
            this.index = s;
            do {
              this.mathList = this.mathList.concat(this.scanImplicitGroup());
            } while (!this.parseToken("}") && !this.end());
          }
        }
        this.parseMode = s;
        const a = this.swapMathList(i);
        return e || a;
      }
      scanToken() {
        const t = this.get();
        if (!t) return null;
        let e = null;
        if ("space" === t.type)
          "text" === this.parseMode &&
            ((e = new Zt("text", "", " ", this.style)), (e.symbol = " "));
        else if ("placeholder" === t.type)
          (e = new Zt(this.parseMode, "placeholder", t.value)),
            (e.captureSelection = !0);
        else if ("command" === t.type) {
          if ("placeholder" === t.value)
            (e = new Zt(
              this.parseMode,
              "placeholder",
              this.scanArg("string"),
              this.style
            )),
              (e.captureSelection = !0);
          else if ("char" === t.value) {
            const t = this.index;
            let s = Math.floor(this.scanNumber(!0));
            (!isFinite(s) || s < 0 || s > 1114111) && (s = 10067),
              (e = new Zt(
                this.parseMode,
                "math" === this.parseMode ? "mord" : "",
                String.fromCodePoint(s)
              )),
              (e.symbol = "\\char"),
              (e.latex = "\\char" + ue(this.tokens.slice(t)));
          } else if ("hskip" === t.value || "kern" === t.value) {
            const s = this.scanSkip();
            isFinite(s) &&
              ((e = new Zt(this.parseMode, "spacing", null, this.style)),
              (e.width = s),
              (e.symbol = "\\" + t.value),
              (e.latex = "\\" + t.value));
          } else if (((e = this.scanMacro(t.value)), !e)) {
            const s = ft("\\" + t.value, this.parseMode, {}),
              i = this.index,
              [a, r] = this.parseArguments(s);
            if (s && !s.infix) {
              if (s.parse) {
                const i = s.parse("\\" + t.value, r);
                if (i.type)
                  e = new Zt(
                    this.parseMode,
                    s.type,
                    a ? this.scanArg(a) : null,
                    {
                      ...this.style,
                      ...i,
                    }
                  );
                else {
                  const t = this.parseMode;
                  if (
                    (i.mode && ((this.parseMode = i.mode), delete i.mode), a)
                  ) {
                    const t = this.style;
                    (this.style = {
                      ...this.style,
                      ...i,
                    }),
                      (e = this.scanArg(a)),
                      (this.style = t);
                  } else
                    this.style = {
                      ...this.style,
                      ...i,
                    };
                  this.parseMode = t;
                }
              } else {
                const i = {
                  ...this.style,
                  variant: s.variant || this.style.variant,
                  variantStyle: s.variantStyle || this.style.variantStyle,
                };
                (e = new Zt(
                  this.parseMode,
                  s.type || "mop",
                  s.value || t.value,
                  i
                )),
                  s.skipBoundary && (e.skipBoundary = !0);
              }
              if (
                e instanceof Zt &&
                !/^(llap|rlap|class|cssId)$/.test(t.value)
              ) {
                e.symbol = "\\" + t.value;
                const s = ue(this.tokens.slice(i, this.index));
                if (
                  (s && (e.latex = e.symbol + s),
                  e.isFunction && this.smartFence)
                ) {
                  const t = this.scanSmartFence();
                  t && (e = [e, t]);
                }
              }
            }
            s ||
              ((e = new Zt("text", "error", "\\" + t.value)),
              (e.symbol = "\\" + t.value),
              (e.latex = "\\" + t.value));
          }
        } else if ("literal" === t.type && "string" == typeof t.value) {
          const s = ft(t.value, this.parseMode, this.macros);
          if (s) {
            const i = {
              ...this.style,
            };
            (e = new Zt(this.parseMode, s.type, s.value || t.value, i)),
              s.isFunction && (e.isFunction = !0);
          } else
            e = new Zt(
              this.parseMode,
              "math" === this.parseMode ? "mord" : "",
              t.value,
              this.style
            );
          if (
            ((e.symbol = t.value),
            (e.latex = ht(this.parseMode, t.value)),
            (null == s ? void 0 : s.isFunction) && this.smartFence)
          ) {
            const t = this.scanSmartFence();
            t && (e = [e, t]);
          }
        } else
          "#" === t.type &&
            ("?" === t.value
              ? (e = this.placeholder())
              : this.args && (e = this.args[t.value] || this.placeholder()));
        return e && !Array.isArray(e) ? [e] : e;
      }
      scanMacro(t) {
        if (!this.macros || !this.macros[t]) return null;
        const e = this.index,
          s = [];
        let i,
          a = 0;
        "string" == typeof this.macros[t]
          ? ((i = this.macros[t]),
            /(^|[^\\])#1/.test(i) && (a = 1),
            /(^|[^\\])#2/.test(i) && (a = 2),
            /(^|[^\\])#3/.test(i) && (a = 3),
            /(^|[^\\])#4/.test(i) && (a = 4),
            /(^|[^\\])#5/.test(i) && (a = 5),
            /(^|[^\\])#6/.test(i) && (a = 6),
            /(^|[^\\])#7/.test(i) && (a = 7),
            /(^|[^\\])#8/.test(i) && (a = 8),
            /(^|[^\\])#9/.test(i) && (a = 9))
          : ((i = this.macros[t].def), (a = this.macros[t].args || 0));
        for (let t = 1; t <= a; t++) s[t] = this.scanLiteralArg();
        this.args &&
          "string" == typeof this.args["?"] &&
          (s["?"] = this.args["?"]);
        const r = new Zt(
          this.parseMode,
          "group",
          ge(i, this.parseMode, s, this.macros)
        );
        return (
          (r.captureSelection = !0),
          (r.symbol = "\\" + t),
          (r.latex = "\\" + t + ue(this.tokens.slice(e))),
          r
        );
      }
      parseAtom() {
        let t =
          this.scanEnvironment() ||
          this.scanModeShift() ||
          this.scanModeSet() ||
          this.scanGroup() ||
          this.scanLeftRight();
        return (
          !(t || (!this.parseSupSub() && !this.parseLimits())) ||
          (t || (t = this.scanToken()),
          Array.isArray(t)
            ? (this.mathList = this.mathList.concat(t))
            : t && this.mathList.push(t),
          null !== t)
        );
      }
    }

    function ge(t, e, s, i, a = !1) {
      let r = [];
      const n = new fe(
        (function (t) {
          const e = [],
            s = t.toString().split(/\r?\n/);
          let i = "",
            a = "";
          for (const t of s) {
            (i += a), (a = " ");
            const e = t.match(/((?:\\%)|[^%])*/);
            e && (i += e[0]);
          }
          const r = new ne(i);
          for (; !r.end(); ) {
            const t = r.makeToken();
            t && e.push(t);
          }
          return e;
        })(t),
        s,
        i
      );
      for (n.parseMode = e || "math", a && (n.smartFence = !0); !n.end(); )
        r = r.concat(n.scanImplicitGroup());
      return r;
    }

    function ye(t, e) {
      let s = "";
      for (const e of t) s += e.relation + ":" + e.offset + "/";
      return e && (s += "#" + e), s;
    }

    function be(t) {
      const e = {
          path: [],
          extent: 0,
        },
        s = t.split("#");
      s.length > 1 && (e.extent = parseInt(s[1]));
      const i = s[0].split("/");
      for (const t of i) {
        const s = t.match(/([^:]*):(.*)/);
        s &&
          e.path.push({
            relation: s[1],
            offset: parseInt(s[2]),
          });
      }
      return e;
    }
    var xe = {
      pathFromString: be,
      pathToString: ye,
      pathDistance: function (t, e) {
        let s = 0,
          i = -1,
          a = !1;
        for (; !a; )
          (i += 1),
            (a = i >= t.length || i >= e.length),
            (a =
              a ||
              !(
                t[i].relation === e[i].relation && t[i].offset === e[i].offset
              ));
        return (
          (s =
            i === t.length && i === e.length
              ? 0
              : i + 1 === t.length &&
                i + 1 === e.length &&
                t[i].relation === e[i].relation
              ? 1
              : 2),
          s
        );
      },
      pathCommonAncestor: function (t, e) {
        const s = [],
          i = Math.min(t.length - 1, e.length - 1);
        let a = 0;
        for (
          ;
          a <= i &&
          t[a].relation === e[a].relation &&
          t[a].offset === e[a].offset;

        )
          s.push(t[a]), (a += 1);
        return s;
      },
      clone: function (t) {
        return be(ye(t)).path;
      },
    };
    const ve = {
        Left: "moveToPreviousChar",
        Right: "moveToNextChar",
        Up: "moveUp",
        Down: "moveDown",
        "Shift-Left": "extendToPreviousChar",
        "Shift-Right": "extendToNextChar",
        "Shift-Up": "extendUp",
        "Shift-Down": "extendDown",
        Backspace: "deletePreviousChar",
        "Alt-Del": "deletePreviousChar",
        Del: "deleteNextChar",
        "Alt-Backspace": "deleteNextChar",
        "Alt-Left": "moveToPreviousWord",
        "Alt-Right": "moveToNextWord",
        "Alt-Shift-Left": "extendToPreviousWord",
        "Alt-Shift-Right": "extendToNextWord",
        "Ctrl-Left": "moveToGroupStart",
        "Ctrl-Right": "moveToGroupEnd",
        "Ctrl-Shift-Left": "extendToGroupStart",
        "Ctrl-Shift-Right": "extendToGroupEnd",
        "math:Spacebar": "moveAfterParent",
        "math:Shift-Spacebar": "moveBeforeParent",
        Home: "moveToMathFieldStart",
        "mac:Meta-Left": "moveToMathFieldStart",
        "Shift-Home": "extendToMathFieldStart",
        "mac:Meta-Shift-Left": "extendToMathFieldStart",
        End: "moveToMathFieldEnd",
        "mac:Meta-Right": "moveToMathFieldEnd",
        "Shift-End": "extendToMathFieldEnd",
        "mac:Meta-Shift-Right": "extendToMathFieldEnd",
        PageUp: "moveToGroupStart",
        PageDown: "moveToGroupEnd",
        "math:Tab": "moveToNextPlaceholder",
        "math:F8": "moveToNextPlaceholder",
        "math:Shift-Tab": "moveToPreviousPlaceholder",
        "math:Shift-F8": "moveToPreviousPlaceholder",
        "text:Tab": "moveToNextPlaceholder",
        "text:F8": "moveToNextPlaceholder",
        "text:Shift-Tab": "moveToPreviousPlaceholder",
        "text:Shift-F8": "moveToPreviousPlaceholder",
        "math:Esc": ["switch-mode", "command"],
        "math:Backslash": ["switch-mode", "command"],
        "math:IntlBackslash": ["switch-mode", "command"],
        "math:Alt-Equal": [
          "apply-style",
          {
            mode: "text",
          },
        ],
        "text:Alt-Equal": [
          "apply-style",
          {
            mode: "math",
          },
        ],
        "command:Esc": [
          "complete",
          {
            discard: !0,
          },
        ],
        "command:Tab": [
          "complete",
          {
            acceptSuggestion: !0,
          },
        ],
        "command:Return": "complete",
        "command:Enter": "complete",
        "command:Shift-Esc": [
          "complete",
          {
            discard: !0,
          },
        ],
        "command:Down": "nextSuggestion",
        "ios:command:Tab": "nextSuggestion",
        "command:Up": "previousSuggestion",
        "!mac:Ctrl-KeyA": "selectAll",
        "mac:Meta-KeyA": "selectAll",
        Cut: "cut",
        Copy: "copy",
        Paste: "paste",
        Clear: "delete",
        "!mac:Ctrl-KeyZ": "undo",
        "mac:Meta-KeyZ": "undo",
        Undo: "undo",
        "!mac:Ctrl-KeyY": "redo",
        "mac:Meta-Shift-KeyY": "redo",
        "!mac:Ctrl-Shift-KeyZ": "redo",
        "mac:Meta-Shift-KeyZ": "redo",
        Redo: "redo",
        EraseEof: "deleteToGroupEnd",
        "mac:Ctrl-KeyB": "moveToPreviousChar",
        "mac:Ctrl-KeyF": "moveToNextChar",
        "mac:Ctrl-KeyP": "moveUp",
        "mac:Ctrl-KeyN": "moveDown",
        "mac:Ctrl-KeyA": "moveToMathFieldStart",
        "mac:Ctrl-KeyE": "moveToMathFieldEnd",
        "mac:Ctrl-Shift-KeyB": "extendToPreviousChar",
        "mac:Ctrl-Shift-KeyF": "extendToNextChar",
        "mac:Ctrl-Shift-KeyP": "extendUp",
        "mac:Ctrl-Shift-KeyN": "extendDown",
        "mac:Ctrl-Shift-KeyA": "extendToMathFieldStart",
        "mac:Ctrl-Shift-KeyE": "extendToMathFieldEnd",
        "mac:Ctrl-Alt-KeyB": "moveToPreviousWord",
        "mac:Ctrl-Alt-KeyF": "moveToNextWord",
        "mac:Ctrl-Shift-Alt-KeyB": "extendToPreviousWord",
        "mac:Ctrl-Shift-Alt-KeyF": "extendToNextWord",
        "mac:Ctrl-KeyH": "deletePreviousChar",
        "mac:Ctrl-KeyD": "deleteNextChar",
        "mac:Ctrl-KeyL": "scrollIntoView",
        "mac:Ctrl-KeyT": "transpose",
        "math:Shift-Quote": ["switch-mode", "text", "", "“"],
        "text:Shift-Quote": ["switch-mode", "math", "”", ""],
        "math:Ctrl-Digit2": ["insert", "$$\\sqrt{#0}$$"],
        "math:Ctrl-Digit5": "moveToOpposite",
        "math:Ctrl-Digit6": "moveToSuperscript",
        "math:Ctrl-Minus": "moveToSubscript",
        "math:Alt-BracketLeft": [
          "insert",
          "$$\\left\\lbrack #0 \\right\\rbrack$$",
        ],
        "math:Alt-Shift-BracketLeft": [
          "insert",
          "$$\\left\\lbrace #0 \\right\\rbrace$$",
        ],
        "math:Return": "addRowAfter",
        "math:Enter": "addRowAfter",
        "math:Ctrl-Comma": "addColumnAfter",
        "math:Alt-KeyQ": ["insert", "$$\\theta$$"],
        "math:Alt-KeyP": ["insert", "$$\\pi$$"],
        "math:Alt-KeyV": ["insert", "$$\\sqrt{#0}$$"],
        "math:Alt-KeyW": ["insert", "$$\\sum_{i=#?}^{#?}$$"],
        "math:Alt-KeyB": ["insert", "$$\\int_{#?}^{#?}$$"],
        "math:Alt-KeyU": ["insert", "$$\\cup$$"],
        "math:Alt-KeyN": ["insert", "$$\\cap$$"],
        "math:Alt-KeyO": ["insert", "$$\\emptyset$$"],
        "math:Alt-KeyD": ["insert", "$$\\differentialD$$"],
        "math:Alt-Shift-KeyO": ["insert", "$$\\varnothing$$"],
        "math:Alt-Shift-KeyD": ["insert", "$$\\partial$$"],
        "math:Alt-Shift-KeyP": ["insert", "$$\\prod_{i=#?}^{#?}$$"],
        "math:Alt-Shift-KeyU": ["insert", "$$\\bigcup$$"],
        "math:Alt-Shift-KeyN": ["insert", "$$\\bigcap$$"],
        "math:Alt-Shift-KeyA": ["insert", "$$\\forall$$"],
        "math:Alt-Shift-KeyE": ["insert", "$$\\exists$$"],
        "math:Alt-Digit5": ["insert", "$\\infty$$"],
        "math:Alt-Digit6": ["insert", "$$\\wedge$$"],
        "math:Alt-Shift-Digit6": ["insert", "$$\\vee$$"],
        "math:Alt-Digit9": ["insert", "("],
        "math:Alt-Digit0": ["insert", ")"],
        "math:Alt-Shift-Backslash": ["insert", "|"],
        "math:Alt-Backslash": ["insert", "$$\\backslash$$"],
        "math:Slash": ["insert", "$$\\frac{#@}{#?}$$"],
        "math:Alt-Slash": ["insert", "$$\\frac{#?}{#@}$$"],
        "math:NumpadDivide": ["insert", "$$\\frac{#@}{#?}$$"],
        "math:Alt-NumpadDivide": ["insert", "\\frac{#?}{#@}"],
        "math:Shift-Backquote": ["insert", "$$\\~$$"],
        "math:Alt-Shift-Slash": ["insert", "$$\\/$$"],
        "Alt-Shift-KeyK": "toggleKeystrokeCaption",
        "Alt-Space": "toggleVirtualKeyboard",
        "mac:Ctrl-Meta-Up": [
          "speak",
          "parent",
          {
            withHighlighting: !1,
          },
        ],
        "!mac:Ctrl-Alt-Up": [
          "speak",
          "parent",
          {
            withHighlighting: !1,
          },
        ],
        "mac:Ctrl-Meta-Down": [
          "speak",
          "all",
          {
            withHighlighting: !1,
          },
        ],
        "!mac:Ctrl-Alt-Down": [
          "speak",
          "all",
          {
            withHighlighting: !1,
          },
        ],
        "mac:Ctrl-Meta-Left": [
          "speak",
          "left",
          {
            withHighlighting: !1,
          },
        ],
        "!mac:Ctrl-Alt-Left": [
          "speak",
          "left",
          {
            withHighlighting: !1,
          },
        ],
        "mac:Ctrl-Meta-Right": [
          "speak",
          "right",
          {
            withHighlighting: !1,
          },
        ],
        "!mac:Ctrl-Alt-Right": [
          "speak",
          "right",
          {
            withHighlighting: !1,
          },
        ],
        "!mac:Ctrl-Alt-Period": [
          "speak",
          "selection",
          {
            withHighlighting: !1,
          },
        ],
        "mac:Ctrl-Meta-Period": [
          "speak",
          "selection",
          {
            withHighlighting: !1,
          },
        ],
        "mac:Ctrl-Meta-Shift-Up": [
          "speak",
          "parent",
          {
            withHighlighting: !0,
          },
        ],
        "!mac:Ctrl-Alt-Shift-Up": [
          "speak",
          "parent",
          {
            withHighlighting: !0,
          },
        ],
        "mac:Ctrl-Meta-Shift-Down": [
          "speak",
          "all",
          {
            withHighlighting: !0,
          },
        ],
        "!mac:Ctrl-Alt-Shift-Down": [
          "speak",
          "all",
          {
            withHighlighting: !0,
          },
        ],
        "mac:Ctrl-Meta-Shift-Left": [
          "speak",
          "left",
          {
            withHighlighting: !0,
          },
        ],
        "!mac:Ctrl-Alt-Shift-Left": [
          "speak",
          "left",
          {
            withHighlighting: !0,
          },
        ],
        "mac:Ctrl-Meta-Shift-Right": [
          "speak",
          "right",
          {
            withHighlighting: !0,
          },
        ],
        "!mac:Ctrl-Alt-Shift-Right": [
          "speak",
          "right",
          {
            withHighlighting: !0,
          },
        ],
        "!mac:Ctrl-Alt-Shift-Period": [
          "speak",
          "selection",
          {
            withHighlighting: !0,
          },
        ],
        "mac:Ctrl-Meta-Shift-Period": [
          "speak",
          "selection",
          {
            withHighlighting: !0,
          },
        ],
      },
      ke = {
        "\\theta": "Alt-KeyQ",
        "\\sqrt": ["Alt-KeyV", "Ctrl-Digit2"],
        "\\pi": "Alt-KeyP",
        "\\prod": "Alt-Shift-KeyP",
        "\\sum": "Alt-KeyW",
        "\\int": "Alt-KeyB",
        "\\cup": "Alt-KeyU",
        "\\cap": "Alt-KeyN",
        "\\bigcup": "Alt-Shift-KeyU",
        "\\bigcap": "Alt-Shift-KeyN",
        "\\forall": "Alt-Shift-KeyA",
        "\\exists": "Alt-Shift-KeyE",
        "\\infty": "Alt-Digit5",
        "\\wedge": "Alt-Digit5",
        "\\vee": "Alt-Shift-Digit6",
        "\\differentialD": "Alt-keyD",
        "\\partial": "Alt-Shift-KeyD",
        "\\frac": "Slash",
        "\\emptyset": "Alt-KeyO",
        "\\varnothing": "Alt-Shift-KeyO",
        "\\~": "~",
      },
      we = {
        "''": {
          mode: "math",
          value: "^{\\doubleprime}",
        },
        alpha: "\\alpha",
        delta: "\\delta",
        Delta: "\\Delta",
        pi: {
          mode: "math",
          value: "\\pi",
        },
        "pi ": {
          mode: "text",
          value: "\\pi ",
        },
        Pi: {
          mode: "math",
          value: "\\Pi",
        },
        theta: "\\theta",
        Theta: "\\Theta",
        ii: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\imaginaryI",
        },
        jj: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\imaginaryJ",
        },
        ee: {
          mode: "math",
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\exponentialE",
        },
        nabla: {
          mode: "math",
          value: "\\nabla",
        },
        grad: {
          mode: "math",
          value: "\\nabla",
        },
        del: {
          mode: "math",
          value: "\\partial",
        },
        "∞": "\\infty",
        oo: {
          mode: "math",
          after:
            "nothing+digit+frac+surd+binop+relop+punct+array+openfence+closefence+space",
          value: "\\infty",
        },
        "∑": {
          mode: "math",
          value: "\\sum",
        },
        sum: {
          mode: "math",
          value: "\\sum_{#?}^{#?}",
        },
        prod: {
          mode: "math",
          value: "\\prod_{#?}^{#?}",
        },
        sqrt: {
          mode: "math",
          value: "\\sqrt",
        },
        "∆": {
          mode: "math",
          value: "\\differentialD",
        },
        "∂": {
          mode: "math",
          value: "\\differentialD",
        },
        sin: {
          mode: "math",
          value: "\\sin",
        },
        cos: {
          mode: "math",
          value: "\\cos",
        },
        tan: {
          mode: "math",
          value: "\\tan",
        },
        tanh: {
          mode: "math",
          value: "\\tanh",
        },
        log: {
          mode: "math",
          value: "\\log",
        },
        ln: {
          mode: "math",
          value: "\\ln",
        },
        exp: {
          mode: "math",
          value: "\\exp",
        },
        lim: {
          mode: "math",
          value: "\\lim_{#?}",
        },
        dx: "dx",
        dy: "dy",
        dt: "dt",
        AA: {
          mode: "math",
          value: "\\forall",
        },
        EE: {
          mode: "math",
          value: "\\exists",
        },
        "!EE": {
          mode: "math",
          value: "\\nexists",
        },
        "&&": {
          mode: "math",
          value: "\\land",
        },
        xin: {
          mode: "math",
          after: "nothing+text+relop+punct+openfence+space",
          value: "x \\in",
        },
        in: {
          mode: "math",
          after: "nothing+letter+closefence",
          value: "\\in",
        },
        "!in": {
          mode: "math",
          value: "\\notin",
        },
        NN: "\\N",
        ZZ: "\\Z",
        QQ: "\\Q",
        RR: "\\R",
        CC: "\\C",
        PP: "\\P",
        xx: "\\times",
        "+-": "\\pm",
        "!=": "\\ne",
        ">=": "\\ge",
        "<=": "\\le",
        "<<": "\\ll",
        ">>": "\\gg",
        "~~": "\\approx",
        "≈": "\\approx",
        "?=": "\\questeq",
        "÷": "\\div",
        "¬": "\\neg",
        ":=": "\\coloneq",
        "::": "\\Colon",
        "(:": "\\langle",
        ":)": "\\rangle",
        beta: "\\beta",
        chi: "\\chi",
        epsilon: "\\epsilon",
        varepsilon: "\\varepsilon",
        eta: {
          mode: "math",
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\eta",
        },
        "eta ": {
          mode: "text",
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\eta ",
        },
        gamma: "\\gamma",
        Gamma: "\\Gamma",
        iota: "\\iota",
        kappa: "\\kappa",
        lambda: "\\lambda",
        Lambda: "\\Lambda",
        mu: {
          mode: "math",
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\mu",
        },
        "mu ": {
          mode: "text",
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\mu ",
        },
        nu: {
          mode: "math",
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\nu",
        },
        "nu ": {
          mode: "text",
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\nu ",
        },
        µ: "\\mu",
        phi: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\phi",
        },
        Phi: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\Phi",
        },
        varphi: "\\varphi",
        psi: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\psi",
        },
        Psi: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\Psi",
        },
        rho: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\rho",
        },
        sigma: "\\sigma",
        Sigma: "\\Sigma",
        tau: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\tau",
        },
        vartheta: "\\vartheta",
        upsilon: "\\upsilon",
        xi: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\xi",
        },
        Xi: {
          after:
            "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
          value: "\\Xi",
        },
        zeta: "\\zeta",
        omega: "\\omega",
        Omega: "\\Omega",
        Ω: "\\omega",
        forall: "\\forall",
        exists: {
          mode: "math",
          value: "\\exists",
        },
        "!exists": {
          mode: "math",
          value: "\\nexists",
        },
        ":.": {
          mode: "math",
          value: "\\therefore",
        },
        liminf: "\\operatorname*{lim~inf}_{#?}",
        limsup: "\\operatorname*{lim~sup}_{#?}",
        argmin: "\\operatorname*{arg~min}_{#?}",
        argmax: "\\operatorname*{arg~max}_{#?}",
        det: "\\det",
        mod: {
          mode: "math",
          value: "\\mod",
        },
        max: {
          mode: "math",
          value: "\\max",
        },
        min: {
          mode: "math",
          value: "\\min",
        },
        erf: "\\operatorname{erf}",
        erfc: "\\operatorname{erfc}",
        bessel: {
          mode: "math",
          value: "\\operatorname{bessel}",
        },
        mean: {
          mode: "math",
          value: "\\operatorname{mean}",
        },
        median: {
          mode: "math",
          value: "\\operatorname{median}",
        },
        fft: {
          mode: "math",
          value: "\\operatorname{fft}",
        },
        lcm: {
          mode: "math",
          value: "\\operatorname{lcm}",
        },
        gcd: {
          mode: "math",
          value: "\\operatorname{gcd}",
        },
        randomReal: "\\operatorname{randomReal}",
        randomInteger: "\\operatorname{randomInteger}",
        Re: {
          mode: "math",
          value: "\\operatorname{Re}",
        },
        Im: {
          mode: "math",
          value: "\\operatorname{Im}",
        },
        mm: {
          mode: "math",
          after: "nothing+digit",
          value: "\\operatorname{mm}",
        },
        cm: {
          mode: "math",
          after: "nothing+digit",
          value: "\\operatorname{cm}",
        },
        km: {
          mode: "math",
          after: "nothing+digit",
          value: "\\operatorname{km}",
        },
        kg: {
          mode: "math",
          after: "nothing+digit",
          value: "\\operatorname{kg}",
        },
        "...": "\\ldots",
        "+...": "+\\cdots",
        "-...": "-\\cdots",
        "->...": "\\to\\cdots",
        "->": "\\to",
        "|->": "\\mapsto",
        "--\x3e": "\\longrightarrow",
        "<--": "\\longleftarrow",
        "=>": "\\Rightarrow",
        "==>": "\\Longrightarrow",
        "<=>": "\\Leftrightarrow",
        "<->": "\\leftrightarrow",
        "(.)": "\\odot",
        "(+)": "\\oplus",
        "(/)": "\\oslash",
        "(*)": "\\otimes",
        "(-)": "\\ominus",
        "||": "\\Vert",
        "{": "\\{",
        "}": "\\}",
        "*": "\\cdot",
      };

    function Se(t, e, s) {
      if (!s) return s;
      if ("string" == typeof s) return s;
      if ("string" == typeof s.mode && s.mode !== t) return null;
      if (!e) return s ? s.value : void 0;
      let i = !1,
        a = !1,
        r = !1,
        n = !1,
        o = !1,
        l = !1,
        c = !1,
        h = !1,
        d = !1,
        m = !1,
        p = !1,
        u = !1,
        f = !1,
        g = !1,
        y = e[e.length - 1],
        b = e.length - 1;
      for (; y && /msubsup|placeholder/.test(y.type); ) (b -= 1), (y = e[b]);
      return (
        (i = !y || "first" === y.type),
        y &&
          ((f = "text" === y.mode),
          (a = !f && "mord" === y.type && st.test(y.body)),
          (r = !f && "mord" === y.type && /[0-9]+$/.test(y.body)),
          (n = !f && y.isFunction),
          (o = "genfrac" === y.type),
          (l = "surd" === y.type),
          (c = "mbin" === y.type),
          (h = "mrel" === y.type),
          (d = "mpunct" === y.type || "minner" === y.type),
          (m = y.array),
          (p = "mopen" === y.type),
          (u = "mclose" === y.type || "leftright" === y.type),
          (g = "space" === y.type)),
        void 0 !== s.after
          ? (/nothing/.test(s.after) && i) ||
            (/letter/.test(s.after) && a) ||
            (/digit/.test(s.after) && r) ||
            (/function/.test(s.after) && n) ||
            (/frac/.test(s.after) && o) ||
            (/surd/.test(s.after) && l) ||
            (/binop/.test(s.after) && c) ||
            (/relop/.test(s.after) && h) ||
            (/punct/.test(s.after) && d) ||
            (/array/.test(s.after) && m) ||
            (/openfence/.test(s.after) && p) ||
            (/closefence/.test(s.after) && u) ||
            (/text/.test(s.after) && f) ||
            (/space/.test(s.after) && g)
            ? s.value
            : null
          : s.value
      );
    }

    function Me(t) {
      let e = "other";
      return (
        navigator &&
          navigator.platform &&
          navigator.userAgent &&
          (/^(mac)/i.test(navigator.platform)
            ? (e = "mac")
            : /^(win)/i.test(navigator.platform)
            ? (e = "win")
            : /(android)/i.test(navigator.userAgent)
            ? (e = "android")
            : /(iphone)/i.test(navigator.userAgent) ||
              /(ipod)/i.test(navigator.userAgent) ||
              /(ipad)/i.test(navigator.userAgent)
            ? (e = "ios")
            : /\bCrOS\b/i.test(navigator.userAgent) && (e = "chromeos")),
        e === t ? t : "!" + t
      );
    }

    function Ae(t) {
      let e = t;
      return (
        Array.isArray(e) &&
          e.length > 0 &&
          (e = e[0] + "(" + e.slice(1).join("") + ")"),
        e
      );
    }

    function _e(t, e) {
      let s = "";
      Array.isArray(t) || (t = [t]);
      for (const i of t) {
        let t;
        const a = i.match(/(^[^:]*):/),
          r = a ? a[1] : "";
        if (
          r === Me("mac") ||
          r === Me("win") ||
          r === Me("ios") ||
          r === Me("android") ||
          r === Me("chromeos") ||
          r === Me("other")
        ) {
          const e = i.match(/:([^:]*)$/);
          t = e ? e[1] : i;
        } else if (
          ![
            "mac",
            "!mac",
            "win",
            "!win",
            "ios",
            "!ios",
            "android",
            "!android",
            "chromeos",
            "!chromeos",
            "other",
            "!other",
          ].includes(r)
        ) {
          const e = i.match(/:([^:]*)$/);
          t = e ? e[1] : i;
        }
        if (t) {
          const i = "mac" === Me("mac") || "ios" === Me("ios"),
            a = t.length > 1 ? t.split("-") : [t];
          let r = "";
          for (const t of a)
            !i &&
              r.length > 0 &&
              (r += '<span class="ML__shortcut-join">+</span>'),
              "Key" === t.substr(0, 3)
                ? (r += t.substr(3, 1))
                : "Digit" === t.substr(0, 5)
                ? (r += t.substr(5, 1))
                : (r +=
                    {
                      Meta: i ? "⌘" : "command",
                      Shift: i ? "⇧" : "shift",
                      Alt: i ? "⌥" : "alt",
                      Ctrl: i ? "⌃" : "control",
                      "\n": i ? "⏎" : "return",
                      Return: i ? "⏎" : "return",
                      Enter: i ? "⌤" : "enter",
                      Tab: i ? "⇥" : "tab",
                      Esc: "esc",
                      Backspace: i ? "⌫" : "backspace",
                      Del: i ? "⌦" : "del",
                      PageUp: i ? "⇞" : "page up",
                      PageDown: i ? "⇟" : "page down",
                      Home: i ? "⤒" : "home",
                      End: i ? "⤓" : "end",
                      Spacebar: "space",
                      Semicolon: ";",
                      Period: ".",
                      Comma: ",",
                      Minus: "-",
                      Equal: "=",
                      Quote: "'",
                      BracketLeft: "[",
                      BracketRight: "]",
                      Backslash: "\\",
                      IntlBackslash: "\\",
                      Backquote: "`",
                      Slash: "/",
                      NumpadMultiply: "* &#128290;",
                      NumpadDivide: "/ &#128290;",
                      NumpadSubtract: "- &#128290;",
                      NumpadAdd: "+ &#128290;",
                      NumpadDecimal: ". &#128290;",
                      NumpadComma: ", &#128290;",
                      Help: "help",
                      Left: "⇠",
                      Up: "⇡",
                      Right: "⇢",
                      Down: "⇣",
                    }[t] || t);
          s.length > 0 && (s += e || " or "), (s += r);
        }
      }
      return s;
    }
    var Ce = {
      KEYBOARD_SHORTCUTS: ve,
      INLINE_SHORTCUTS: we,
      stringify: _e,
      startsWithString: function (t, e) {
        const s = [];
        for (let i = 0; i <= t.length - 1; i++) {
          const a = t.substring(i);
          (e && e.overrideDefaultInlineShortcuts) ||
            Object.keys(we).forEach((t) => {
              t.startsWith(a) && !s.includes(t) && s.push(t);
            });
          const r = e && e.inlineShortcuts ? e.inlineShortcuts : null;
          r &&
            Object.keys(r).forEach((t) => {
              t.startsWith(a) && s.push(t);
            });
        }
        return s;
      },
      forString: function (t, e, s, i) {
        let a = "";
        (i && i.overrideDefaultInlineShortcuts) || (a = Se(t, e, we[s]));
        const r = i && i.inlineShortcuts ? i.inlineShortcuts : null;
        let n;
        return r && (n = Se(t, e, r[s])), n || a;
      },
      selectorForKeystroke: function (t, e) {
        for (const s of [
          Me("mac") + ":" + t + ":" + e,
          Me("win") + ":" + t + ":" + e,
          Me("ios") + ":" + t + ":" + e,
          Me("android") + ":" + t + ":" + e,
          Me("chromeos") + ":" + t + ":" + e,
          Me("other") + ":" + t + ":" + e,
          Me("mac") + ":" + e,
          Me("win") + ":" + e,
          Me("ios") + ":" + e,
          Me("android") + ":" + e,
          Me("chromeos") + ":" + e,
          t + ":" + e,
          e,
        ])
          if (ve[s]) return ve[s];
        return "";
      },
      forCommand: function (t) {
        let e = [];
        if ("string" == typeof t) {
          const s = ke[t];
          Array.isArray(s) ? (e = s.slice()) : s && e.push(s);
        }
        t = Ae(t);
        const s = new RegExp(
          "^" +
            t
              .replace("\\", "\\\\")
              .replace("|", "\\|")
              .replace("*", "\\*")
              .replace("$", "\\$")
              .replace("^", "\\^") +
            "([^*a-zA-Z]|$)"
        );
        return (
          Object.keys(ve).forEach((t) => {
            if (s.test(Ae(ve[t]))) {
              const s = t.match(/:([^:]*)$/);
              s && e.push(s[1]);
            }
          }),
          _e(e)
        );
      },
    };

    function Le(t) {
      return 0 === t.length || (1 === t.length && "first" === t[0].type);
    }

    function ze(t, e) {
      (this.root = Xt()),
        (this.path = [
          {
            relation: "body",
            offset: 0,
          },
        ]),
        (this.extent = 0),
        (this.config = t
          ? {
              ...t,
            }
          : {}),
        (this.target = e),
        (this.suppressChangeNotifications = !1);
    }

    function $e(t) {
      const e = Object.assign(new ze(t.config, t.target), t);
      return (e.path = xe.clone(t.path)), e;
    }

    function Te(t, e) {
      let s = 0;
      for (let i = 0; i < e.row; i++)
        for (let e = 0; e < t[i].length; e++) s += 1;
      return (s += e.col), s;
    }

    function De(t, e) {
      if ("string" == typeof e) {
        const t = e.match(/cell([0-9]*)$/);
        t && (e = parseInt(t[1]));
      }
      const s = {
        row: 0,
        col: 0,
      };
      for (; e > 0; )
        (s.col += 1),
          (!t[s.row] || s.col >= t[s.row].length) &&
            ((s.col = 0), (s.row += 1)),
          (e -= 1);
      return s;
    }

    function Fe(t, e) {
      let s;
      return (
        "object" != typeof e && (e = De(t, e)),
        Array.isArray(t[e.row]) && (s = t[e.row][e.col] || null),
        !s || (0 !== s.length && "first" === s[0].type) || s.unshift(We()),
        s
      );
    }

    function qe(t) {
      let e = 0,
        s = 0,
        i = 1;
      for (const e of t) (s += 1), e.length > i && (i = e.length);
      return (e = s * i), e;
    }

    function Ee(t, e, s) {
      if (!t) return [];
      e || (e = ",");
      let i,
        a = [];
      for (let r of t)
        r && r.length > 0 && "first" === r[0].type && (r = r.slice(1)),
          r &&
            r.length > 0 &&
            (i ? a.push(i) : (i = new Zt("math", "mpunct", e, s)),
            (a = a.concat(r)));
      return a;
    }

    function Pe(t, e, s) {
      const i = {
        ...e,
      };
      if (((i.row += s), i.row < 0)) {
        if (((i.col += s), (i.row = t.length - 1), i.col < 0)) return null;
        for (; i.row >= 0 && !Fe(t, i); ) i.row -= 1;
        if (i.row < 0) return null;
      } else if (i.row >= t.length) {
        for (i.col += s, i.row = 0; i.row < t.length && !Fe(t, i); ) i.row += 1;
        if (i.row > t.length - 1) return null;
      }
      return i;
    }

    function Be(t) {
      return (
        !!t &&
        (("mord" === t.type && /[0-9.]/.test(t.body)) ||
          ("mpunct" === t.type && "," === t.body))
      );
    }

    function Ke(t, e) {
      if (!t) return !1;
      if (Array.isArray(t)) {
        for (const s of t) if (Ke(s, e)) return !0;
      } else {
        if (t === e) return !0;
        if (
          [
            "body",
            "numer",
            "denom",
            "index",
            "subscript",
            "superscript",
            "underscript",
            "overscript",
          ].some(function (s) {
            return s === e || Ke(t[s], e);
          })
        )
          return !0;
        if (t.array)
          for (let s = qe(t.array); s >= 0; s--)
            if (Ke(Fe(t.array, s), e)) return !0;
      }
      return !1;
    }

    function Oe(t) {
      if (t)
        return (
          1 === t.length &&
            "leftright" === t[0].type &&
            "(" === t[0].leftDelim &&
            (t = t[0].body),
          t
        );
    }

    function Re(t, e) {
      if (!t) return ["latex", ""];
      if (t.length <= 1) return ["latex", t];
      if (!e || "ASCIIMath" !== e.format) {
        const e = t.trim();
        if (
          (e.startsWith("$$") && e.endsWith("$$")) ||
          (e.startsWith("\\[") && e.endsWith("\\]")) ||
          (e.startsWith("\\(") && e.endsWith("\\)"))
        )
          return ["latex", e.substring(2, e.length - 2)];
        if (e.startsWith("$") && e.endsWith("$"))
          return ["latex", e.substring(1, e.length - 1)];
        if (((t = t.replace(/\\\\([^\s\n])/g, "\\$1")), /\\/.test(t)))
          return ["latex", t];
      }
      return (
        (t = (t = (t = (t = (t = (t = t.replace(/\u2061/gu, "")).replace(
          /\u3016/gu,
          "{"
        )).replace(/\u3017/gu, "}")).replace(
          /([^\\])sinx/g,
          "$1\\sin x"
        )).replace(/([^\\])cosx/g, "$1\\cos x ")).replace(/\u2013/g, "-")),
        [e.format || "asciimath", Ie(t, e)]
      );
    }

    function Ie(t, e) {
      if (!t) return "";
      let s,
        i = !1;
      if (
        (i ||
          ("^" !== t[0] && "_" !== t[0]) ||
          ((s = Ne(t.substr(1), {
            ...e,
            noWrap: !0,
          })),
          (t = t[0] + "{" + s.match + "}"),
          (t += Ie(s.rest, e)),
          (i = !0)),
        i ||
          ((s = t.match(/^(sqrt|\u221a)(.*)/)),
          s &&
            ((s = Ne(s[2], {
              ...e,
              noWrap: !0,
            })),
            (t = "\\sqrt{" + s.match + "}"),
            (t += Ie(s.rest, e)),
            (i = !0))),
        i ||
          ((s = t.match(/^(\\cbrt|\u221b)(.*)/)),
          s &&
            ((s = Ne(s[2], {
              ...e,
              noWrap: !0,
            })),
            (t = "\\sqrt[3]{" + s.match + "}"),
            (t += Ie(s.rest, e)),
            (i = !0))),
        i ||
          ((s = t.match(/^abs(.*)/)),
          s &&
            ((s = Ne(s[1], {
              ...e,
              noWrap: !0,
            })),
            (t = "\\left|" + s.match + "\\right|"),
            (t += Ie(s.rest, e)),
            (i = !0))),
        i ||
          ((s = t.match(/^["”“](.*?)["”“](.*)/)),
          s && ((t = "\\text{" + s[1] + "}"), (t += Ie(s[2], e)), (i = !0))),
        i ||
          ((s = t.match(/^([^a-zA-Z({[_^\\\s"]+)(.*)/)),
          s && ((t = He(s[1], e)), (t += Ie(s[2], e)), (i = !0))),
        !i &&
          /^(f|g|h)[^a-zA-Z]/.test(t) &&
          ((s = Ne(t.substring(1), {
            ...e,
            noWrap: !0,
          })),
          (t =
            "(" === t[1]
              ? t[0] + "\\mleft(" + s.match + "\\mright)"
              : t[0] + s.match),
          (t += Ie(s.rest, e)),
          (i = !0)),
        i ||
          ((s = t.match(/^([a-zA-Z]+)(.*)/)),
          s && ((t = He(s[1], e)), (t += Ie(s[2], e)), (i = !0))),
        !i)
      )
        if (
          ((s = Ne(t, {
            ...e,
            noWrap: !0,
          })),
          s.match && "/" === s.rest[0])
        ) {
          const a = Ne(s.rest.substr(1), {
            ...e,
            noWrap: !0,
          });
          a.match &&
            (t = "\\frac{" + s.match + "}{" + a.match + "}" + Ie(a.rest, e)),
            (i = !0);
        } else
          s.match &&
            ((t =
              "(" === t[0]
                ? "\\left(" + s.match + "\\right)" + Ie(s.rest, e)
                : s.match + Ie(s.rest, e)),
            (i = !0));
      return (
        i ||
          ((s = t.match(/^(\s+)(.*)$/)),
          s && ((t = " " + Ie(s[2], e)), (i = !0))),
        t
      );
    }

    function Ne(t, e) {
      let s = "",
        i = (t = t.trim()),
        a = t.charAt(0),
        r = {
          "(": ")",
          "{": "}",
          "[": "]",
        }[a];
      if (r) {
        let n = 1,
          o = 1;
        for (; o < t.length && n > 0; )
          t[o] === a && n++, t[o] === r && n--, o++;
        0 === n
          ? (e.noWrap && "(" === a
              ? (s = Ie(t.substring(1, o - 1), e))
              : ("{" === a && "}" === r && ((a = "\\{"), (r = "\\}")),
                (s =
                  "\\left" + a + Ie(t.substring(1, o - 1), e) + "\\right" + r)),
            (i = t.substring(o)))
          : ((s = t.substring(1, o)), (i = ""));
      } else {
        let a = t.match(/^([a-zA-Z]+)/);
        if (a) {
          let s = Ce.forString("math", null, t, e);
          if (s)
            return (
              (s = s.replace("_{#?}", "")),
              (s = s.replace("^{#?}", "")),
              {
                match: s,
                rest: t.substring(s.length),
              }
            );
        }
        if (((a = t.match(/^([a-zA-Z])/)), a))
          return {
            match: a[1],
            rest: t.substring(1),
          };
        if (((a = t.match(/^(-)?\d+(\.\d*)?/)), a))
          return {
            match: a[0],
            rest: t.substring(a[0].length),
          };
        /^\\(left|right)/.test(t) ||
          ((a = t.match(/^(\\[a-zA-Z]+)/)),
          a && ((i = t.substring(a[1].length)), (s = a[1])));
      }
      return {
        match: s,
        rest: i,
      };
    }

    function He(t, e) {
      let s = Ce.forString("math", null, t, e);
      return (
        s
          ? ((s = s.replace("_{#?}", "")),
            (s = s.replace("^{#?}", "")),
            (s += " "))
          : (s = t),
        s
      );
    }

    function We() {
      return new Zt("", "first");
    }
    (ze.prototype._announce = function (t, e, s) {
      "function" == typeof this.config.onAnnounce &&
        this.config.onAnnounce(this.target, t, e, s);
    }),
      (ze.prototype.filter = function (t, e) {
        e = e < 0 ? -1 : 1;
        const s = [],
          i = new ze();
        (i.path = xe.clone(this.path)),
          (i.extent = this.extent),
          (i.root = this.root),
          e >= 0 ? i.collapseForward() : (i.collapseBackward(), i.move(1));
        const a = i.anchor();
        do {
          t.bind(i)(i.path, i.anchor()) && s.push(i.toString()),
            e >= 0
              ? i.next({
                  iterateAll: !0,
                })
              : i.previous({
                  iterateAll: !0,
                });
        } while (a !== i.anchor());
        return s;
      }),
      (ze.prototype.forEach = function (t) {
        this.root.forEach(t);
      }),
      (ze.prototype.forEachSelected = function (t, e) {
        (e = e || {}).recursive = void 0 !== e.recursive && e.recursive;
        const s = this.siblings(),
          i = this.startOffset() + 1,
          a = this.endOffset() + 1;
        if (e.recursive)
          for (let e = i; e < a; e++)
            s[e] && "first" !== s[e].type && s[e].forEach(t);
        else
          for (let e = i; e < a; e++) s[e] && "first" !== s[e].type && t(s[e]);
      }),
      (ze.prototype.toString = function () {
        return xe.pathToString(this.path, this.extent);
      }),
      (ze.prototype.adjustPlaceholder = function () {
        const t = this.siblings();
        if (t && t.length <= 1) {
          let e;
          const s = this.relation();
          if (
            ("numer" === s
              ? (e = "numerator")
              : "denom" === s
              ? (e = "denominator")
              : "surd" === this.parent().type && "body" === s
              ? (e = "radicand")
              : "overunder" === this.parent().type && "body" === s
              ? (e = "base")
              : ("underscript" !== s && "overscript" !== s) ||
                (e = "annotation"),
            e)
          ) {
            const e = [new Zt("math", "placeholder", "⬚", this.anchorStyle())];
            Array.prototype.splice.apply(t, [1, 0].concat(e));
          }
        }
      }),
      (ze.prototype.selectionWillChange = function () {
        "function" != typeof this.config.onSelectionWillChange ||
          this.suppressChangeNotifications ||
          this.config.onSelectionWillChange(this.target);
      }),
      (ze.prototype.selectionDidChange = function () {
        "function" != typeof this.config.onSelectionDidChange ||
          this.suppressChangeNotifications ||
          this.config.onSelectionDidChange(this.target);
      }),
      (ze.prototype.contentWillChange = function () {
        "function" != typeof this.config.onContentWillChange ||
          this.suppressChangeNotifications ||
          this.config.onContentWillChange(this.target);
      }),
      (ze.prototype.contentDidChange = function () {
        "function" != typeof this.config.onContentDidChange ||
          this.suppressChangeNotifications ||
          this.config.onContentDidChange(this.target);
      }),
      (ze.prototype.setPath = function (t, e) {
        if ("string" == typeof t) t = xe.pathFromString(t);
        else if (Array.isArray(t)) {
          const s = xe.clone(t),
            i = this.path;
          (this.path = s),
            0 === e &&
              "placeholder" === this.anchor().type &&
              ((s[s.length - 1].offset = this.anchorOffset() - 1), (e = 1)),
            (t = {
              path: s,
              extent: e || 0,
            }),
            (this.path = i);
        }
        const s = 0 !== xe.pathDistance(this.path, t.path),
          i = t.extent !== this.extent;
        return (
          (s || i) &&
            (s && this.adjustPlaceholder(),
            this.selectionWillChange(),
            (this.path = xe.clone(t.path)),
            this.siblings().length < this.anchorOffset()
              ? ((this.path = [
                  {
                    relation: "body",
                    offset: 0,
                  },
                ]),
                (this.extent = 0))
              : this.setExtent(t.extent),
            this.selectionDidChange()),
          s || i
        );
      }),
      (ze.prototype.wordBoundary = function (t, e) {
        e = e < 0 ? -1 : 1;
        const s = new ze();
        (s.path = xe.clone(t)), (s.root = this.root);
        let i = 0;
        for (
          ;
          s.sibling(i) &&
          "text" === s.sibling(i).mode &&
          it.test(s.sibling(i).body);

        )
          i += e;
        return (
          s.sibling(i) || (i -= e),
          (s.path[s.path.length - 1].offset += i),
          s.path
        );
      }),
      (ze.prototype.wordBoundaryOffset = function (t, e) {
        e = e < 0 ? -1 : 1;
        const s = this.siblings();
        if (!s[t]) return t;
        if ("text" !== s[t].mode) return t;
        let i;
        if (it.test(s[t].body)) {
          let a,
            r = t;
          do {
            (a = "text" === s[r].mode && it.test(s[r].body)), (r += e);
          } while (s[r] && a);
          i = s[r] ? r - 2 * e : r - e;
        } else if (/\s/.test(s[t].body)) {
          let a = t;
          for (; s[a] && "text" === s[a].mode && /\s/.test(s[a].body); ) a += e;
          if (s[a]) {
            let t = !0;
            do {
              (t = "text" === s[a].mode && !/\s/.test(s[a].body)), (a += e);
            } while (s[a] && t);
            i = s[a] ? a - 2 * e : a - e;
          } else i = a - e;
        } else {
          let a = t;
          for (; s[a] && "text" === s[a].mode && !/\s/.test(s[a].body); )
            a += e;
          i = s[a] ? a : a - e;
          let r = !0;
          for (; s[a] && r; )
            (r = "text" === s[a].mode && /\s/.test(s[a].body)),
              r && (i = a),
              (a += e);
          i = s[a] ? a - 2 * e : a - e;
        }
        return i - (e > 0 ? 0 : 1);
      }),
      (ze.prototype.setRange = function (t, e, s) {
        s = s || {};
        const i = xe.pathDistance(t, e);
        if (0 === i)
          return s.extendToWordBoundary
            ? ((t = this.wordBoundary(t, -1)),
              (e = this.wordBoundary(e, 1)),
              this.setRange(t, e))
            : this.setPath(xe.clone(t), 0);
        if (1 === i) {
          const i = e[e.length - 1].offset - t[t.length - 1].offset;
          return s.extendToWordBoundary
            ? ((t = this.wordBoundary(t, i < 0 ? 1 : -1)),
              (e = this.wordBoundary(e, i < 0 ? -1 : 1)),
              this.setRange(t, e))
            : this.setPath(xe.clone(t), i);
        }
        let a = xe.pathCommonAncestor(t, e);
        const r = a.length;
        if (t.length === r || e.length === r || t[r].relation !== e[r].relation)
          return this.setPath(a, -1);
        a.push(t[r]), (a = xe.clone(a));
        let n = e[r].offset - t[r].offset + 1;
        return (
          n <= 0
            ? e.length > r + 1
              ? ((a[r].relation = e[r].relation),
                (a[r].offset = e[r].offset),
                (a[a.length - 1].offset -= 1),
                (n = 2 - n))
              : ((a[r].relation = e[r].relation),
                (a[r].offset = e[r].offset),
                (n = 1 - n))
            : e.length <= t.length
            ? (a[a.length - 1].offset -= 1)
            : e.length > t.length && (a[r].offset -= 1),
          this.setPath(a, n)
        );
      }),
      (ze.prototype.ancestor = function (t) {
        if (t > this.path.length) return null;
        let e = this.root;
        for (let s = 0; s < this.path.length - t; s++) {
          const t = this.path[s];
          if (e.array) e = Fe(e.array, t.relation)[t.offset];
          else {
            if (!e[t.relation]) return null;
            {
              (0 !== e[t.relation].length &&
                "first" === e[t.relation][0].type) ||
                e[t.relation].unshift(We());
              const s = Math.min(t.offset, e[t.relation].length - 1);
              e = e[t.relation][s];
            }
          }
        }
        return e;
      }),
      (ze.prototype.anchor = function () {
        if (this.parent().array)
          return Fe(this.parent().array, this.relation())[this.anchorOffset()];
        const t = this.siblings();
        return t[Math.min(t.length - 1, this.anchorOffset())];
      }),
      (ze.prototype.parent = function () {
        return this.ancestor(1);
      }),
      (ze.prototype.relation = function () {
        return this.path.length > 0
          ? this.path[this.path.length - 1].relation
          : "";
      }),
      (ze.prototype.anchorOffset = function () {
        return this.path.length > 0
          ? this.path[this.path.length - 1].offset
          : 0;
      }),
      (ze.prototype.focusOffset = function () {
        return this.path.length > 0
          ? this.path[this.path.length - 1].offset + this.extent
          : 0;
      }),
      (ze.prototype.startOffset = function () {
        return Math.min(this.focusOffset(), this.anchorOffset());
      }),
      (ze.prototype.endOffset = function () {
        return Math.max(this.focusOffset(), this.anchorOffset());
      }),
      (ze.prototype.insertFirstAtom = function () {
        this.siblings();
      }),
      (ze.prototype.siblings = function () {
        if (0 === this.path.length) return [];
        let t;
        return (
          this.parent().array
            ? (t = Fe(this.parent().array, this.relation()))
            : ((t = this.parent()[this.relation()] || []),
              "string" == typeof t && (t = [])),
          (0 !== t.length && "first" === t[0].type) || t.unshift(We()),
          t
        );
      }),
      (ze.prototype.sibling = function (t) {
        return this.siblings()[this.startOffset() + t];
      }),
      (ze.prototype.isCollapsed = function () {
        return 0 === this.extent;
      }),
      (ze.prototype.setExtent = function (t) {
        this.extent = t;
      }),
      (ze.prototype.collapseForward = function () {
        return 0 !== this.extent && (this.setSelection(this.endOffset()), !0);
      }),
      (ze.prototype.collapseBackward = function () {
        return 0 !== this.extent && (this.setSelection(this.startOffset()), !0);
      }),
      (ze.prototype.selectGroup_ = function () {
        const t = this.siblings();
        if ("text" === this.anchorMode()) {
          let e = this.startOffset(),
            s = this.endOffset();
          for (; t[e] && "text" === t[e].mode && it.test(t[e].body); ) e -= 1;
          for (; t[s] && "text" === t[s].mode && it.test(t[s].body); ) s += 1;
          if (((s -= 1), e >= s))
            return void this.setSelection(this.endOffset() - 1, 1);
          this.setSelection(e, s - e);
        } else if (
          "mord" === this.sibling(0).type &&
          /[0-9,.]/.test(this.sibling(0).body)
        ) {
          let e = this.startOffset(),
            s = this.endOffset();
          for (; Be(t[e]); ) e -= 1;
          for (; Be(t[s]); ) s += 1;
          (s -= 1), this.setSelection(e, s - e);
        } else this.setSelection(0, "end");
      }),
      (ze.prototype.selectAll_ = function () {
        (this.path = [
          {
            relation: "body",
            offset: 0,
          },
        ]),
          this.setSelection(0, "end");
      }),
      (ze.prototype.deleteAll_ = function () {
        this.selectAll_(), this.delete_();
      }),
      (ze.prototype.contains = function (t) {
        if (this.isCollapsed()) return !1;
        const e = this.siblings(),
          s = this.startOffset(),
          i = this.endOffset();
        for (let a = s; a < i; a++) if (Ke(e[a], t)) return !0;
        return !1;
      }),
      (ze.prototype.getSelectedAtoms = function () {
        if (this.isCollapsed()) return null;
        const t = [],
          e = this.siblings(),
          s = this.startOffset() + 1,
          i = this.endOffset() + 1;
        for (let a = s; a < i; a++)
          e[a] && "first" !== e[a].type && t.push(e[a]);
        return t;
      }),
      (ze.prototype.commandOffsets = function () {
        const t = this.siblings();
        if (t.length <= 1) return null;
        let e = Math.min(this.endOffset(), t.length - 1);
        if ("command" !== t[e].type) return null;
        for (; e > 0 && "command" === t[e].type; ) e -= 1;
        let s = this.startOffset() + 1;
        for (; s <= t.length - 1 && "command" === t[s].type; ) s += 1;
        return s > e
          ? {
              start: e + 1,
              end: s,
            }
          : null;
      }),
      (ze.prototype.extractCommandStringAroundInsertionPoint = function (t) {
        let e = "";
        const s = this.commandOffsets();
        if (s) {
          const i = t ? this.anchorOffset() + 1 : s.end,
            a = this.siblings();
          for (let t = s.start; t < i; t++) e += a[t].body || "";
        }
        return e;
      }),
      (ze.prototype.decorateCommandStringAroundInsertionPoint = function (t) {
        const e = this.commandOffsets();
        if (e) {
          const s = this.siblings();
          for (let i = e.start; i < e.end; i++) s[i].error = t;
        }
      }),
      (ze.prototype.commitCommandStringBeforeInsertionPoint = function () {
        const t = this.commandOffsets();
        if (t) {
          const e = this.siblings(),
            s = this.anchorOffset() + 1;
          for (let i = t.start; i < s; i++) e[i] && (e[i].suggestion = !1);
        }
      }),
      (ze.prototype.spliceCommandStringAroundInsertionPoint = function (t) {
        const e = this.commandOffsets();
        if (e) {
          if ((this.contentWillChange(), t)) {
            Array.prototype.splice.apply(
              this.siblings(),
              [e.start, e.end - e.start].concat(t)
            );
            let s = [];
            for (const e of t)
              s = s.concat(e.filter((t) => "placeholder" === t.type));
            this.setExtent(0),
              (this.path[this.path.length - 1].offset = e.start - 1),
              (0 !== s.length && this.leap(1, !1)) ||
                this.setSelection(e.start + t.length - 1);
          } else
            this.siblings().splice(e.start, e.end - e.start),
              this.setSelection(e.start - 1, 0);
          this.contentDidChange();
        }
      }),
      (ze.prototype.removeCommandString = function () {
        this.contentWillChange();
        const t = this.suppressChangeNotifications;
        (this.suppressChangeNotifications = !0),
          (function t(e) {
            if (e)
              if (Array.isArray(e))
                for (let s = e.length - 1; s >= 0; s--)
                  "command" === e[s].type ? e.splice(s, 1) : t(e[s]);
              else if (
                (t(e.body),
                t(e.superscript),
                t(e.subscript),
                t(e.underscript),
                t(e.overscript),
                t(e.numer),
                t(e.denom),
                t(e.index),
                e.array)
              )
                for (let s = qe(e.array); s >= 0; s--) t(Fe(e.array, s));
          })(this.root.body),
          (this.suppressChangeNotifications = t),
          this.contentDidChange();
      }),
      (ze.prototype.getContentFromSiblings = function (t, e) {
        const s = this.siblings();
        if (Le(s)) return "";
        if (
          ("first" === s[0].type && 0 === t && (t = 1),
          "root" === this.parent().type && 1 === t && e === s.length - 1)
        )
          return this.parent().toLatex();
        let i = "",
          a = t;
        for (; a <= e; ) (i += s[a].toLatex()), a++;
        return i;
      }),
      (ze.prototype.getImplicitArgOffset = function () {
        const t = this.siblings();
        let e = this.startOffset();
        if ("text" === t[e].mode) for (; e >= 1 && "text" === t[e].mode; ) e--;
        else
          for (
            ;
            e >= 1 && /^(mord|surd|msubsup|leftright|mop)$/.test(t[e].type);

          )
            e--;
        return e;
      }),
      (ze.prototype.setSelection = function (t, e, s) {
        (t = t || 0), (e = e || 0);
        const i = this.path[this.path.length - 1].relation;
        s || (s = i);
        const a = this.parent();
        if (!a && "body" !== s) return !1;
        const r = s.startsWith("cell");
        if ((!r && !a[s]) || (r && !a.array)) return !1;
        const n = s !== i;
        this.path[this.path.length - 1].relation = s;
        const o = this.siblings().length;
        this.path[this.path.length - 1].relation = i;
        const l = this.extent;
        "end" === e ? (e = o - t - 1) : "start" === e && (e = -t),
          this.setExtent(e);
        const c = this.extent !== l;
        this.setExtent(l),
          t < 0 && (t = o + t),
          (t = Math.max(0, Math.min(t, o - 1)));
        const h = this.path[this.path.length - 1].offset;
        return (
          (n || h !== t || c) &&
            (n && this.adjustPlaceholder(),
            this.selectionWillChange(),
            (this.path[this.path.length - 1].relation = s),
            (this.path[this.path.length - 1].offset = t),
            this.setExtent(e),
            this.selectionDidChange()),
          !0
        );
      }),
      (ze.prototype.next = function (t) {
        t = t || {};
        const e = {
          body: "numer",
          numer: "denom",
          denom: "index",
          index: "overscript",
          overscript: "underscript",
          underscript: "subscript",
          subscript: "superscript",
        };
        if (this.anchorOffset() === this.siblings().length - 1) {
          this.adjustPlaceholder();
          let s = e[this.relation()];
          const i = this.parent();
          for (; s && !i[s]; ) s = e[s];
          if (s) return void this.setSelection(0, 0, s);
          if (this.parent().array) {
            const t = qe(this.parent().array);
            let e = parseInt(this.relation().match(/cell([0-9]*)$/)[1]) + 1;
            for (; e < t; ) {
              if (
                Fe(this.parent().array, e) &&
                this.setSelection(0, 0, "cell" + e)
              )
                return void this.selectionDidChange();
              e += 1;
            }
          }
          if (1 === this.path.length)
            (this.suppressChangeNotifications ||
              !this.config.onMoveOutOf ||
              this.config.onMoveOutOf(this, "forward")) &&
              (this.path[0].offset = 0);
          else {
            const e = !t.iterateAll && this.parent().skipBoundary;
            this.path.pop(), e && this.next(t);
          }
          return void this.selectionDidChange();
        }
        this.setSelection(this.anchorOffset() + 1);
        const s = this.anchor();
        if (s && !s.captureSelection) {
          let i;
          if (s.array) {
            let t = 0;
            i = "";
            const e = qe(s.array);
            for (; !i && t < e; )
              Fe(s.array, t) && (i = "cell" + t.toString()), (t += 1);
            return (
              this.path.push({
                relation: i,
                offset: 0,
              }),
              void this.setSelection(0, 0, i)
            );
          }
          for (i = "body"; i; ) {
            if (Array.isArray(s[i]))
              return (
                this.path.push({
                  relation: i,
                  offset: 0,
                }),
                this.insertFirstAtom(),
                void (!t.iterateAll && s.skipBoundary && this.next(t))
              );
            i = e[i];
          }
        }
      }),
      (ze.prototype.previous = function (t) {
        const e = {
          numer: "body",
          denom: "numer",
          index: "denom",
          overscript: "index",
          underscript: "overscript",
          subscript: "underscript",
          superscript: "subscript",
        };
        if (
          (!(t = t || {}).iterateAll &&
            1 === this.anchorOffset() &&
            this.parent() &&
            this.parent().skipBoundary &&
            this.setSelection(0),
          this.anchorOffset() < 1)
        ) {
          let t = e[this.relation()];
          for (; t && !this.setSelection(-1, 0, t); ) t = e[t];
          const s = this.parent() ? this.parent().type : "none";
          if (
            ("body" !== t || ("msubsup" !== s && "mop" !== s) || (t = null), t)
          )
            return;
          if (
            (this.adjustPlaceholder(),
            this.selectionWillChange(),
            this.relation().startsWith("cell"))
          ) {
            let t = parseInt(this.relation().match(/cell([0-9]*)$/)[1]) - 1;
            for (; t >= 0; ) {
              if (
                Fe(this.parent().array, t) &&
                this.setSelection(-1, 0, "cell" + t)
              )
                return void this.selectionDidChange();
              t -= 1;
            }
          }
          return (
            1 === this.path.length
              ? (this.suppressChangeNotifications ||
                  !this.config.onMoveOutOf ||
                  this.config.onMoveOutOf.bind(this)(-1)) &&
                (this.path[0].offset = this.root.body.length - 1)
              : (this.path.pop(), this.setSelection(this.anchorOffset() - 1)),
            void this.selectionDidChange()
          );
        }
        const s = this.anchor();
        if (!s.captureSelection) {
          let t;
          if (s.array) {
            t = "";
            const e = qe(s.array);
            let i = e - 1;
            for (; !t && i < e; )
              Fe(s.array, i) && (t = "cell" + i.toString()), (i -= 1);
            return (
              (i += 1),
              this.path.push({
                relation: t,
                offset: Fe(s.array, i).length - 1,
              }),
              void this.setSelection(-1, 0, t)
            );
          }
          for (t = "superscript"; t; ) {
            if (Array.isArray(s[t]))
              return (
                this.path.push({
                  relation: t,
                  offset: s[t].length - 1,
                }),
                void this.setSelection(-1, 0, t)
              );
            t = e[t];
          }
        }
        this.setSelection(this.anchorOffset() - 1),
          !t.iterateAll &&
            this.sibling(0) &&
            this.sibling(0).skipBoundary &&
            this.previous(t);
      }),
      (ze.prototype.move = function (t, e) {
        const s =
          (e = e || {
            extend: !1,
          }).extend || !1;
        if ((this.removeSuggestion(), s)) this.extend(t, e);
        else {
          const e = $e(this);
          if (t > 0)
            for (this.collapseForward() && t--; t > 0; ) this.next(), t--;
          else if (t < 0)
            for (this.collapseBackward() && t++; 0 !== t; )
              this.previous(), t++;
          this._announce("move", e);
        }
      }),
      (ze.prototype.up = function (t) {
        const e =
          (t = t || {
            extend: !1,
          }).extend || !1;
        this.collapseBackward();
        const s = this.relation();
        if ("denom" === s)
          e
            ? (this.selectionWillChange(),
              this.path.pop(),
              (this.path[this.path.length - 1].offset -= 1),
              this.setExtent(1),
              this.selectionDidChange())
            : this.setSelection(this.anchorOffset(), 0, "numer"),
            this._announce("moveUp");
        else if (this.parent().array) {
          let e = De(this.parent().array, s);
          (e = Pe(this.parent().array, e, -1)),
            e && Fe(e)
              ? ((this.path[this.path.length - 1].relation =
                  "cell" + Te(this.parent().array, e)),
                this.setSelection(this.anchorOffset()),
                this._announce("moveUp"))
              : this.move(-1, t);
        } else this._announce("line");
      }),
      (ze.prototype.down = function (t) {
        const e =
          (t = t || {
            extend: !1,
          }).extend || !1;
        this.collapseForward();
        const s = this.relation();
        if ("numer" === s)
          e
            ? (this.selectionWillChange(),
              this.path.pop(),
              (this.path[this.path.length - 1].offset -= 1),
              this.setExtent(1),
              this.selectionDidChange())
            : this.setSelection(this.anchorOffset(), 0, "denom"),
            this._announce("moveDown");
        else if (this.parent().array) {
          let e = De(this.parent().array, s);
          (e = Pe(this.parent().array, e, 1)),
            e && Fe(e)
              ? ((this.path[this.path.length - 1].relation =
                  "cell" + Te(this.parent().array, e)),
                this.setSelection(this.anchorOffset()),
                this._announce("moveDown"))
              : this.move(1, t);
        } else this._announce("line");
      }),
      (ze.prototype.extend = function (t) {
        let e = this.path[this.path.length - 1].offset,
          s = 0;
        const i = $e(this);
        s = this.extent + t;
        const a = e + s;
        if (a < 0 && 0 !== s) {
          if (this.path.length > 1)
            return (
              this.selectionWillChange(),
              this.path.pop(),
              this.setExtent(-1),
              this.selectionDidChange(),
              void this._announce("move", i)
            );
          (e = this.path[this.path.length - 1].offset), (s = this.extent);
        } else if (a >= this.siblings().length) {
          if (this.path.length > 1)
            return (
              this.selectionWillChange(),
              this.path.pop(),
              (this.path[this.path.length - 1].offset -= 1),
              this.setExtent(1),
              this.selectionDidChange(),
              void this._announce("move", i)
            );
          this.isCollapsed() && (e -= 1), (s -= 1);
        }
        this.setSelection(e, s), this._announce("move", i);
      }),
      (ze.prototype.skip = function (t, e) {
        const s =
          (e = e || {
            extend: !1,
          }).extend || !1;
        t = t < 0 ? -1 : 1;
        const i = $e(this),
          a = this.siblings(),
          r = this.focusOffset();
        let n = r + t;
        if (
          (s && (n = Math.min(Math.max(0, n), a.length - 1)),
          n < 0 || n >= a.length)
        )
          this.move(t, e);
        else {
          if (a[n] && "text" === a[n].mode) {
            if (((n = this.wordBoundaryOffset(n, t)), n < 0 && !s))
              return void this.setSelection(0);
            if (n > a.length)
              return this.setSelection(a.length - 1), void this.move(t, e);
          } else {
            const e = a[n] ? a[n].type : "";
            if (("mopen" === e && t > 0) || ("mclose" === e && t < 0)) {
              let s = "mopen" === e ? 1 : -1;
              for (n += t > 0 ? 1 : -1; n >= 0 && n < a.length && 0 !== s; )
                "mopen" === a[n].type
                  ? (s += 1)
                  : "mclose" === a[n].type && (s -= 1),
                  (n += t);
              0 !== s && (n = r + t), t > 0 && (n -= 1);
            } else {
              for (; a[n] && "math" === a[n].mode && a[n].type === e; ) n += t;
              n -= t > 0 ? 1 : 0;
            }
          }
          if (s) {
            const t = this.anchorOffset();
            this.setSelection(t, n - t);
          } else this.setSelection(n);
          this._announce("move", i);
        }
      }),
      (ze.prototype.jump = function (t, e) {
        const s =
          (e = e || {
            extend: !1,
          }).extend || !1;
        t = t < 0 ? -1 : 1;
        const i = this.siblings();
        let a = this.focusOffset();
        t > 0 && (a = Math.min(a + 1, i.length - 1));
        const r = t < 0 ? 0 : i.length - 1;
        s ? this.extend(r - a) : this.move(r - a);
      }),
      (ze.prototype.jumpToMathFieldBoundary = function (t, e) {
        const s =
          (e = e || {
            extend: !1,
          }).extend || !1;
        t = (t = t || 1) < 0 ? -1 : 1;
        const i = $e(this),
          a = [
            {
              relation: "body",
              offset: this.path[0].offset,
            },
          ];
        let r;
        s
          ? t < 0
            ? a[0].offset > 0 && (r = -a[0].offset)
            : a[0].offset < this.siblings().length - 1 &&
              (r = this.siblings().length - 1 - a[0].offset)
          : ((a[0].offset = t < 0 ? 0 : this.root.body.length - 1), (r = 0)),
          this.setPath(a, r),
          this._announce("move", i);
      }),
      (ze.prototype.leap = function (t, e) {
        (t = (t = t || 1) < 0 ? -1 : 1), (e = e || !0);
        const s = this.suppressChangeNotifications;
        this.suppressChangeNotifications = !0;
        const i = $e(this),
          a = this.extent;
        this.move(t), "placeholder" === this.anchor().type && this.move(t);
        const r = this.filter(
          (t, e) =>
            "placeholder" === e.type ||
            (t.length > 1 && 1 === this.siblings().length),
          t
        );
        if (0 === r.length) {
          if ((this.setPath(i, a), e))
            if (this.config.onTabOutOf)
              this.config.onTabOutOf(
                this.target,
                t > 0 ? "forward" : "backward"
              );
            else if (document.activeElement) {
              const e =
                  'a[href]:not([disabled]),\n                    button:not([disabled]),\n                    textarea:not([disabled]),\n                    input[type=text]:not([disabled]),\n                    select:not([disabled]),\n                    [contentEditable="true"],\n                    [tabindex]:not([disabled]):not([tabindex="-1"])',
                s = Array.prototype.filter.call(
                  document.querySelectorAll(e),
                  (t) =>
                    ((t.offsetWidth > 0 || t.offsetHeight > 0) &&
                      !t.contains(document.activeElement)) ||
                    t === document.activeElement
                );
              let i = s.indexOf(document.activeElement) + t;
              i < 0 && (i = s.length - 1),
                i >= s.length && (i = 0),
                s[i].focus();
            }
          return (this.suppressChangeNotifications = s), !1;
        }
        return (
          this.selectionWillChange(),
          this.setPath(r[0]),
          "placeholder" === this.anchor().type && this.setExtent(-1),
          this._announce("move", i),
          this.selectionDidChange(),
          (this.suppressChangeNotifications = s),
          !0
        );
      }),
      (ze.prototype.anchorMode = function () {
        const t = this.isCollapsed() ? this.anchor() : this.sibling(1);
        let e;
        if (t) {
          if ("commandliteral" === t.type || "command" === t.type)
            return "command";
          e = t.mode;
        }
        let s = 1,
          i = this.ancestor(s);
        for (; !e && i; ) i && (e = i.mode), (s += 1), (i = this.ancestor(s));
        return e;
      }),
      (ze.prototype.anchorStyle = function () {
        const t = this.isCollapsed() ? this.anchor() : this.sibling(1);
        let e;
        if (t && "first" !== t.type) {
          if ("commandliteral" === t.type || "command" === t.type) return {};
          e = {
            color: t.color,
            backgroundColor: t.backgroundColor,
            fontFamily: t.fontFamily,
            fontShape: t.fontShape,
            fontSeries: t.fontSeries,
            fontSize: t.fontSize,
          };
        }
        let s = 1,
          i = this.ancestor(s);
        for (; !e && i; )
          i &&
            (e = {
              color: i.color,
              backgroundColor: i.backgroundColor,
              fontFamily: i.fontFamily,
              fontShape: i.fontShape,
              fontSeries: i.fontSeries,
              fontSize: i.fontSize,
            }),
            (s += 1),
            (i = this.ancestor(s));
        return e;
      }),
      (ze.prototype.simplifyParen = function (t) {
        if (t && this.config.removeExtraneousParentheses) {
          for (let e = 0; t[e]; e++)
            if (
              "leftright" === t[e].type &&
              "(" === t[e].leftDelim &&
              Array.isArray(t[e].body)
            ) {
              let s = 0,
                i = 0,
                a = 0;
              for (let r = 0; t[e].body[r]; r++)
                "genfrac" === t[e].body[r].type && (s++, (i = r)),
                  "first" !== t[e].body[r].type && a++;
              0 === a && 1 === s && (t[e] = t[e].body[i]);
            }
          t.forEach((t) => {
            if (
              ("genfrac" === t.type &&
                (this.simplifyParen(t.numer),
                this.simplifyParen(t.denom),
                (t.numer = Oe(t.numer)),
                (t.denom = Oe(t.denom))),
              t.superscript &&
                (this.simplifyParen(t.superscript),
                (t.superscript = Oe(t.superscript))),
              t.subscript &&
                (this.simplifyParen(t.subscript),
                (t.subscript = Oe(t.subscript))),
              t.underscript &&
                (this.simplifyParen(t.underscript),
                (t.underscript = Oe(t.underscript))),
              t.overscript &&
                (this.simplifyParen(t.overscript),
                (t.overscript = Oe(t.overscript))),
              t.index && (this.simplifyParen(t.index), (t.index = Oe(t.index))),
              "surd" === t.type
                ? (this.simplifyParen(t.body), (t.body = Oe(t.body)))
                : t.body && Array.isArray(t.body) && this.simplifyParen(t.body),
              t.array)
            )
              for (let e = qe(t.array); e >= 0; e--)
                this.simplifyParen(Fe(t.array, e));
          });
        }
      }),
      (ze.prototype.invalidateLatex = function () {
        let t = 1,
          e = this.ancestor(t);
        for (; e; ) (e.latex = void 0), (t += 1), (e = this.ancestor(t));
      }),
      (ze.prototype.insert = function (t, e) {
        if ((e = e || {}).smartFence) {
          if (this._insertSmartFence(t, e.style)) return;
        } else {
          const e = this.parent();
          if (
            "leftright" === (null == e ? void 0 : e.type) &&
            "?" === e.rightDelim &&
            this.endOffset() === this.siblings().length - 1 &&
            /^[)}\]|]$/.test(t)
          )
            return (
              this.contentWillChange(),
              (e.rightDelim = t),
              this.move(1),
              void this.contentDidChange()
            );
        }
        const s = this.suppressChangeNotifications;
        e.suppressChangeNotifications &&
          (this.suppressChangeNotifications = !0),
          this.contentWillChange();
        const i = this.suppressChangeNotifications;
        (this.suppressChangeNotifications = !0),
          e.insertionMode || (e.insertionMode = "replaceSelection"),
          e.selectionMode || (e.selectionMode = "placeholder"),
          e.format || (e.format = "auto"),
          (e.macros = e.macros || this.config.macros);
        const a = e.mode || this.anchorMode();
        let r;
        const n = [this.getSelectedAtoms()];
        void 0 !== e.placeholder && (n["?"] = e.placeholder),
          "replaceSelection" !== e.insertionMode || this.isCollapsed()
            ? "replaceAll" === e.insertionMode
              ? ((this.root.body = []),
                (this.root.latex = ""),
                (this.path = [
                  {
                    relation: "body",
                    offset: 0,
                  },
                ]),
                (this.extent = 0))
              : "insertBefore" === e.insertionMode
              ? this.collapseBackward()
              : "insertAfter" === e.insertionMode && this.collapseForward()
            : this.delete_();
        const o = this.siblings(),
          l = this.startOffset();
        if (
          (l + 1 < o.length && o[l + 1] && "placeholder" === o[l + 1].type
            ? this.delete_(1)
            : l > 0 && o[l] && "placeholder" === o[l].type && this.delete_(-1),
          "math" === a && "ASCIIMath" === e.format)
        )
          ([, t] = Re(t, {
            ...this.config,
            format: "ASCIIMath",
          })),
            (r = ge(t, "math", null, e.macros, !1)),
            this.simplifyParen(r);
        else if ("text" !== a && "auto" === e.format)
          if ("command" === a) {
            r = [];
            for (const e of t)
              et.test(e) && r.push(new Zt("command", "command", e));
          } else if ("" === t) r = [new Zt("command", "command", "\\")];
          else {
            if (
              (([e.format, t] = Re(t, this.config)),
              (t = t.replace(/(^|[^\\])#\?/g, "$1\\placeholder{}")),
              n[0])
            )
              t = t.replace(/(^|[^\\])#@/g, "$1#0");
            else if (/(^|[^\\])#@/.test(t)) {
              const e = this.getImplicitArgOffset();
              (t = t.replace(
                /(^|[^\\])#@/g,
                "$1" + this.getContentFromSiblings(e + 1, this.startOffset())
              )),
                this._deleteAtoms(e - this.startOffset());
            } else t = t.replace(/(^|[^\\])#@/g, "$1#?");
            (r = ge(t, a, n, e.macros, e.smartFence)),
              "latex" !== e.format && this.simplifyParen(r);
          }
        else
          "latex" === e.format
            ? (r = ge(t, a, n, e.macros, e.smartFence))
            : ("text" !== a && "text" !== e.format) ||
              (r = ge(
                (t = (t = (t = (t = (t = (t = (t = (t = (t = (t = (t =
                  t.replace(/\\/g, "\\textbackslash ")).replace(
                  /#/g,
                  "\\#"
                )).replace(/\$/g, "\\$")).replace(/%/g, "\\%")).replace(
                  /&/g,
                  "\\&"
                )).replace(/_/g, "\\_")).replace(
                  /{/g,
                  "\\textbraceleft "
                )).replace(/}/g, "\\textbraceright ")).replace(
                  /\^/g,
                  "\\textasciicircum "
                )).replace(/~/g, "\\textasciitilde ")).replace(
                  /£/g,
                  "\\textsterling "
                )),
                "text",
                n,
                e.macros,
                !1
              ));
        this.invalidateLatex(),
          (function t(e, s) {
            e &&
              s &&
              (Array.isArray(e)
                ? e.forEach((e) => t(e, s))
                : "object" == typeof e &&
                  (e.color ||
                    e.backgroundColor ||
                    e.fontFamily ||
                    e.fontShape ||
                    e.fontSeries ||
                    e.fontSize ||
                    (e.applyStyle(s),
                    t(e.body, s),
                    t(e.numer, s),
                    t(e.denom, s),
                    t(e.index, s),
                    t(e.overscript, s),
                    t(e.underscript, s),
                    t(e.subscript, s),
                    t(e.superscript, s))));
          })(r, e.style);
        const c = this.parent();
        if (
          ("latex" !== e.format &&
          this.config.removeExtraneousParentheses &&
          c &&
          "leftright" === c.type &&
          "(" === c.leftDelim &&
          Le(c.body) &&
          r &&
          1 === r.length &&
          "genfrac" === r[0].type
            ? (this.path.pop(), (this.siblings()[this.anchorOffset()] = r[0]))
            : ("latex" !== e.format ||
                1 !== n.length ||
                n[0] ||
                ("root" === c.type && Le(c.body) && (c.latex = t)),
              Array.prototype.splice.apply(
                this.siblings(),
                [this.anchorOffset() + 1, 0].concat(r)
              )),
          this.insertFirstAtom(),
          (this.suppressChangeNotifications = i),
          "placeholder" === e.selectionMode)
        ) {
          let t = [];
          for (const e of r)
            t = t.concat(e.filter((t) => "placeholder" === t.type));
          0 !== t.length && this.leap(1, !1)
            ? this._announce("move")
            : this.setSelection(this.anchorOffset() + r.length);
        } else
          "before" === e.selectionMode ||
            ("after" === e.selectionMode
              ? this.setSelection(this.anchorOffset() + r.length)
              : "item" === e.selectionMode &&
                this.setSelection(this.anchorOffset(), r.length));
        this.contentDidChange(), (this.suppressChangeNotifications = s);
      }),
      (ze.prototype._insertSmartFence = function (t, e) {
        const s = this.parent();
        if (
          "leftright" === s.type &&
          "|" !== s.leftDelim &&
          /\||\\vert|\\Vert|\\mvert|\\mid/.test(t)
        )
          return (
            this.insert("\\,\\middle" + t + "\\, ", {
              mode: "math",
              format: "latex",
              style: e,
            }),
            !0
          );
        ("{" !== t && "\\{" !== t) || (t = "\\lbrace"),
          ("}" !== t && "\\}" !== t) || (t = "\\rbrace"),
          ("[" !== t && "\\[" !== t) || (t = "\\lbrack"),
          ("]" !== t && "\\]" !== t) || (t = "\\rbrack");
        const i = Q[t];
        if (i && ("leftright" !== s.type || "|" !== s.leftDelim)) {
          let s = "";
          const a = this.isCollapsed() || "placeholder" === this.anchor().type;
          (s = this.sibling(0).isFunction
            ? "\\mleft" + t + "\\mright"
            : "\\left" + t + "\\right"),
            (s += a ? "?" : i);
          let r = [];
          return (
            a &&
              (r = this.siblings().splice(
                this.anchorOffset() + 1,
                this.siblings().length
              )),
            this.insert(s, {
              mode: "math",
              format: "latex",
              style: e,
            }),
            a && ((this.sibling(0).body = r), this.move(-1)),
            !0
          );
        }
        let a;
        if (
          (Object.keys(Q).forEach((e) => {
            t === Q[e] && (a = e);
          }),
          a)
        ) {
          if (
            s &&
            "leftright" === s.type &&
            this.endOffset() === this.siblings().length - 1
          )
            return (
              this.contentWillChange(),
              (s.rightDelim = t),
              this.move(1),
              this.contentDidChange(),
              !0
            );
          const i = this.siblings();
          let a;
          for (
            a = this.endOffset();
            a >= 0 && ("leftright" !== i[a].type || "?" !== i[a].rightDelim);
            a--
          );
          if (a >= 0)
            return (
              this.contentWillChange(),
              (i[a].rightDelim = t),
              (i[a].body = i[a].body.concat(
                i.slice(a + 1, this.endOffset() + 1)
              )),
              i.splice(a + 1, this.endOffset() - a),
              this.setSelection(a),
              this.contentDidChange(),
              !0
            );
          if (s && "leftright" === s.type && "?" === s.rightDelim) {
            this.contentWillChange(), (s.rightDelim = t);
            const e = i.slice(this.endOffset() + 1);
            return (
              i.splice(this.endOffset() + 1),
              this.path.pop(),
              Array.prototype.splice.apply(
                this.siblings(),
                [this.endOffset() + 1, 0].concat(e)
              ),
              this.contentDidChange(),
              !0
            );
          }
          const r = this.ancestor(2);
          return r &&
            "leftright" === r.type &&
            "?" === r.rightDelim &&
            this.endOffset() === i.length - 1
            ? (this.move(1), this._insertSmartFence(t, e))
            : (this.insert(t, {
                mode: "math",
                format: "latex",
                style: e,
              }),
              !0);
        }
        return !1;
      }),
      (ze.prototype.positionInsertionPointAfterCommitedCommand = function () {
        const t = this.siblings(),
          e = this.commandOffsets();
        let s = e.start;
        for (; s < e.end && !t[s].suggestion; ) s++;
        this.setSelection(s - 1);
      }),
      (ze.prototype.removeSuggestion = function () {
        const t = this.siblings();
        for (let e = t.length - 1; e >= 0; e--)
          t[e].suggestion && t.splice(e, 1);
      }),
      (ze.prototype.insertSuggestion = function (t, e) {
        this.removeSuggestion();
        const s = [],
          i = t.substr(e);
        for (const t of i) {
          const e = new Zt("command", "command", t);
          (e.suggestion = !0), s.push(e);
        }
        Array.prototype.splice.apply(
          this.siblings(),
          [this.anchorOffset() + 1, 0].concat(s)
        );
      }),
      (ze.prototype._deleteAtoms = function (t) {
        t > 0
          ? this.siblings().splice(this.anchorOffset() + 1, t)
          : (this.siblings().splice(this.anchorOffset() + t + 1, -t),
            this.setSelection(this.anchorOffset() + t));
      }),
      (ze.prototype.delete = function (t) {
        if (0 === (t = t || 0)) this.delete_(0);
        else if (t > 0) for (; t > 0; ) this.delete_(1), t--;
        else for (; t < 0; ) this.delete_(-1), t++;
      }),
      (ze.prototype.delete_ = function (t) {
        this.contentWillChange(), this.selectionWillChange();
        const e = this.suppressChangeNotifications;
        if (
          ((this.suppressChangeNotifications = !0),
          (t = (t = t || 0) < 0 ? -1 : t > 0 ? 1 : t),
          this.removeSuggestion(),
          this.parent().array && t < 0 && 0 === this.startOffset())
        ) {
          const t = this.parent().array;
          if (
            (function (t) {
              const e = {
                col: 0,
                row: 0,
              };
              for (; e.row < t.length && !Fe(t, e); ) e.row += 1;
              return Fe(t, e) ? "cell" + Te(t, e) : "";
            })(t) === this.relation()
          ) {
            const e = (function (t, e, s) {
              e || (e = [";", ","]);
              let i,
                a = [];
              for (const s of t)
                i ? a.push(i) : (i = new Zt("math", "mpunct", e[0], void 0)),
                  (a = a.concat(Ee(s, e[1])));
              return a;
            })(t);
            this.path.pop(),
              this.siblings().splice(this.anchorOffset(), 1, ...e),
              this.setSelection(this.anchorOffset() - 1, e.length);
          } else {
            const e = De(t, this.relation());
            if (0 === e.col) {
              const s = Pe(t, e, -1);
              (s.col = t[s.row].length - 1),
                (this.path[this.path.length - 1].relation = "cell" + Te(t, s));
              const i = t[s.row][s.col].length,
                a = Ee(t[e.row]);
              (t[s.row][s.col] = t[s.row][s.col].concat(a)),
                this.setSelection(i - 1, a.length),
                (function (t, e) {
                  t.splice(e, 1);
                })(t, e.row);
            } else if (
              0 ===
              (function (t, e) {
                let s = 0;
                const i = {
                  col: e,
                  row: 0,
                };
                for (; i.row < t.length; ) {
                  const e = Fe(t, i);
                  if (e && e.length > 0) {
                    let t = e.length;
                    "first" === e[0].type && (t -= 1), t > 0 && (s += 1);
                  }
                  i.row += 1;
                }
                return s;
              })(t, e.col)
            ) {
              !(function (t, e) {
                let s = 0;
                for (; s < t.length; ) t[s][e] && t[s].splice(e, 1), (s += 1);
              })(t, e.col),
                (e.col -= 1),
                (this.path[this.path.length - 1].relation = "cell" + Te(t, e));
              const s = t[e.row][e.col];
              this.setSelection(s.length - 1, 0);
            }
          }
          return (
            (this.suppressChangeNotifications = e),
            this.selectionDidChange(),
            void this.contentDidChange()
          );
        }
        const s = this.siblings();
        if (this.isCollapsed()) {
          const e = this.anchorOffset();
          if (t < 0)
            if (0 !== e) {
              const t = this.sibling(0);
              "leftright" === t.type
                ? ((t.rightDelim = "?"), this.move(-1))
                : !t.captureSelection &&
                  /^(group|array|genfrac|surd|leftright|overlap|overunder|box|mathstyle|sizing)$/.test(
                    t.type
                  )
                ? this.move(-1)
                : (this._announce("delete", null, s.slice(e, e + 1)),
                  s.splice(e, 1),
                  this.setSelection(e - 1));
            } else {
              const t = this.relation();
              if ("superscript" === t || "subscript" === t) {
                const e = this.parent()[t].filter(
                  (t) => "placeholder" !== t.type && "first" !== t.type
                );
                (this.parent()[t] = null),
                  this.path.pop(),
                  Array.prototype.splice.apply(
                    this.siblings(),
                    [this.anchorOffset(), 0].concat(e)
                  ),
                  this.setSelection(this.anchorOffset() - 1),
                  this._announce("deleted: " + t);
              } else if ("denom" === t) {
                const t = this.parent().numer.filter(
                    (t) => "placeholder" !== t.type && "first" !== t.type
                  ),
                  e = this.parent().denom.filter(
                    (t) => "placeholder" !== t.type && "first" !== t.type
                  );
                this.path.pop(),
                  Array.prototype.splice.apply(
                    this.siblings(),
                    [this.anchorOffset(), 1].concat(e)
                  ),
                  Array.prototype.splice.apply(
                    this.siblings(),
                    [this.anchorOffset(), 0].concat(t)
                  ),
                  this.setSelection(this.anchorOffset() + t.length - 1),
                  this._announce("deleted: denominator");
              } else if ("body" === t) {
                const t = this.siblings().filter(
                  (t) => "placeholder" !== t.type
                );
                this.path.length > 1 &&
                  (t.shift(),
                  this.path.pop(),
                  Array.prototype.splice.apply(
                    this.siblings(),
                    [this.anchorOffset(), 1].concat(t)
                  ),
                  this.setSelection(this.anchorOffset() - 1),
                  this._announce("deleted: root"));
              } else this.move(-1), this.delete(-1);
            }
          else if (t > 0)
            if (e !== s.length - 1)
              /^(group|array|genfrac|surd|leftright|overlap|overunder|box|mathstyle|sizing)$/.test(
                this.sibling(1).type
              )
                ? this.move(1)
                : (this._announce("delete", null, s.slice(e + 1, e + 2)),
                  s.splice(e + 1, 1));
            else if ("numer" === this.relation()) {
              const t = this.parent().numer.filter(
                  (t) => "placeholder" !== t.type && "first" !== t.type
                ),
                e = this.parent().denom.filter(
                  (t) => "placeholder" !== t.type && "first" !== t.type
                );
              this.path.pop(),
                Array.prototype.splice.apply(
                  this.siblings(),
                  [this.anchorOffset(), 1].concat(e)
                ),
                Array.prototype.splice.apply(
                  this.siblings(),
                  [this.anchorOffset(), 0].concat(t)
                ),
                this.setSelection(this.anchorOffset() + t.length - 1),
                this._announce("deleted: numerator");
            } else this.move(1), this.delete(-1);
        } else {
          const t = this.startOffset() + 1,
            e = this.endOffset() + 1;
          this._announce("deleted", null, s.slice(t, e)),
            s.splice(t, e - t),
            this.setSelection(t - 1);
        }
        (this.suppressChangeNotifications = e),
          this.selectionDidChange(),
          this.contentDidChange();
      }),
      (ze.prototype.moveToNextPlaceholder_ = function () {
        this.leap(1);
      }),
      (ze.prototype.moveToPreviousPlaceholder_ = function () {
        this.leap(-1);
      }),
      (ze.prototype.moveToNextChar_ = function () {
        this.move(1);
      }),
      (ze.prototype.moveToPreviousChar_ = function () {
        this.move(-1);
      }),
      (ze.prototype.moveUp_ = function () {
        this.up();
      }),
      (ze.prototype.moveDown_ = function () {
        this.down();
      }),
      (ze.prototype.moveToNextWord_ = function () {
        this.skip(1);
      }),
      (ze.prototype.moveToPreviousWord_ = function () {
        this.skip(-1);
      }),
      (ze.prototype.moveToGroupStart_ = function () {
        this.setSelection(0);
      }),
      (ze.prototype.moveToGroupEnd_ = function () {
        this.setSelection(-1);
      }),
      (ze.prototype.moveToMathFieldStart_ = function () {
        this.jumpToMathFieldBoundary(-1);
      }),
      (ze.prototype.moveToMathFieldEnd_ = function () {
        this.jumpToMathFieldBoundary(1);
      }),
      (ze.prototype.deleteNextChar_ = function () {
        this.delete_(1);
      }),
      (ze.prototype.deletePreviousChar_ = function () {
        this.delete_(-1);
      }),
      (ze.prototype.deleteNextWord_ = function () {
        this.extendToNextBoundary(), this.delete_();
      }),
      (ze.prototype.deletePreviousWord_ = function () {
        this.extendToPreviousBoundary(), this.delete_();
      }),
      (ze.prototype.deleteToGroupStart_ = function () {
        this.extendToGroupStart(), this.delete_();
      }),
      (ze.prototype.deleteToGroupEnd_ = function () {
        this.extendToMathFieldStart(), this.delete_();
      }),
      (ze.prototype.deleteToMathFieldEnd_ = function () {
        this.extendToMathFieldEnd(), this.delete_();
      }),
      (ze.prototype.transpose_ = function () {}),
      (ze.prototype.extendToNextChar_ = function () {
        this.extend(1);
      }),
      (ze.prototype.extendToPreviousChar_ = function () {
        this.extend(-1);
      }),
      (ze.prototype.extendToNextWord_ = function () {
        this.skip(1, {
          extend: !0,
        });
      }),
      (ze.prototype.extendToPreviousWord_ = function () {
        this.skip(-1, {
          extend: !0,
        });
      }),
      (ze.prototype.extendUp_ = function () {
        this.up({
          extend: !0,
        });
      }),
      (ze.prototype.extendDown_ = function () {
        this.down({
          extend: !0,
        });
      }),
      (ze.prototype.extendToNextBoundary_ = function () {
        this.skip(1, {
          extend: !0,
        });
      }),
      (ze.prototype.extendToPreviousBoundary_ = function () {
        this.skip(-1, {
          extend: !0,
        });
      }),
      (ze.prototype.extendToGroupStart_ = function () {
        this.setExtent(-this.anchorOffset());
      }),
      (ze.prototype.extendToGroupEnd_ = function () {
        this.setExtent(this.siblings().length - this.anchorOffset());
      }),
      (ze.prototype.extendToMathFieldStart_ = function () {
        this.jumpToMathFieldBoundary(-1, {
          extend: !0,
        });
      }),
      (ze.prototype.extendToMathFieldEnd_ = function () {
        this.jumpToMathFieldBoundary(1, {
          extend: !0,
        });
      }),
      (ze.prototype.moveToSuperscript_ = function () {
        if ((this.collapseForward(), !this.anchor().superscript))
          if (this.anchor().subscript) this.anchor().superscript = [We()];
          else {
            const t = this.sibling(1);
            t && t.superscript
              ? (this.path[this.path.length - 1].offset += 1)
              : t && t.subscript
              ? ((this.path[this.path.length - 1].offset += 1),
                (this.anchor().superscript = [We()]))
              : ("limits" !== this.anchor().limits &&
                  (this.siblings().splice(
                    this.anchorOffset() + 1,
                    0,
                    new Zt(
                      this.parent().mode,
                      "msubsup",
                      "​",
                      this.anchorStyle()
                    )
                  ),
                  (this.path[this.path.length - 1].offset += 1)),
                (this.anchor().superscript = [We()]));
          }
        this.path.push({
          relation: "superscript",
          offset: 0,
        }),
          this.selectGroup_();
      }),
      (ze.prototype.moveToSubscript_ = function () {
        if ((this.collapseForward(), !this.anchor().subscript))
          if (this.anchor().superscript) this.anchor().subscript = [We()];
          else {
            const t = this.sibling(1);
            t && t.subscript
              ? (this.path[this.path.length - 1].offset += 1)
              : t && t.superscript
              ? ((this.path[this.path.length - 1].offset += 1),
                (this.anchor().subscript = [We()]))
              : ("limits" !== this.anchor().limits &&
                  (this.siblings().splice(
                    this.anchorOffset() + 1,
                    0,
                    new Zt(
                      this.parent().mode,
                      "msubsup",
                      "​",
                      this.anchorStyle()
                    )
                  ),
                  (this.path[this.path.length - 1].offset += 1)),
                (this.anchor().subscript = [We()]));
          }
        this.path.push({
          relation: "subscript",
          offset: 0,
        }),
          this.selectGroup_();
      }),
      (ze.prototype.moveToOpposite_ = function () {
        const t = {
          superscript: "subscript",
          subscript: "superscript",
          denom: "numer",
          numer: "denom",
        }[this.relation()];
        t || this.moveToSuperscript_(),
          this.parent()[t] || (this.parent()[t] = [We()]),
          this.setSelection(0, "end", t);
      }),
      (ze.prototype.moveBeforeParent_ = function () {
        this.path.length > 1
          ? (this.path.pop(), this.setSelection(this.anchorOffset() - 1))
          : this._announce("plonk");
      }),
      (ze.prototype.moveAfterParent_ = function () {
        if (this.path.length > 1) {
          const t = $e(this);
          this.path.pop(), this.setExtent(0), this._announce("move", t);
        } else this._announce("plonk");
      }),
      (ze.prototype._addCell = function (t) {
        const e = this.parent();
        if (e && "array" === e.type && Array.isArray(e.array)) {
          const s = this.relation();
          if (e.array) {
            const i = De(e.array, s);
            "after row" === t || "before row" === t
              ? ((i.col = 0),
                (i.row = i.row + ("after row" === t ? 1 : 0)),
                e.array.splice(i.row, 0, [[]]))
              : ((i.col += "after column" === t ? 1 : 0),
                e.array[i.row].splice(i.col, 0, []));
            const a = Te(e.array, i);
            this.path.pop(),
              this.path.push({
                relation: "cell" + a.toString(),
                offset: 0,
              }),
              this.insertFirstAtom();
          }
        }
      }),
      (ze.prototype.convertParentToArray = function () {
        const t = this.parent();
        if ("leftright" === t.type) {
          t.type = "array";
          const e =
              {
                "(": "pmatrix",
                "\\lbrack": "bmatrix",
                "\\lbrace": "cases",
              }[t.leftDelim] || "matrix",
            s = ut(e),
            i = [[t.body]];
          s.parser && Object.assign(t, s.parser(e, [], i)),
            (t.tabularMode = s.tabular),
            (t.parseMode = this.anchorMode()),
            (t.env = {
              ...s,
            }),
            (t.env.name = e),
            (t.array = i),
            (t.rowGaps = [0]),
            delete t.body,
            (this.path[this.path.length - 1].relation = "cell0");
        }
      }),
      (ze.prototype.addRowAfter_ = function () {
        this.contentWillChange(),
          this.convertParentToArray(),
          this._addCell("after row"),
          this.contentDidChange();
      }),
      (ze.prototype.addRowBefore_ = function () {
        this.contentWillChange(),
          this.convertParentToArray(),
          this._addCell("before row"),
          this.contentDidChange();
      }),
      (ze.prototype.addColumnAfter_ = function () {
        this.contentWillChange(),
          this.convertParentToArray(),
          this._addCell("after column"),
          this.contentDidChange();
      }),
      (ze.prototype.addColumnBefore_ = function () {
        this.contentWillChange(),
          this.convertParentToArray(),
          this._addCell("before column"),
          this.contentDidChange();
      }),
      (ze.prototype._applyStyle = function (t) {
        if (this.isCollapsed()) return;
        const e = this;

        function s(t, s) {
          let i = !0;
          return (
            e.forEachSelected(
              (e) => {
                i = i && e[t] === s;
              },
              {
                recursive: !0,
              }
            ),
            i
          );
        }
        t.color && s("color", t.color) && (t.color = "none"),
          t.backgroundColor &&
            s("backgroundColor", t.backgroundColor) &&
            (t.backgroundColor = "none"),
          t.fontFamily &&
            s("fontFamily", t.fontFamily) &&
            (t.fontFamily = "none"),
          t.series && (t.fontSeries = t.series),
          t.fontSeries &&
            s("fontSeries", t.fontSeries) &&
            (t.fontSeries = "auto"),
          t.shape && (t.fontShape = t.shape),
          t.fontShape && s("fontShape", t.fontShape) && (t.fontShape = "auto"),
          t.size && (t.fontSize = t.size),
          t.fontSize && s("fontSize", t.fontSize) && (t.fontSize = "size5"),
          this.contentWillChange(),
          this.forEachSelected((e) => e.applyStyle(t), {
            recursive: !0,
          }),
          this.contentDidChange();
      });
    var Ve = {
      EditableMathlist: ze,
      parseMathString: Re,
    };
    const je = {
        "#": "#",
        "|": "|",
        "[": "BracketLeft",
        "]": "BracketRight",
        "-": "Minus",
        "+": "Plus",
        "=": "Equal",
        "/": "Slash",
        "\\": "Backslash",
      },
      Ue = {
        Space: "Spacebar",
        " ": "Spacebar",
        Escape: "Esc",
        ArrowLeft: "Left",
        ArrowUp: "Up",
        ArrowRight: "Right",
        ArrowDown: "Down",
        Delete: "Del",
      },
      Ge = {
        q: "KeyQ",
        w: "KeyW",
        e: "KeyE",
        r: "KeyR",
        t: "KeyT",
        y: "KeyY",
        u: "KeyU",
        i: "KeyI",
        o: "KeyO",
        p: "KeyP",
        a: "KeyA",
        s: "KeyS",
        d: "KeyD",
        f: "KeyF",
        g: "KeyG",
        h: "KeyH",
        j: "KeyJ",
        k: "KeyK",
        l: "KeyL",
        z: "KeyZ",
        x: "KeyX",
        c: "KeyC",
        v: "KeyV",
        b: "KeyB",
        n: "KeyN",
        m: "KeyM",
        1: "Digit1",
        2: "Digit2",
        3: "Digit3",
        4: "Digit4",
        5: "Digit5",
        6: "Digit6",
        7: "Digit7",
        8: "Digit8",
        9: "Digit9",
        0: "Digit0",
        "!": "Shift-Digit1",
        "@": "Shift-Digit2",
        "#": "Shift-Digit3",
        $: "Shift-Digit4",
        "%": "Shift-Digit5",
        "^": "Shift-Digit6",
        "&": "Shift-Digit7",
        "*": "Shift-Digit8",
        "(": "Shift-Digit9",
        ")": "Shift-Digit0",
        "-": "Minus",
        _: "Shift-Minus",
        "/": "Slash",
        "\\": "Backslash",
        "|": "Shift-Backslash",
        "?": "Shift-Slash",
        " ": "Spacebar",
      };

    function Ze(t) {
      let e,
        s = !0;
      "Unidentified" === t.key &&
        t.target &&
        (e = Ge[t.target.value] || t.target.value),
        e ||
          (je[t.key] ? ((e = je[t.key]), (s = !1)) : (e = Ue[t.key]),
          e || (e = Ge[t.key.toLowerCase()])),
        !e && t.code && (e = Ue[t.code] || t.code);
      const i = [];
      return (
        t.ctrlKey && i.push("Ctrl"),
        t.metaKey && i.push("Meta"),
        s && t.altKey && i.push("Alt"),
        s && t.shiftKey && i.push("Shift"),
        0 === i.length ? e : (i.push(e), i.join("-"))
      );
    }

    function Xe(t, e) {
      let s,
        i = null,
        a = null,
        r = !1,
        n = !1;

      function o(t) {
        clearTimeout(s),
          (s = setTimeout(function () {
            clearTimeout(s), t();
          }));
      }

      function l() {
        if (
          (function (t) {
            return t.selectionStart !== t.selectionEnd;
          })(t)
        )
          return;
        const s = t.value;
        (t.value = ""), s.length > 0 && e.typedText(s);
      }
      const c = t || e.container;
      c.addEventListener(
        "keydown",
        function (s) {
          if (
            ("function" == typeof e.allowDeadKey && e.allowDeadKey()) ||
            ("Dead" !== s.key && "Unidentified" !== s.key && 229 !== s.keyCode)
          )
            n = !1;
          else {
            (n = !0), (r = !1);
            const s = e.blur,
              i = e.focus;
            (e.blur = null),
              (e.focus = null),
              t.blur(),
              t.focus(),
              (e.blur = s),
              (e.focus = i);
          }
          return (
            !(
              !r &&
              "CapsLock" !== s.code &&
              !/(Control|Meta|Alt|Shift)(Right|Left)/.test(s.code)
            ) || ((i = s), (a = null), e.keystroke(Ze(s), s))
          );
        },
        !0
      ),
        c.addEventListener(
          "keypress",
          function (t) {
            r || (i && a && e.keystroke(Ze(i), i), (a = t), o(l));
          },
          !0
        ),
        c.addEventListener(
          "keyup",
          function () {
            r || !i || a || l();
          },
          !0
        ),
        c.addEventListener(
          "paste",
          function () {
            t.focus();
            const s = t.value;
            (t.value = ""), s.length > 0 && e.paste(s);
          },
          !0
        ),
        c.addEventListener(
          "copy",
          function (t) {
            e.copy && e.copy(t);
          },
          !0
        ),
        c.addEventListener(
          "cut",
          function (t) {
            e.cut && e.cut(t);
          },
          !0
        ),
        c.addEventListener(
          "blur",
          function () {
            (i = null), (a = null), e.blur && e.blur();
          },
          !0
        ),
        c.addEventListener(
          "focus",
          function () {
            e.focus && e.focus();
          },
          !0
        ),
        c.addEventListener(
          "compositionstart",
          () => {
            r = !0;
          },
          !0
        ),
        c.addEventListener(
          "compositionend",
          () => {
            (r = !1), o(l);
          },
          !0
        ),
        c.addEventListener("input", () => {
          if (n) {
            const s = e.blur,
              i = e.focus;
            (e.blur = null),
              (e.focus = null),
              t.blur(),
              t.focus(),
              (e.blur = s),
              (e.focus = i),
              (n = !1),
              (r = !1),
              o(l);
          } else r || o(l);
        });
    }
    var Ye = {
      delegateKeyboardEvents: Xe,
      select: Xe.select,
      keyboardEventToString: Ze,
      eventToChar: function (t) {
        if (!t) return "";
        let e;
        return (
          "Unidentified" === t.key && t.target && (e = t.target.value),
          (e = e || t.key || t.code),
          /^(Return|Enter|Tab|Escape|Delete|PageUp|PageDown|Home|End|Help|ArrowLeft|ArrowRight|ArrowUp|ArrowDown)$/.test(
            e
          ) && (e = ""),
          e
        );
      },
      charToEvent: function (t) {
        return {
          key: t,
          metaKey: !1,
          ctrlKey: !1,
          altKey: !1,
          shiftKey: !1,
        };
      },
    };
    const Je = {
      "\\text": "roman text",
      "\\textrm": "roman text",
      "\\textnormal": "roman text",
      "\\textit": "italic text",
      "\\textbf": "bold text",
      "\\texttt": "monospaced text",
      "\\textsf": "sans-serif text",
      "\\mathrm": ["roman", "(upright)"],
      "\\mathbf": "bold",
      "\\bf": "bold",
      "\\bold": "bold",
      "\\mathit": "italic",
      "\\mathbb": "blackboard",
      "\\mathscr": "script",
      "\\mathtt": ["typewriter", "(monospaced)"],
      "\\mathsf": "sans-serif",
      "\\mathcal": "caligraphic",
      "\\frak": ["fraktur", "(gothic)"],
      "\\mathfrak": ["fraktur", "(gothic)"],
      "\\textcolor": "text color",
      "\\color": "color",
      "\\forall": "for all",
      "\\exists": "there exists",
      "\\nexists": "there does not exist",
      "\\frac": "fraction",
      "\\dfrac": "display fraction",
      "\\cfrac": "continuous fraction",
      "\\tfrac": "text fraction",
      "\\binom": "binomial coefficient",
      "\\dbinom": "display binomial coefficient",
      "\\tbinom": "text binomial coefficient",
      "\\pdiff": "partial differential",
      "\\vec": "vector",
      "\\check": "caron",
      "\\acute": "acute",
      "\\breve": "breve",
      "\\tilde": "tilde",
      "\\dot": "dot",
      "\\hat": ["hat", "circumflex"],
      "\\ddot": "double dot",
      "\\bar": "bar",
      "\\prime": "prime",
      "\\doubleprime": "double prime",
      "\\varnothing": "empty set",
      "\\emptyset": "empty set",
      "\\subseteq": "subset of or <br>equal to",
      "\\supseteq": "superset of or <br>equal to",
      "\\supset": "superset of",
      "\\subset": "subset of",
      "\\partial": "partial derivative",
      "\\bigcup": "union",
      "\\bigcap": "intersection",
      "\\approx": "approximately equal to",
      "\\notin": "not an element of",
      "\\in": ["element of", "included in"],
      "\\infty": "infinity",
      "\\land": "logical and",
      "\\sqrt": "square root",
      "\\prod": "product",
      "\\sum": "summation",
      "\\amalg": [
        "amalgamation",
        "coproduct",
        "free product",
        "disjoint union",
      ],
      "\\cup": "union with",
      "\\cap": "intersection with",
      "\\int": "integral",
      "\\iint": "surface integral",
      "\\oint": "curve integral",
      "\\iiint": "volume integral",
      "\\iff": "if and only if",
      "\\ln": "natural logarithm",
      "\\boldsymbol": "bold",
      "\\setminus": "set subtraction",
      "\\stackrel": "relation with symbol above",
      "\\stackbin": "operator with symbol above",
      "\\underset": "symbol with annotation below",
      "\\overset": "symbol with annotation above",
      "\\hslash": ["h-bar", "Planck constant"],
      "\\gtrsim": "greater than or <br>similar to",
      "\\propto": "proportional to",
      "\\equiv": "equivalent to",
      "\\!": ["negative thin space", "(-3 mu)"],
      "\\ ": ["space", "(6 mu)"],
      "\\,": ["thin space", "(3 mu)"],
      "\\:": ["medium space", "(4 mu)"],
      "\\;": ["thick space", "(5 mu)"],
      "\\quad": ["1 em space", "(18 mu)"],
      "\\qquad": ["2 em space", "(36 mu)"],
      "\\enskip": ["&#189; em space", "(9 mu)"],
      "\\mp": "minus or plus",
      "\\pm": "plus or minus",
      "\\Im": "Imaginary part of",
      "\\Re": "Real part of",
      "\\gothicCapitalR": "Real part of",
      "\\gothicCapitalI": "Imaginary part part of",
      "\\differentialD": "differential d",
      "\\aleph": [
        "aleph",
        "infinite cardinal",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Cardinal_number">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\beth": [
        "beth",
        "beth number",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Beth_number">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\gimel": [
        "gimel",
        "gimel function",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Gimel_function">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\O": "empty set",
      "\\N": "set of <br>natural numbers",
      "\\Z": "set of <br>integers",
      "\\Q": "set of <br>rational numbers",
      "\\C": "set of <br>complex numbers",
      "\\R": "set of <br>real numbers",
      "\\P": "set of <br>prime numbers",
      "\\lesseqqgtr": "less than, equal to or<br> greater than",
      "\\gnapprox": "greater than and <br>not approximately",
      "\\lnapprox": "lesser than and <br>not approximately",
      "\\j": "dotless j",
      "\\i": "dotless i",
      "\\cdot": "centered dot",
      "\\lmoustache": "left moustache",
      "\\rmoustache": "right moustache",
      "\\nabla": ["nabla", "del", "differential vector operator"],
      "\\square": [
        "square",
        "d’Alembert operator",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/D%27Alembert_operator">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\blacksquare": [
        "black square",
        "end of proof",
        "tombstone",
        "Halmos symbol",
      ],
      "\\Box": "end of proof",
      "\\colon": ["such that", "ratio"],
      "\\coloneq": ["is defined by", "is assigned"],
      "\\Colon": ["is defined by", "as"],
      "\\_": ["underbar", "underscore"],
      "\\ll": "much less than",
      "\\gg": "much greater than",
      "\\doteq": "approximately equal to",
      "\\Doteq": "approximately equal to",
      "\\doteqdot": "approximately equal to",
      "\\cong": ["isomorphism of", "(for algebras, modules...)"],
      "\\det": ["determinant of", "(of a matrix)"],
      "\\dotplus": "Cartesian product algebra",
      "\\otimes": [
        "tensor product",
        "(of algebras)",
        "Kronecker product",
        "(of matrices)",
      ],
      "\\oplus": ["direct sum", "(of modules)"],
      "\\lb": "base-2 logarithm",
      "\\lg": "base-10 logarithm",
      "\\wp": [
        "Weierstrass P",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Weierstrass%27s_elliptic_functions">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\wr": [
        "wreath product",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Wreath_product">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\top": ["tautology", "Proposition P is universally true"],
      "\\bot": ["contradiction", "Proposition P is contradictory"],
      "\\mid": ["probability", "of event A given B"],
      "\\mho": [
        "Siemens",
        "electrical conductance in SI unit",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Siemens_(unit)">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\Longrightarrow": "implies",
      "\\Longleftrightarrow": "if, and only if,",
      "\\prec": "precedes",
      "\\preceq": "precedes or is equal to",
      "\\succ": "succeedes",
      "\\succeq": "succeedes or is equal to",
      "\\perp": ["is perpendicular to", "is independent of"],
      "\\models": [
        "entails",
        "double-turnstyle, models",
        "is a semantic consequence of",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Double_turnstile">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\vdash": [
        "satisfies",
        "turnstyle, assertion sign",
        "syntactic inference",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Turnstile_(symbol)">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\implies": ["implies", "logical consequence"],
      "\\impliedby": ["implied by", "logical consequence"],
      "\\surd": ["surd", "root of", "checkmark"],
      "\\ltimes": [
        "semi direct product",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\rtimes": [
        "semi direct product",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\leftthreetimes": [
        "semi direct product",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\rightthreetimes": [
        "semi direct product",
        '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>',
      ],
      "\\divideontimes": ["divide on times"],
      "\\curlywedge": "nor",
      "\\curlyvee": "nand",
      "\\simeq": "is group isomorphic with",
      "\\vartriangleleft": ["is a normal subgroup of", "is an ideal ring of"],
      "\\circ": ["circle", "ring", "function composition"],
      "\\rlap": ["overlap right", "\\rlap{x}o"],
      "\\llap": ["overlap left", "o\\llap{/}"],
      "\\colorbox": ["color box", "\\colorbox{#fbc0bd}{...}"],
      "\\ast": ["asterisk", "reflexive closure (as a superscript)"],
      "\\bullet": "bullet",
      "\\lim": "limit",
    };

    function Qe(t, e) {
      t.popover.innerHTML = e;
      const s = t._getCaretPosition();
      s && ts(t, s), t.popover.classList.add("is-visible");
    }

    function ts(t, e) {
      const s =
          window.innerHeight ||
          document.documentElement.clientHeight ||
          document.body.clientHeight,
        i =
          window.innerWidth ||
          document.documentElement.clientWidth ||
          document.body.clientWidth,
        a = window.innerWidth - document.documentElement.clientWidth,
        r = window.innerHeight - document.documentElement.clientHeight,
        n = t.virtualKeyboardVisible ? t.virtualKeyboard.offsetHeight : 0;
      e.x + t.popover.offsetWidth / 2 > i - a
        ? (t.popover.style.left = i - t.popover.offsetWidth - a + "px")
        : e.x - t.popover.offsetWidth / 2 < 0
        ? (t.popover.style.left = 0)
        : (t.popover.style.left = e.x - t.popover.offsetWidth / 2 + "px"),
        e.y + t.popover.offsetHeight + 5 > s - r - n
          ? (t.popover.classList.add("reverse-direction"),
            (t.popover.style.top =
              e.y - e.height - t.popover.offsetHeight - 5 + "px"))
          : (t.popover.classList.remove("reverse-direction"),
            (t.popover.style.top = e.y + 5 + "px"));
    }

    function es(t) {
      t.popover.classList.remove("is-visible");
    }
    var ss = {
      NOTES: Je,
      showPopoverWithLatex: function (t, e, s) {
        if (!e || 0 === e.length) return void es(t);
        const i = e,
          a = ft(i),
          r = (function (t, e) {
            const s = ge(t, "math", null, e.config.macros);
            return H(
              I(
                Gt(
                  {
                    mathstyle: k.displaystyle,
                    macros: e.config.macros,
                  },
                  s
                ),
                "ML__base"
              ),
              "ML__mathlive"
            ).toMarkup();
          })((a && a.template) || e, t),
          n = (function (t) {
            let e = Je[t] || "";
            return Array.isArray(e) && (e = e.join("<br>")), e;
          })(i),
          o = Ce.forCommand(i);
        let l = s
          ? '<div class="ML__popover__prev-shortcut" role="button" aria-label="Previous suggestion"><span><span>&#x25B2;</span></span></div>'
          : "";
        (l += '<span class="ML__popover__content" role="button">'),
          (l += '<div class="ML__popover__command">' + r + "</div>"),
          n && (l += '<div class="ML__popover__note">' + n + "</div>"),
          o && (l += '<div class="ML__popover__shortcut">' + o + "</div>"),
          (l += "</span>"),
          (l += s
            ? '<div class="ML__popover__next-shortcut" role="button" aria-label="Next suggestion"><span><span>&#x25BC;</span></span></div>'
            : ""),
          Qe(t, l);
        let c = t.popover.getElementsByClassName("ML__popover__content");
        c &&
          c.length > 0 &&
          t._attachButtonHandlers(c[0], [
            "complete",
            {
              acceptSuggestion: !0,
            },
          ]),
          (c = t.popover.getElementsByClassName("ML__popover__prev-shortcut")),
          c &&
            c.length > 0 &&
            t._attachButtonHandlers(c[0], "previousSuggestion"),
          (c = t.popover.getElementsByClassName("ML__popover__next-shortcut")),
          c && c.length > 0 && t._attachButtonHandlers(c[0], "nextSuggestion");
      },
      showPopover: Qe,
      hidePopover: es,
      updatePopoverPosition: function t(e, s) {
        if (
          e.element &&
          e.element.mathfield === e &&
          e.popover.classList.contains("is-visible")
        )
          if (s && s.deferred) window.requestAnimationFrame(() => t(e));
          else if (
            e.mathlist.anchor() &&
            "command" === e.mathlist.anchor().type
          ) {
            const t = e._getCaretPosition();
            t && ts(e, t);
          } else es(e);
      },
    };

    function is(t) {
      const e = is.locale.substring(0, 2);
      let s = "";
      return (
        is.strings[is.locale] && (s = is.strings[is.locale][t]),
        !s && is.strings[e] && (s = is.strings[e][t]),
        s || (s = is.strings.en[t]),
        s || (s = t),
        s
      );
    }
    (is.plural = function (t, e, s) {
      (s = s || {}).type = s.type || "cardinal";
      const i = is.locale.substring(0, 2),
        a = "ordinal" === s.type ? is.ordinal : is.cardinal;
      let r,
        n =
          "ordinal" === s.type
            ? is._ordinalPluralCategories.indexOf(a.select(t))
            : is._cardinalPluralCategories.indexOf(a.select(t));
      return (
        is.strings[is.locale] && (r = is.strings[is.locale][e]),
        !r && is.strings[i] && (r = is.strings[i][e]),
        r ||
          ((r = is.strings.en[e]),
          r || (r = e),
          (n =
            "ordinal" === s.type
              ? is._ordinalPluralCategories.indexOf(
                  is._ordinalEnglish.select(t)
                )
              : is._cardinalPluralCategories.indexOf(
                  is._cardinalEnglish.select(t)
                ))),
        r.split(";")[n] || r.split(";")[0]
      );
    }),
      (is.merge = function (t, e) {
        if (t && e) {
          const s = is._locale;
          (is.locale = t),
            (is.strings[t] = {
              ...is.strings[t],
              ...e,
            }),
            (is.locale = s);
        } else
          t &&
            !e &&
            ((e = t), Object.keys(e).forEach((t) => is.merge(t, e[t])));
      }),
      Object.defineProperty(is, "locale", {
        set(t) {
          (is._locale = t), (is._ordinal = null), (is._cardinal = null);
        },
        get: () => (
          is._locale ||
            (is._locale =
              "undefined" == typeof navigator
                ? "en"
                : navigator.language.slice(0, 5)),
          is._locale
        ),
      }),
      Object.defineProperty(is, "ordinal", {
        get: () => (
          is._ordinal ||
            ((is._ordinalEnglish = new Intl.PluralRules("en", {
              type: "ordinal",
            })),
            (is._ordinalEnglishPluralCategories =
              is._ordinalEnglish.resolvedOptions().pluralCategories),
            (is._ordinal = new Intl.PluralRules(is.locale, {
              type: "ordinal",
            })),
            (is._ordinalPluralCategories =
              is._ordinal.resolvedOptions().pluralCategories)),
          is._ordinal
        ),
      }),
      Object.defineProperty(is, "cardinal", {
        get: () => (
          is._cardinal ||
            ((is._cardinalEnglish = new Intl.PluralRules("en", {
              type: "cardinal",
            })),
            (is._cardinalEnglishPluralCategories =
              is._cardinalEnglish.resolvedOptions().pluralCategories),
            (is._cardinal = new Intl.PluralRules(is.locale, {
              type: "cardinal",
            })),
            (is._cardinaPluralCategories =
              is._ordinal.resolvedOptions().pluralCategories)),
          is._cardinal
        ),
      }),
      (is.strings = {
        en: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "Functions",
          "keyboard.tooltip.greek": "Greek Letters",
          "keyboard.tooltip.command": "LaTeX Command Mode",
          "keyboard.tooltip.numeric": "Numeric",
          "keyboard.tooltip.roman": "Symbols and Roman Letters",
          "tooltip.copy to clipboard": "Copy to Clipboard",
          "tooltip.redo": "Redo",
          "tooltip.toggle virtual keyboard": "Toggle Virtual Keyboard",
          "tooltip.undo": "Undo",
        },
        ar: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "مهام",
          "keyboard.tooltip.greek": "حروف يونانية",
          "keyboard.tooltip.command": "حالة تلقي الأوامر اللاتك",
          "keyboard.tooltip.numeric": "الرقمية",
          "keyboard.tooltip.roman": "رموز الاحرف الرومانية",
          "tooltip.copy to clipboard": "نسخ إلى الحافظة",
          "tooltip.redo": "الإعادة",
          "tooltip.toggle virtual keyboard": "تبديل لوحة المفاتيح الإفتراضية",
          "tooltip.undo": "إلغاء",
        },
        de: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "Funktionen",
          "keyboard.tooltip.greek": "Griechische Buchstaben",
          "keyboard.tooltip.command": "LaTeX-Befehlsmodus",
          "keyboard.tooltip.numeric": "Numerisch",
          "keyboard.tooltip.roman": "Symbole und römische Buchstaben",
          "tooltip.copy to clipboard": "In die Zwischenablage kopieren",
          "tooltip.redo": "Wiederholen",
          "tooltip.toggle virtual keyboard": "Virtuelle Tastatur umschalten",
          "tooltip.undo": "Widerrufen",
        },
        el: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "συναρτήσεις",
          "keyboard.tooltip.greek": "ελληνικά γράμματα",
          "keyboard.tooltip.command": "Λειτουργία εντολών LaTeX",
          "keyboard.tooltip.numeric": "Αριθμητικός",
          "keyboard.tooltip.roman": "Σύμβολα και ρωμαϊκά γράμματα",
          "tooltip.copy to clipboard": "Αντιγραφή στο πρόχειρο",
          "tooltip.redo": "Ξανακάνω",
          "tooltip.toggle virtual keyboard": "Εναλλαγή εικονικού πληκτρολογίου",
          "tooltip.undo": "Ξεκάνω",
        },
        es: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "Funciones",
          "keyboard.tooltip.greek": "Letras griegas",
          "keyboard.tooltip.command": "Modo Comando LaTeX",
          "keyboard.tooltip.numeric": "Numérico",
          "keyboard.tooltip.roman": "Símbolos y letras romanas",
          "tooltip.copy to clipboard": "Copiar al portapapeles",
          "tooltip.redo": "Rehacer",
          "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
          "tooltip.undo": "Deshacer",
        },
        fa: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "توابع",
          "keyboard.tooltip.greek": "حروف یونانی",
          "keyboard.tooltip.command": "حالت دستور لاتک",
          "keyboard.tooltip.numeric": "عددی",
          "keyboard.tooltip.roman": "علائم و حروف لاتین",
          "tooltip.copy to clipboard": "کپی به کلیپبورد",
          "tooltip.redo": "بازگشت به بعد",
          "tooltip.toggle virtual keyboard": "نمایش/نهفتن کیبورد مجازی",
          "tooltip.undo": "بازگشت به قبل",
        },
        fr: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "Fonctions",
          "keyboard.tooltip.greek": "Lettres grecques",
          "keyboard.tooltip.command": "Mode de commandes LaTeX",
          "keyboard.tooltip.numeric": "Numérique",
          "keyboard.tooltip.roman": "Lettres et symboles romains",
          "tooltip.copy to clipboard": "Copier dans le presse-papiers",
          "tooltip.redo": "Rétablir",
          "tooltip.toggle virtual keyboard":
            "Afficher/Masquer le clavier virtuel",
          "tooltip.undo": "Annuler",
        },
        it: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "Funzioni",
          "keyboard.tooltip.greek": "Lettere greche",
          "keyboard.tooltip.command": "Modalità di comando LaTeX",
          "keyboard.tooltip.numeric": "Numerico",
          "keyboard.tooltip.roman": "Simboli e lettere romane",
          "tooltip.copy to clipboard": "Copia negli appunti",
          "tooltip.redo": "Rifare",
          "tooltip.toggle virtual keyboard":
            "Attiva / disattiva la tastiera virtuale",
          "tooltip.undo": "Disfare",
        },
        ja: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "関数",
          "keyboard.tooltip.greek": "ギリシャ文字",
          "keyboard.tooltip.command": "LaTeXコマンドモード",
          "keyboard.tooltip.numeric": "数値",
          "keyboard.tooltip.roman": "記号とローマ字",
          "tooltip.copy to clipboard": "クリップボードにコピー",
          "tooltip.redo": "やり直し",
          "tooltip.toggle virtual keyboard": "仮想キーボードの切り替え",
          "tooltip.undo": "元に戻す",
        },
        pl: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "Funkcje",
          "keyboard.tooltip.greek": "Litery greckie",
          "keyboard.tooltip.command": "Tryb poleceń LaTeX",
          "keyboard.tooltip.numeric": "Numeryczne",
          "keyboard.tooltip.roman": "Symbole i litery rzymskie",
          "tooltip.copy to clipboard": "Kopiuj do Schowka",
          "tooltip.redo": "Przywróć",
          "tooltip.toggle virtual keyboard": "Przełącz wirtualną klawiaturę",
          "tooltip.undo": "Cofnij",
        },
        ru: {
          "keyboard.tooltip.calculus1": "Calculus",
          "keyboard.tooltip.functions": "Функции",
          "keyboard.tooltip.greek": "Греческие буквы",
          "keyboard.tooltip.command": "Режим командной строки LaTeX",
          "keyboard.tooltip.numeric": "числовой",
          "keyboard.tooltip.roman": "Символы и римские буквы",
          "tooltip.copy to clipboard": "Скопировать в буфер обмена",
          "tooltip.redo": "переделывать",
          "tooltip.toggle virtual keyboard":
            "Переключить виртуальную клавиатуру",
          "tooltip.undo": "расстегивать",
        },
      });
    const as = {
        numeric: {
          tooltip: "keyboard.tooltip.numeric",
          layer: "math",
          label: "123",
          layers: ["math"],
        },
        roman: {
          tooltip: "keyboard.tooltip.roman",
          layer: "lower-roman",
          label: "ABC",
          layers: ["lower-roman", "upper-roman", "symbols"],
        },
        greek: {
          tooltip: "keyboard.tooltip.greek",
          layer: "lower-greek",
          label: "&alpha;&beta;&gamma;",
          classes: "tex-math",
          layers: ["lower-greek", "upper-greek"],
        },
        functions: {
          tooltip: "keyboard.tooltip.functions",
          layer: "functions",
          label: "<i>f</i>&thinsp;()",
          classes: "tex",
          layers: ["functions"],
        },
        calculus1: {
          tooltip: "keyboard.tooltip.calculus1",
          layer: "calculus1",
          label: "Main",
          layers: ["calculus1"],
        },
        command: {
          tooltip: "keyboard.tooltip.command",
          command: "enterCommandMode",
          label: "<svg><use xlink:href='#svg-command' /></svg>",
          layers: ["lower-command", "upper-command", "symbols-command"],
        },
        style: {
          tooltip: "keyboard.tooltip.style",
          layer: "style",
          label: "<b>b</b><i>i</i>𝔹",
        },
      },
      rs = {
        "\\varphi ": {
          label: "&Phi;",
          insert: "\\Phi ",
        },
        "\\varsigma ": {
          label: "&Sigma;",
          insert: "\\Sigma ",
        },
        "\\epsilon ": {
          label: "&#x0190;",
          insert: "\\Epsilon",
        },
        "\\rho ": {
          label: "&#x3A1",
          insert: "\\Rho",
        },
        "\\tau ": {
          label: "&#x3A4;",
          insert: "\\Tau",
        },
        "\\upsilon ": {
          label: "&Upsilon;",
          insert: "\\Upsilon ",
        },
        "\\theta ": {
          label: "&Theta;",
          insert: "\\Theta ",
        },
        "\\iota ": {
          label: "&Iota;",
          insert: "\\Iota",
        },
        "\\omicron ": {
          label: "&#x039F;",
          insert: "\\Omicron",
        },
        "\\pi ": {
          label: "&Pi;",
          insert: "\\Pi ",
        },
        "\\alpha ": {
          label: "&Alpha;",
          insert: "\\Alpha",
        },
        "\\sigma ": {
          label: "&Sigma;",
          insert: "\\Sigma ",
        },
        "\\delta ": {
          label: "&Delta;",
          insert: "\\Delta ",
        },
        "\\phi ": {
          label: "&#x03a6;",
          insert: "\\Phi ",
        },
        "\\gamma ": {
          label: "&Gamma;",
          insert: "\\Gamma ",
        },
        "\\eta ": {
          label: "&Eta;",
          insert: "\\Eta",
        },
        "\\xi ": {
          label: "&Xi;",
          insert: "\\Xi ",
        },
        "\\kappa ": {
          label: "&Kappa;",
          insert: "\\Kappa",
        },
        "\\lambda ": {
          label: "&Lambda;",
          insert: "\\Lambda ",
        },
        "\\zeta ": {
          label: "&Zeta;",
          insert: "\\Zeta",
        },
        "\\chi ": {
          label: "&Chi;",
          insert: "\\Chi",
        },
        "\\psi ": {
          label: "&Psi;",
          insert: "\\Psi ",
        },
        "\\omega ": {
          label: "&Omega;",
          insert: "\\Omega ",
        },
        "\\beta ": {
          label: "&Beta;",
          insert: "\\Beta",
        },
        "\\nu ": {
          label: "&Nu;",
          insert: "\\Nu",
        },
        "\\mu ": {
          label: "&Mu;",
          insert: "\\Mu",
        },
      },
      ns = {
        0: [
          "\\emptyset",
          "\\varnothing",
          "\\infty",
          {
            latex: "#?_0",
            insert: "#@_0",
          },
        ],
        2: [
          "\\frac{1}{2}",
          {
            latex: "#?^2",
            insert: "#@^2",
          },
        ],
        3: [
          "\\frac{1}{3}",
          {
            latex: "#?^3",
            insert: "#@^3",
          },
        ],
        4: [
          "\\frac{1}{4}",
          {
            latex: "#?^4",
            insert: "#@^4",
          },
        ],
        5: [
          "\\frac{1}{5}",
          {
            latex: "#?^5",
            insert: "#@^5",
          },
        ],
        6: [
          "\\frac{1}{6}",
          {
            latex: "#?^6",
            insert: "#@^6",
          },
        ],
        7: [
          "\\frac{1}{7}",
          {
            latex: "#?^7",
            insert: "#@^7",
          },
        ],
        8: [
          "\\frac{1}{8}",
          {
            latex: "#?^8",
            insert: "#@^8",
          },
        ],
        9: [
          "\\frac{1}{9}",
          {
            latex: "#?^9",
            insert: "#@^9",
          },
        ],
        ".": [
          ",",
          ";",
          "\\colon",
          {
            latex: ":",
            aside: "ratio",
          },
          {
            latex: "\\cdotp",
            aside: "center dot",
            classes: "box",
          },
          {
            latex: "\\cdots",
            aside: "center ellipsis",
            classes: "box",
          },
          {
            latex: "\\ldotp",
            aside: "low dot",
            classes: "box",
          },
          {
            latex: "\\ldots",
            aside: "low ellipsis",
            classes: "box",
          },
          {
            latex: "\\vdots",
            aside: "",
            classes: "box",
          },
          {
            latex: "\\ddots",
            aside: "",
            classes: "box",
          },
          "\\odot",
          "\\oslash",
          "\\circledcirc",
        ],
        "*": [
          "\\cdot",
          "\\ast",
          "\\prod",
          {
            latex: "\\prod_{i\\mathop=i}^{\\infty}",
            classes: "small",
          },
        ],
        "+": [
          "\\pm",
          "\\mp",
          "\\sum",
          {
            latex: "\\sum_{i\\mathop=1}^{\\infty}",
            classes: "small",
          },
        ],
        "-": ["\\pm", "\\mp"],
        "/": ["/", "\\div"],
        "(": [
          "\\left( #0\\right)",
          "\\left[ #0\\right]",
          "\\left\\{ #0\\right\\}",
          "\\left\\langle #0\\right\\rangle",
          "\\lfloor",
          "\\llcorner",
          "(",
          "\\lbrack",
          "\\lvert",
          "\\lVert",
          "\\lgroup",
          "\\langle",
          "\\lceil",
          "\\ulcorner",
          "\\lmoustache",
          "\\lbrace",
        ],
        ")": [
          "\\rfloor",
          "\\lrcorner",
          ")",
          "\\rbrack",
          "\\rvert",
          "\\rVert",
          "\\rgroup",
          "\\rangle",
          "\\rceil",
          "\\urcorner",
          "\\rmoustache",
          "\\rbrace",
        ],
        "=": [
          "\\ne",
          "\\differencedelta",
          "\\varpropto",
          "\\thickapprox",
          "\\thicksim",
        ],
        "!=": ["\\neq", "\\ncong", "", "\\nsim"],
        "<": [
          "\\leq",
          "\\leqq",
          "\\lneqq",
          "\\ll",
          "\\nless",
          "\\nleq",
          "\\precsim",
          "\\lesssim",
          "\\lessgtr",
          "\\prec",
          "\\preccurlyeq",
          "\\lessdot",
          "\\nprec",
        ],
        ">": [
          "\\geq",
          "\\geqq",
          "\\gneqq",
          "\\gg",
          "\\ngtr",
          "\\ngeq",
          "\\succsim",
          "\\gtrsim",
          "\\gtrless",
          "\\succ",
          "\\succcurlyeq",
          "\\gtrdot",
          "\\nsucc",
        ],
        set: [
          "\\in",
          "\\owns",
          "\\subset",
          "\\nsubset",
          "\\supset",
          "\\nsupset",
        ],
        "!set": ["\\notin", "\\backepsilon"],
        subset: [],
        supset: [],
        infinity: ["\\aleph_0", "\\aleph_1", "\\omega", "\\mathfrak{m}"],
        "numeric-pi": ["\\prod", "\\theta", "\\rho", "\\sin", "\\cos", "\\tan"],
        ee: ["e", "\\ln(#?)"],
        "^": ["_{#?}"],
        sqrt: ["\\frac{1}{\\sqrt{#?}}", "\\vert #0  \\vert"],
        int: [
          {
            latex: "\\int_{#?}^{#?}",
            classes: "small",
          },
          {
            latex: "\\int",
            classes: "small",
          },
          {
            latex: "\\smallint",
            classes: "small",
          },
          {
            latex: "\\iint",
            classes: "small",
          },
          {
            latex: "\\iiint",
            classes: "small",
          },
          {
            latex: "\\oint",
            classes: "small",
          },
          {
            latex: "\\dfrac{\\rd}{\\rd x}",
            classes: "small",
          },
          {
            latex: "\\frac{\\partial}{\\partial x}",
            classes: "small",
          },
          "\\capitalDifferentialD",
          "\\rd",
          "\\partial",
        ],
        nabla: ["\\nabla\\times", "\\nabla\\cdot", "\\nabla^{2}"],
        "!": ["!!", "\\Gamma", "\\Pi"],
        accents: [
          "\\bar{#@}",
          "\\vec{#@}",
          "\\hat{#@}",
          "\\check{#@}",
          "\\dot{#@}",
          "\\ddot{#@}",
          "\\mathring{#@}",
          "\\breve{#@}",
          "\\acute{#@}",
          "\\tilde{#@}",
          "\\grave{#@}",
        ],
        A: [
          {
            latex: "\\aleph",
            aside: "aleph",
          },
          {
            latex: "\\forall",
            aside: "for all",
          },
        ],
        a: [
          {
            latex: "\\aleph",
            aside: "aleph",
          },
          {
            latex: "\\forall",
            aside: "for all",
          },
        ],
        b: [
          {
            latex: "\\beth",
            aside: "beth",
          },
        ],
        B: [
          {
            latex: "\\beth",
            aside: "beth",
          },
        ],
        c: [
          {
            latex: "\\C",
            aside: "set of complex numbers",
          },
        ],
        d: [
          {
            latex: "\\daleth",
            aside: "daleth",
          },
        ],
        D: [
          {
            latex: "\\daleth",
            aside: "daleth",
          },
        ],
        e: [
          {
            latex: "\\exponentialE",
            aside: "exponential e",
          },
          {
            latex: "\\exists",
            aside: "there is",
          },
          {
            latex: "\\nexists",
            aside: "there isn’t",
          },
        ],
        g: [
          {
            latex: "\\gimel",
            aside: "gimel",
          },
        ],
        G: [
          {
            latex: "\\gimel",
            aside: "gimel",
          },
        ],
        h: [
          {
            latex: "\\hbar",
            aside: "h bar",
          },
          {
            latex: "\\hslash",
            aside: "h slash",
          },
        ],
        i: [
          {
            latex: "\\imaginaryI",
            aside: "imaginary i",
          },
        ],
        j: [
          {
            latex: "\\imaginaryJ",
            aside: "imaginary j",
          },
        ],
        l: [
          {
            latex: "\\ell",
            aside: "ell",
          },
        ],
        n: [
          {
            latex: "\\N",
            aside: "set of natural numbers",
          },
        ],
        p: [
          {
            latex: "\\P",
            aside: "set of primes",
          },
        ],
        q: [
          {
            latex: "\\Q",
            aside: "set of rational numbers",
          },
        ],
        r: [
          {
            latex: "\\R",
            aside: "set of real numbers",
          },
        ],
        z: [
          {
            latex: "\\Z",
            aside: "set of integers",
          },
        ],
        "x-var": [
          "y",
          "t",
          "s",
          "u",
          "x^2",
          "x^3",
          "\\sqrt{x}",
          "\\frac{1}{x}",
          "\\frac{1}{x^2}",
          "\\frac{1}{\\sqrt{x}}",
          "x_#?",
          "x^#?",
        ],
        "n-var": ["i", "j", "k", "a", "b", "n"],
        ii: ["\\Re", "\\Im", "\\imaginaryJ", "\\Vert #0 \\Vert"],
        logic: [
          {
            latex: "\\exists",
            aside: "there is",
          },
          {
            latex: "\\nexists",
            aside: "there isn’t",
          },
          {
            latex: "\\ni",
            aside: "such that",
          },
          {
            latex: "\\Colon",
            aside: "such that",
          },
          {
            latex: "\\implies",
            aside: "implies",
          },
          {
            latex: "\\impliedby",
            aside: "implied by",
          },
          {
            latex: "\\iff",
            aside: "if and only if",
          },
          {
            latex: "\\land",
            aside: "and",
          },
          {
            latex: "\\lor",
            aside: "or",
          },
          {
            latex: "\\oplus",
            aside: "xor",
          },
          {
            latex: "\\lnot",
            aside: "not",
          },
          {
            latex: "\\downarrow",
            aside: "nor",
          },
          {
            latex: "\\uparrow",
            aside: "nand",
          },
          {
            latex: "\\curlywedge",
            aside: "nor",
          },
          {
            latex: "\\bar\\curlywedge",
            aside: "nand",
          },
          {
            latex: "\\therefore",
            aside: "therefore",
          },
          {
            latex: "\\because",
            aside: "because",
          },
          {
            latex: "^\\biconditional",
            aside: "biconditional",
          },
          "\\leftrightarrow",
          "\\Leftrightarrow",
          "\\to",
          "\\models",
          "\\vdash",
          "\\gets",
          "\\dashv",
          "\\roundimplies",
        ],
        "set-operators": [
          "\\cap",
          "\\cup",
          "\\setminus",
          "\\smallsetminus",
          "\\complement",
        ],
        "set-relations": [
          "\\in",
          "\\notin",
          "\\ni",
          "\\owns",
          "\\subset",
          "\\supset",
          "\\subseteq",
          "\\supseteq",
          "\\subsetneq",
          "\\supsetneq",
          "\\varsubsetneq",
          "\\subsetneqq",
          "\\nsubset",
          "\\nsupset",
          "\\nsubseteq",
          "\\nsupseteq",
        ],
        space: [
          {
            latex: '\\char"203A\\!\\char"2039',
            insert: "\\!",
            aside: "negative thin space<br>⁻³⧸₁₈ em",
          },
          {
            latex: '\\unicode{"203A}\\,\\unicode{"2039}',
            insert: "\\,",
            aside: "thin space<br>³⧸₁₈ em",
          },
          {
            latex: '\\unicode{"203A}\\:\\unicode{"2039}',
            insert: "\\:",
            aside: "medium space<br>⁴⧸₁₈ em",
          },
          {
            latex: '\\unicode{"203A}\\;\\unicode{"2039}',
            insert: "\\;",
            aside: "thick space<br>⁵⧸₁₈ em",
          },
          {
            latex: '\\unicode{"203A}\\ \\unicode{"2039}',
            insert: "\\ ",
            aside: "⅓ em",
          },
          {
            latex: '\\unicode{"203A}\\enspace\\unicode{"2039}',
            insert: "\\enspace",
            aside: "½ em",
          },
          {
            latex: '\\unicode{"203A}\\quad\\unicode{"2039}',
            insert: "\\quad",
            aside: "1 em",
          },
          {
            latex: '\\unicode{"203A}\\qquad\\unicode{"2039}',
            insert: "\\qquad",
            aside: "2 em",
          },
        ],
        delete: [
          {
            label:
              '<span class="warning"><svg><use xlink:href="#svg-trash" /></svg></span>',
            command: '"deleteAll"',
          },
        ],
        "->|": [],
      };
    let os = {};
    const ls = {
      math: "\n        <div class='rows'>\n            <ul>\n                <li class='keycap tex' data-alt-keys='x-var'><i>x</i></li>\n                <li class='keycap tex' data-alt-keys='n-var'><i>n</i></li>\n                <li class='separator w5'></li>\n                <row name='numpad-1'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-insert='$$\\exponentialE$$' data-alt-keys='ee'>e</li>\n                <li class='keycap tex' data-insert='$$\\imaginaryI$$' data-alt-keys='ii'>i</li>\n                <li class='keycap tex' data-latex='\\pi' data-alt-keys='numeric-pi'></li>\n            </ul>\n            <ul>\n                <li class='keycap tex' data-key='<' data-alt-keys='<'>&lt;</li>\n                <li class='keycap tex' data-key='>' data-alt-keys='>'>&gt;</li>\n                <li class='separator w5'></li>\n                <row name='numpad-2'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-alt-keys='x2' data-insert='$$#@^{2}$$'><span><i>x</i>&thinsp;²</span></li>\n                <li class='keycap tex' data-alt-keys='^' data-insert='$$#@^{#?}$$'><span><i>x</i><sup>&thinsp;<small>&#x2b1a;</small></sup></span></li>\n                <li class='keycap tex' data-alt-keys='sqrt' data-insert='$$\\sqrt{#0}$$' data-latex='\\sqrt{#0}'></li>\n            </ul>\n            <ul>\n                <li class='keycap tex' data-alt-keys='(' >(</li>\n                <li class='keycap tex' data-alt-keys=')' >)</li>\n                <li class='separator w5'></li>\n                <row name='numpad-3'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex small' data-alt-keys='int' data-latex='\\int_0^\\infty'><span></span></li>\n                <li class='keycap tex' data-latex='\\forall' data-alt-keys='logic' ></li>\n                <li class='action font-glyph bottom right' data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deletePreviousChar\"]'>&#x232b;</li></ul>\n            </ul>\n            <ul>\n                <li class='keycap' data-alt-keys='foreground-color' data-command='[\"applyStyle\",{\"color\":\"#cc2428\"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'></span></li>\n                <li class='keycap' data-alt-keys='background-color' data-command='[\"applyStyle\",{\"backgroundColor\":\"#fff590\"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>\n                <li class='separator w5'></li>\n                <row name='numpad-4'/>\n                <li class='separator w5'></li>\n                <arrows/>\n            </ul>\n        </div>\n    ",
      "lower-roman":
        "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <row name='lower-1' shift-layer='upper-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <row name='lower-2'  shift-layer='upper-roman''/>\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <row name='lower-3'  shift-layer='upper-roman''/>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='symbols'>&infin;≠</li>\n                <li class='keycap' data-alt-keys=','>,</li>\n                <li class='keycap w50' data-key=' ' data-alt-keys='space'>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
      "upper-roman":
        "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <row name='upper-1'  shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <row name='upper-2' shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <row name='upper-3' shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='symbols'>&infin;≠</li>\n                <li class='keycap' data-alt-keys='.'>;</li>\n                <li class='keycap w50' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
      symbols:
        "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrace '>{</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrace '>}</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-alt-keys='set' data-insert='\\in '>&#x2208;</li>\n                <li class='keycap tex' data-alt-keys='!set' data-insert='\\notin '>&#x2209;</li>\n                <li class='keycap tex' data-insert='\\Re '>&#x211c;<aside>Real</aside></li>\n                <li class='keycap tex' data-insert='\\Im '>&#x2111;<aside>Imaginary</aside></li>\n                <li class='keycap w15' data-insert='\\ulcorner#0\\urcorner '><span><sup>&#x250c;</sup><span><span style='color:#ddd'>o</span><sup>&#x2510;</sup></span><aside>ceil</aside></li>\n                <li class='keycap tex' data-alt-keys='nabla' data-insert='\\nabla '>&#x2207;<aside>nabla</aside></li>\n                <li class='keycap tex' data-alt-keys='infinity' data-insert='\\infty '>&#x221e;</li>\n\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrack '>[</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrack '>]</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-alt-keys='subset' data-insert='\\subset '>&#x2282;</li>\n                <li class='keycap tex' data-alt-keys='supset' data-insert='\\supset '>&#x2283;</li>\n                <li class='keycap tex' data-key='!' data-alt-keys='!'>!<aside>factorial</aside></li>\n                <li class='keycap' data-insert='$$^{\\prime} $$'><span><sup><span><span style='color:#ddd'>o</span>&#x2032</sup></span><aside>prime</aside></li>\n                <li class='keycap w15' data-insert='\\llcorner#0\\lrcorner '><span><sub>&#x2514;</sub><span style='color:#ddd'>o</span><sub>&#x2518;</sub></span><aside>floor</aside></li>\n                <li class='keycap tex' data-insert='\\partial '>&#x2202;<aside>partial<br>derivative</aside></li>\n                <li class='keycap tex' data-insert='\\emptyset '>&#x2205;<aside>empty set</aside></li>\n\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\langle '>&#x27e8;</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rangle '>&#x27e9;</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-insert='\\subseteq '>&#x2286;</li>\n                <li class='keycap tex' data-insert='\\supseteq '>&#x2287;</li>\n                <li class='keycap tex' data-alt-keys='accents' data-insert='$$\\vec{#@}$$' data-latex='\\vec{#?}' data-aside='vector'></li>\n                <li class='keycap tex' data-alt-keys='accents' data-insert='$$\\bar{#@}$$' data-latex='\\bar{#?}' data-aside='bar'></li>\n                <li class='keycap tex' data-alt-keys='absnorm' data-insert='$$\\lvert #@ \\rvert $$' data-latex='\\lvert #? \\rvert' data-aside='abs'></li>\n                <li class='keycap tex' data-insert='\\ast '>&#x2217;<aside>asterisk</aside></li>\n\n                <li class='action font-glyph bottom right w15'\n                    data-shifted='<span class=\"warning\"><svg><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deletePreviousChar\"]'\n                >&#x232b;</li>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='lower-roman'>abc</li>\n                <li class='keycap tex' data-insert='\\cdot '>&#x22c5;<aside>centered dot</aside></li>\n                <li class='keycap tex' data-insert='\\colon '>:<aside>colon</aside></li>\n                <li class='keycap tex' data-insert='\\circ '>&#x2218;<aside>circle</aside></li>\n                <li class='keycap tex' data-insert='\\approx '>&#x2248;<aside>approx.</aside></li>\n                <li class='keycap tex' data-insert='\\ne '>&#x2260;</li>\n                <li class='keycap tex' data-insert='\\pm '>&#x00b1;</li>\n                <arrows/>\n            </ul>\n        </div>",
      "lower-greek":
        "\n        <div class='rows'>\n            <ul><li class='keycap tex' data-insert='\\varphi '><i>&#x03c6;</i><aside>phi var.</aside></li>\n                <li class='keycap tex' data-insert='\\varsigma '><i>&#x03c2;</i><aside>sigma var.</aside></li>\n                <li class='keycap tex' data-insert='\\epsilon '><i>&#x03f5;</i></li>\n                <li class='keycap tex' data-insert='\\rho '><i>&rho;</i></li>\n                <li class='keycap tex' data-insert='\\tau '><i>&tau;</i></li>\n                <li class='keycap tex' data-insert='\\upsilon '><i>&upsilon;</i></li>\n                <li class='keycap tex' data-insert='\\theta '><i>&theta;</i></li>\n                <li class='keycap tex' data-insert='\\iota '><i>&iota;</i></li>\n                <li class='keycap tex' data-insert='\\omicron '>&omicron;</i></li>\n                <li class='keycap tex' data-insert='\\pi '><i>&pi;</i></li>\n            </ul>\n            <ul><li class='keycap tex' data-insert='\\alpha ' data-shifted='&Alpha;' data-shifted-command=''[\"insert\",\"{\\Alpha\"']'><i>&alpha;</i></li>\n                <li class='keycap tex' data-insert='\\sigma '><i>&sigma;</i></li>\n                <li class='keycap tex' data-insert='\\delta '><i>&delta;</i></li>\n                <li class='keycap tex' data-insert='\\phi '><i>&#x03d5;</i></i></li>\n                <li class='keycap tex' data-insert='\\gamma '><i>&gamma;</i></li>\n                <li class='keycap tex' data-insert='\\eta '><i>&eta;</i></li>\n                <li class='keycap tex' data-insert='\\xi '><i>&xi;</i></li>\n                <li class='keycap tex' data-insert='\\kappa '><i>&kappa;</i></li>\n                <li class='keycap tex' data-insert='\\lambda '><i>&lambda;</i></li>\n            </ul>\n            <ul><li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='upper-greek'>&#x21e7;</li>\n                <li class='keycap tex' data-insert='\\zeta '><i>&zeta;</i></li>\n                <li class='keycap tex' data-insert='\\chi '><i>&chi;</i></li>\n                <li class='keycap tex' data-insert='\\psi '><i>&psi;</i></li>\n                <li class='keycap tex' data-insert='\\omega '><i>&omega;</i></li>\n                <li class='keycap tex' data-insert='\\beta '><i>&beta;</i></li>\n                <li class='keycap tex' data-insert='\\nu '><i>&nu;</i></li>\n                <li class='keycap tex' data-insert='\\mu '><i>&mu;</i></li>\n                <li class='action font-glyph bottom right w15'\n                    data-shifted='<span class=\"warning\"><svg><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deletePreviousChar\"]'\n                >&#x232b;</li>\n            </ul>\n            <ul>\n                <li class='keycap ' data-key=' '>&nbsp;</li>\n                <li class='keycap'>,</li>\n                <li class='keycap tex' data-insert='\\varepsilon '><i>&#x03b5;</i><aside>epsilon var.</aside></li>\n                <li class='keycap tex' data-insert='\\vartheta '><i>&#x03d1;</i><aside>theta var.</aside></li>\n                <li class='keycap tex' data-insert='\\varkappa '><i>&#x3f0;</i><aside>kappa var.</aside></li>\n                <li class='keycap tex' data-insert='\\varpi '><i>&#x03d6;<aside>pi var.</aside></i></li>\n                <li class='keycap tex' data-insert='\\varrho '><i>&#x03f1;</i><aside>rho var.</aside></li>\n                <arrows/>\n            </ul>\n        </div>",
      "upper-greek":
        "\n        <div class='rows'>\n            <ul><li class='keycap tex' data-insert='\\Phi '>&Phi;<aside>phi</aside></li>\n                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>\n                <li class='keycap tex' data-insert='E '>&#x0190;<aside>epsilon</aside></li>\n                <li class='keycap tex' data-insert='R '>&#x3A1;<aside>rho</aside></li>\n                <li class='keycap tex' data-insert='T '>&#x3A4;<aside>tau</aside></li>\n                <li class='keycap tex' data-insert='\\Upsilon '>&Upsilon;<aside>upsilon</aside></li>\n                <li class='keycap tex' data-insert='\\Theta '>&Theta;<aside>theta</aside></li>\n                <li class='keycap tex' data-insert='I '>&Iota;<aside>iota</aside></li>\n                <li class='keycap tex' data-insert='O '>&#x039F;<aside>omicron</aside></li>\n                <li class='keycap tex' data-insert='\\Pi '>&Pi;<aside>pi</aside></li></ul>\n            <ul><li class='keycap tex' data-insert='A '>&#x391;<aside>alpha</aside></li>\n                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>\n                <li class='keycap tex' data-insert='\\Delta '>&Delta;<aside>delta</aside></li>\n                <li class='keycap tex' data-insert='\\Phi '>&#x03a6;<aside>phi</aside></li>\n                <li class='keycap tex' data-insert='\\Gamma '>&Gamma;<aside>gamma</aside></li>\n                <li class='keycap tex' data-insert='N '>&Eta;<aside>eta</aside></li>\n                <li class='keycap tex' data-insert='\\Xi '>&Xi;<aside>xi</aside></li>\n                <li class='keycap tex' data-insert='K '>&Kappa;<aside>kappa</aside></li>\n                <li class='keycap tex' data-insert='\\Lambda '>&Lambda;<aside>lambda</aside></li></ul>\n            <ul><li class='shift modifier font-glyph bottom left selected w15 layer-switch' data-layer='lower-greek'>&#x21e7;</li>\n                <li class='keycap tex' data-insert='Z '>&Zeta;<aside>zeta</aside></li>\n                <li class='keycap tex' data-insert='X '>&Chi;<aside>chi</aside></li>\n                <li class='keycap tex' data-insert='\\Psi '>&Psi;<aside>psi</aside></li>\n                <li class='keycap tex' data-insert='\\Omega '>&Omega;<aside>omega</aside></li>\n                <li class='keycap tex' data-insert='B '>&Beta;<aside>beta</aside></li>\n                <li class='keycap tex' data-insert='N '>&Nu;<aside>nu</aside></li>\n                <li class='keycap tex' data-insert='M '>&Mu;<aside>mu</aside></li>\n                <li class='action font-glyph bottom right w15' data-command='[\"performWithFeedback\",\"deletePreviousChar\"]'>&#x232b;</li></ul>\n            <ul>\n                <li class='separator w10'>&nbsp;</li>\n                <li class='keycap'>.</li>\n                <li class='keycap w50' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
      "lower-command":
        "\n        <div class='rows'>\n            <ul><row name='lower-1' class='tt' shift-layer='upper-command'/></ul>\n            <ul><row name='lower-2' class='tt' shift-layer='upper-command'/></ul>\n            <ul><row name='lower-3' class='tt' shift-layer='upper-command'/></ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='symbols-command'>01#</li>\n                <li class='keycap tt' data-shifted='[' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"[\"]'>{</li>\n                <li class='keycap tt' data-shifted=']' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"]\"]'>}</li>\n                <li class='keycap tt' data-shifted='(' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"(\"]'>^</li>\n                <li class='keycap tt' data-shifted=')' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \")\"]'>_</li>\n                <li class='keycap w20' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
      "upper-command":
        "\n        <div class='rows'>\n            <ul><row name='upper-1' class='tt' shift-layer='lower-command'/></ul>\n            <ul><row name='upper-2' class='tt' shift-layer='lower-command'/></ul>\n            <ul><row name='upper-3' class='tt' shift-layer='lower-command'/></ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='symbols-command'01#</li>\n                <li class='keycap tt'>[</li>\n                <li class='keycap tt'>]</li>\n                <li class='keycap tt'>(</li>\n                <li class='keycap tt'>)</li>\n                <li class='keycap w20' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
      "symbols-command":
        "\n        <div class='rows'>\n            <ul><li class='keycap tt'>1</li><li class='keycap tt'>2</li><li class='keycap tt'>3</li><li class='keycap tt'>4</li><li class='keycap tt'>5</li><li class='keycap tt'>6</li><li class='keycap tt'>7</li><li class='keycap tt'>8</li><li class='keycap tt'>9</li><li class='keycap tt'>0</li></ul>\n            <ul><li class='keycap tt'>!</li><li class='keycap tt'>@</li><li class='keycap tt'>#</li><li class='keycap tt'>$</li><li class='keycap tt'>%</li><li class='keycap tt'>^</li><li class='keycap tt'>&</li><li class='keycap tt'>*</li><li class='keycap tt'>+</li><li class='keycap tt'>=</li></ul>\n            <ul>\n                <li class='keycap tt'>\\</li>\n                <li class='keycap tt'>|</li>\n                <li class='keycap tt'>/</li>\n                <li class='keycap tt'>`</li>\n                <li class='keycap tt'>;</li>\n                <li class='keycap tt'>:</li>\n                <li class='keycap tt'>?</li>\n                <li class='keycap tt'>'</li>\n                <li class='keycap tt'>\"</li>\n                <li class='action font-glyph bottom right'\n                    data-shifted='<span class=\"warning\"><svg><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deletePreviousChar\"]'\n                >&#x232b;</li>\n            </ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='lower-command'>abc</li>\n                <li class='keycap tt'>&lt;</li>\n                <li class='keycap tt'>&gt;</li>\n                <li class='keycap tt'>~</li>\n                <li class='keycap tt'>,</li>\n                <li class='keycap tt'>.</li>\n                <li class='keycap' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
      functions:
        "\n        <div class='rows'>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-insert='\\sin'></li>\n                <li class='fnbutton' data-insert='\\sin^{-1}'></li>\n                <li class='fnbutton' data-insert='\\ln'></li>\n                <li class='fnbutton' data-insert='\\exponentialE^{#?}'></li>\n                <li class='bigfnbutton' data-insert='$$\\operatorname{lcm}(#?)$$' data-latex='\\operatorname{lcm}()'></li>\n                <li class='bigfnbutton' data-insert='$$\\operatorname{ceil}(#?)$$' data-latex='\\operatorname{ceil}()'></li>\n                <li class='bigfnbutton' data-insert='$$\\lim_{n\\to\\infty}$$'></li>\n                <li class='bigfnbutton' data-insert='$$\\int$$'></li>\n                <li class='bigfnbutton' data-insert='$$\\operatorname{abs}(#?)$$' data-latex='\\operatorname{abs}()'></li>\n            </ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-insert='\\cos'></li>\n                <li class='fnbutton' data-insert='\\cos^{-1}'></li>\n                <li class='fnbutton' data-insert='\\ln_{10}'></li>\n                <li class='fnbutton' data-insert='$$10^{#?}$$'></li>\n                <li class='bigfnbutton' data-insert='$$\\operatorname{gcd}(#?)$$' data-latex='\\operatorname{gcd}()'></li>\n                <li class='bigfnbutton' data-insert='$$\\operatorname{floor}(#?)$$' data-latex='\\operatorname{floor}()'></li>\n                <li class='bigfnbutton' data-insert='$$\\sum_{n\\mathop=0}^{\\infty}$$'></li>\n                <li class='bigfnbutton' data-insert='$$\\int_{0}^{\\infty}$$'></li>\n                <li class='bigfnbutton' data-insert='$$\\operatorname{sign}(#?)$$' data-latex='\\operatorname{sign}()'></li>\n            </ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-insert='\\tan'></li>\n                <li class='fnbutton' data-insert='\\tan^{-1}'></li>\n                <li class='fnbutton' data-insert='$$\\log_{#?}$$'></li>\n                <li class='fnbutton' data-insert='$$\\sqrt[#?]{#0}$$'></li>\n                <li class='bigfnbutton' data-insert='$$#0 \\mod$$' data-latex='\\mod'></li>\n                <li class='bigfnbutton' data-insert='$$\\operatorname{round}(#?) $$' data-latex='\\operatorname{round}()'></li>\n                <li class='bigfnbutton' data-insert='$$\\prod_{n\\mathop=0}^{\\infty}$$' data-latex='{\\tiny \\prod_{n=0}^{\\infty}}'></li>\n                <li class='bigfnbutton' data-insert='$$\\frac{d #0}{dx}$$'></li>\n                <li class='action font-glyph bottom right' data-command='[\"performWithFeedback\",\"deletePreviousChar\"]'>&#x232b;</li></ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton'>(</li>\n                <li class='fnbutton'>)</li>\n                <li class='fnbutton' data-insert='$$^{#?} $$' data-latex='x^{#?} '></li>\n                <li class='fnbutton' data-insert='$$_{#?} $$' data-latex='x_{#?} '></li>\n                <li class='keycap w20 ' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
      style:
        "\n        <div class='rows'>\n            <ul>\n                <li class='keycap' data-alt-keys='foreground-color' data-command='[\"applyStyle\",{\"color\":\"#cc2428\"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428'></span></li>\n                <li class='keycap' data-alt-keys='background-color' data-command='[\"applyStyle\",{\"backgroundColor\":\"#fff590\"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590'></span></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"size3\"}]' data-latex='\\scriptsize\\text{small}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"size5\"}]' data-latex='\\scriptsize\\text{normal}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"size9\"}]' data-latex='\\huge\\text{big}'></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-latex='\\langle' data-command='[\"insert\", \"\\\\langle\", {\"smartFence\":true}]'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"l\"}]' data-latex='\\fontseries{l}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"m\"}]' data-latex='\\fontseries{m}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"b\"}]' data-latex='\\fontseries{b}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"bx\"}]' data-latex='\\fontseries{bx}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"sb\"}]' data-latex='\\fontseries{sb}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"c\"}]' data-latex='\\fontseries{c}\\text{Ab}'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"up\"}]' data-latex='\\textup{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"it\"}]' data-latex='\\textit{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"sl\"}]' data-latex='\\textsl{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"sc\"}]' data-latex='\\textsc{Ab}'></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-insert='$$\\emph{#?} $$' data-latex='\\text{\\emph{emph}}'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmr\"}]' data-latex='\\textrm{Az}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmtt\"}]' data-latex='\\texttt{Az}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmss\"}]' data-latex='\\textsf{Az}'></li>\n\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"bb\"}]'  data-latex='\\mathbb{AZ}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"scr\"}]'  data-latex='\\mathscr{AZ}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cal\"}]' data-latex='\\mathcal{A1}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"frak\"}]' data-latex='\\mathfrak{Az}'></li>\n            </ul>\n        </div>",

      calculus1:
        "\n        <div class='rows'>\n            <ul>\n                <li class='keycap tex' data-alt-keys='x-var'><i>x</i></li>\n                <li class='keycap tex' data-alt-keys='n-var'><i>a</i></li>\n                <li class='separator w5'></li>\n                <row name='numpad-1'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-insert='\\frac{d}{dx}' data-latex='\\frac{d}{dx}'></li>\n                <li class='keycap tex' data-insert='\\frac{d#?}{dt}' data-latex='\\frac{d#?}{dt}'></li>\n                <li class='keycap tex' data-insert='\\frac{d#?}{d#?}' data-latex='\\frac{d#?}{d#?}'  ></li>\n            </ul>\n            <ul>\n   <li class='keycap tex' data-latex='\\pi' data-alt-keys='numeric-pi'></li>\n                 <li class='keycap tex' data-latex='e^{#?}' data-alt-keys='ee'></li>\n               <li class='separator w5'></li>\n                <row name='numpad-2'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex small' data-latex='\\lim_{x \\to #?}'><span></li>\n                <li class='keycap tex small' data-latex='\\lim_{x \\to \\infty}'></li>\n                <li class='keycap tex small' data-latex='\\lim_{x \\to -\\infty}'></li>\n            </ul>\n            <ul>\n                <li class='keycap tex' data-latex='\\infty'></li>\n                <li class='keycap tex' data-alt-keys='sqrt' data-insert='$$\\sqrt{#0}$$' data-latex='\\sqrt{#0}'></li>                <li class='separator w5'></li>\n                <row name='numpad-3'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex small' data-latex='\\int_{#?}^{#?}}'><span></span></li>\n                <li class='keycap tex small' data-latex='\\int' ></li>\n                <li class='action font-glyph bottom right' data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deletePreviousChar\"]'>&#x232b;</li></ul>\n            </ul>\n            <ul>\n                <li class='keycap tex small' data-latex='\\frac{#?}{#?}' ></li>\n                <li class='keycap tex small' data-latex='#?^#?'> </li></li>\n                <li class='separator w5'></li>\n                <row name='numpad-4'/>\n                <li class='separator w5'></li>\n                <arrows/>\n            </ul>\n        </div>\n    ",
    };

    function cs(t, e, s) {
      const i = ge(
        (t = t.replace(/(^|[^\\])#@/g, "$1#?")),
        "math",
        e,
        s.config.macros
      );
      return H(
        I(
          Gt(
            {
              mathstyle: k.displaystyle,
              macros: s.config.macros,
            },
            i
          ),
          "ML__base"
        ),
        "ML__mathlive"
      ).toMarkup();
    }

    function hs(t, e, s) {
      let i = "<div class='left'>";
      const a = e.replace(/\s+/g, " ").split(" ");
      if (a.length > 1) {
        const e = Object.assign({}, as, t.config.customVirtualKeyboards || {});
        for (const t of a) {
          if (!e[t]) break;
          (i += "<div class='"),
            t === s
              ? (i += "selected ")
              : e[t].command
              ? (i += "action ")
              : (i += "layer-switch "),
            (i += (e[t].classes || "") + "'"),
            e[t].tooltip &&
              ((i += "data-tooltip='" + is(e[t].tooltip) + "' "),
              (i += "data-placement='top' data-delay='1s'")),
            t !== s &&
              (e[t].command && (i += "data-command='\"" + e[t].command + "\"'"),
              e[t].layer && (i += "data-layer='" + e[t].layer + "'")),
            (i += ">" + e[t].label + "</div>");
        }
      }
      return (
        (i += "</div>"),
        (i += `\n        <div class='right'>\n            <div class='action'\n                data-command='"copyToClipboard"'\n                data-tooltip='${is(
          "tooltip.copy to clipboard"
        )}' data-placement='top' data-delay='1s'>\n                <svg><use xlink:href='#svg-copy' /></svg>\n            </div>\n            <div class='action disabled'\n                data-command='"undo"'\n                data-tooltip='${is(
          "tooltip.undo"
        )}' data-placement='top' data-delay='1s'>\n                <svg><use xlink:href='#svg-undo' /></svg>\n            </div>\n            <div class='action disabled'\n                data-command='"redo"'\n                data-tooltip='${is(
          "tooltip.redo"
        )}' data-placement='top' data-delay='1s'>\n                <svg><use xlink:href='#svg-redo' /></svg>\n            </div>\n        </div>\n    `),
        "<div class='keyboard-toolbar' role='toolbar'>" + i + "</div>"
      );
    }

    function ds(t, e, s) {
      for (let i = 0; i < e.length; ++i) {
        const a = e[i];
        a.getAttribute("data-latex")
          ? (a.innerHTML = cs(
              a.getAttribute("data-latex").replace(/&quot;/g, '"'),
              {
                "?": '{\\color{#555}{\\tiny \\char"2B1A}}',
              },
              t
            ))
          : "" === a.innerHTML && a.getAttribute("data-insert")
          ? (a.innerHTML = cs(
              a.getAttribute("data-insert").replace(/&quot;/g, '"'),
              {
                "?": '{\\color{#555}{\\tiny \\char"2B1A}}',
              },
              t
            ))
          : a.getAttribute("data-content") &&
            (a.innerHTML = a
              .getAttribute("data-content")
              .replace(/&quot;/g, '"')),
          a.getAttribute("data-aside") &&
            (a.innerHTML +=
              "<aside>" +
              a.getAttribute("data-aside").replace(/&quot;/g, '"') +
              "</aside>"),
          a.getAttribute("data-classes") &&
            a.classList.add(a.getAttribute("data-classes"));
        let r,
          n = a.getAttribute("data-insert");
        if (
          (n && (n = n.replace(/&quot;/g, '"')),
          n &&
            rs[n] &&
            (a.setAttribute("data-shifted", rs[n].label),
            a.setAttribute(
              "data-shifted-command",
              JSON.stringify(["insertAndUnshiftKeyboardLayer", rs[n].insert])
            )),
          (r = a.getAttribute("data-command")
            ? JSON.parse(a.getAttribute("data-command"))
            : a.getAttribute("data-insert")
            ? [
                "insert",
                a.getAttribute("data-insert"),
                {
                  focus: !0,
                  feedback: !0,
                  mode: "math",
                  format: "auto",
                  resetStyle: !0,
                },
              ]
            : a.getAttribute("data-latex")
            ? [
                "insert",
                a.getAttribute("data-latex"),
                {
                  focus: !0,
                  feedback: !0,
                  mode: "math",
                  format: "auto",
                  resetStyle: !0,
                },
              ]
            : [
                "typedText",
                a.getAttribute("data-key") || a.textContent,
                {
                  focus: !0,
                  feedback: !0,
                  simulateKeystroke: !0,
                },
              ]),
          s && (r = [s, r]),
          a.getAttribute("data-alt-keys"))
        ) {
          const t = os[a.getAttribute("data-alt-keys")];
          t &&
            (r = {
              default: r,
              pressAndHoldStart: [
                "showAlternateKeys",
                a.getAttribute("data-alt-keys"),
                t,
              ],
              pressAndHoldEnd: "hideAlternateKeys",
            });
        }
        t._attachButtonHandlers(a, r);
      }
    }

    function ms(t, e) {
      const s = {
          qwerty: {
            "lower-1": "qwertyuiop",
            "lower-2": " asdfghjkl ",
            "lower-3": "^zxcvbnm~",
            "upper-1": "QWERTYUIOP",
            "upper-2": " ASDFGHJKL ",
            "upper-3": "^ZXCVBNM~",
            "numpad-1": "789/",
            "numpad-2": "456*",
            "numpad-3": "123-",
            "numpad-4": "0.=+",
          },
          azerty: {
            "lower-1": "azertyuiop",
            "lower-2": "qsdfghjklm",
            "lower-3": "^ wxcvbn ~",
            "upper-1": "AZERTYUIOP",
            "upper-2": "QSDFGHJKLM",
            "upper-3": "^ WXCVBN ~",
          },
          qwertz: {
            "lower-1": "qwertzuiop",
            "lower-2": " asdfghjkl ",
            "lower-3": "^yxcvbnm~",
            "upper-1": "QWERTZUIOP",
            "upper-2": " ASDFGHJKL",
            "upper-3": "^YXCVBNM~",
          },
          dvorak: {
            "lower-1": "^  pyfgcrl ",
            "lower-2": "aoeuidhtns",
            "lower-3": "qjkxbmwvz~",
            "upper-1": "^  PYFGCRL ",
            "upper-2": "AOEUIDHTNS",
            "upper-3": "QJKXBMWVZ~",
          },
          colemak: {
            "lower-1": " qwfpgjluy ",
            "lower-2": "arstdhneio",
            "lower-3": "^zxcvbkm~",
            "upper-1": " QWFPGNLUY ",
            "upper-2": "ARSTDHNEIO",
            "upper-3": "^ZXCVBKM~",
          },
        },
        i = s[t.config.virtualKeyboardLayout]
          ? s[t.config.virtualKeyboardLayout]
          : s.qwerty;
      let a,
        r = e;
      r = r.replace(
        /<arrows\/>/g,
        "\n        <li class='action' data-command='[\"performWithFeedback\",\"moveToPreviousChar\"]'\n            data-shifted='<svg><use xlink:href=\"#svg-angle-double-left\" /></svg>'\n            data-shifted-command='[\"performWithFeedback\",\"extendToPreviousChar\"]'>\n            <svg><use xlink:href='#svg-arrow-left' /></svg>\n        </li>\n        <li class='action' data-command='[\"performWithFeedback\",\"moveToNextChar\"]'\n            data-shifted='<svg><use xlink:href=\"#svg-angle-double-right\" /></svg>'\n            data-shifted-command='[\"performWithFeedback\",\"extendToNextChar\"]'>\n            <svg><use xlink:href='#svg-arrow-right' /></svg>\n        </li>\n        <li class='action' data-command='[\"performWithFeedback\",\"moveToNextPlaceholder\"]'>\n        <svg><use xlink:href='#svg-tab' /></svg></li>"
      );
      let n = r.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
      for (; n; ) {
        a = "";
        const t = n[2].match(/[a-zA-Z][a-zA-Z0-9-]*=(['"])(.*?)\1/g),
          e = {};
        for (const s of t) {
          const t = s.match(/([a-zA-Z][a-zA-Z0-9-]*)=(['"])(.*?)\2/);
          e[t[1]] = t[3];
        }
        let o = i[e.name];
        if ((o || (o = s.qwerty[e.name]), o))
          for (const t of o) {
            let s = e.class || "";
            s && (s = " " + s),
              "~" === t
                ? ((a += "<li class='action font-glyph bottom right "),
                  (a +=
                    o.length - (o.match(/ /g) || []).length / 2 == 10
                      ? "w10"
                      : "w15"),
                  (a +=
                    '\' data-shifted=\'<span class="warning"><svg><use xlink:href="#svg-trash" /></svg></span>\'\n                        data-shifted-command=\'"deleteAll"\'\n                        data-alt-keys=\'delete\' data-command=\'["performWithFeedback","deletePreviousChar"]\'\n                        >&#x232b;</li>'))
                : " " === t
                ? (a += "<li class='separator w5'></li>")
                : "^" === t
                ? (a +=
                    "<li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='" +
                    e["shift-layer"] +
                    "'>&#x21e7;</li>")
                : "/" === t
                ? (a +=
                    "<li class='keycap" +
                    s +
                    "' data-alt-keys='/' data-insert='\\frac{#0}{#?}'>&divide;</li>")
                : "*" === t
                ? (a +=
                    "<li class='keycap" +
                    s +
                    "' data-alt-keys='*' data-insert='\\times '>&times;</li>")
                : "-" === t
                ? (a +=
                    "<li class='keycap" +
                    s +
                    "' data-alt-keys='-' data-key='-' data-alt-keys='-'>&#x2212;</li>")
                : /tt/.test(s)
                ? (a +=
                    "<li class='keycap" +
                    s +
                    "' data-alt-keys='" +
                    t +
                    '\' data-command=\'["typedText","' +
                    t +
                    '",{"commandMode":true, "focus":true, "feedback":true}]\'>' +
                    t +
                    "</li>")
                : (a +=
                    "<li class='keycap" +
                    s +
                    "' data-alt-keys='" +
                    t +
                    "'>" +
                    t +
                    "</li>");
          }
        (r = r.replace(new RegExp(n[1] + n[2] + n[3]), a)),
          (n = r.match(/(<row\s+)(.*)((?:<\/row|\/)>)/));
      }
      return r;
    }
    var ps = {
      make: function (t, e) {
        let s =
          '<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n\n            <symbol id="svg-command" viewBox="0 0 640 512">\n                <path d="M34.495 36.465l211.051 211.05c4.686 4.686 4.686 12.284 0 16.971L34.495 475.535c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L205.947 256 10.454 60.506c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.687 12.284-4.687 16.97 0zM640 468v-10c0-6.627-5.373-12-12-12H300c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h328c6.627 0 12-5.373 12-12z"/>\n            </symbol>\n\n            <symbol id="svg-undo" viewBox="0 0 512 512">\n                <path d="M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z"/>\n            </symbol>\n            <symbol id="svg-redo" viewBox="0 0 512 512">\n                <path d="M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z"/>\n            </symbol>\n            <symbol id="svg-arrow-left" viewBox="0 0 192 512">\n                <path d="M25.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L64.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L25 264.5c-4.6-4.7-4.6-12.3.1-17z"/>\n            </symbol>\n            <symbol id="svg-arrow-right" viewBox="0 0 192 512">\n                    <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17z"/>\n            </symbol>\n            <symbol id="svg-tab" viewBox="0 0 448 512">\n                    <path d="M32 217.1c0-8.8 7.2-16 16-16h144v-93.9c0-7.1 8.6-10.7 13.6-5.7l143.5 143.1c6.3 6.3 6.3 16.4 0 22.7L205.6 410.4c-5 5-13.6 1.5-13.6-5.7v-93.9H48c-8.8 0-16-7.2-16-16v-77.7m-32 0v77.7c0 26.5 21.5 48 48 48h112v61.9c0 35.5 43 53.5 68.2 28.3l143.6-143c18.8-18.8 18.8-49.2 0-68L228.2 78.9c-25.1-25.1-68.2-7.3-68.2 28.3v61.9H48c-26.5 0-48 21.6-48 48zM436 64h-8c-6.6 0-12 5.4-12 12v360c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12z"/>\n            </symbol>\n            <symbol id="svg-copy" viewBox="0 0 448 512">\n                <path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM352 32.491a15.88 15.88 0 0 1 7.431 4.195l51.882 51.883A15.885 15.885 0 0 1 415.508 96H352V32.491zM288 464c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V144c0-8.822 7.178-16 16-16h80v240c0 26.51 21.49 48 48 48h112v48zm128-96c0 8.822-7.178 16-16 16H176c-8.822 0-16-7.178-16-16V48c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v240z"/>\n            </symbol>\n            <symbol id="svg-angle-double-right" viewBox="0 0 320 512">\n                <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17zm128-17l-117.8-116c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17L255.3 256 153.1 356.4c-4.7 4.7-4.7 12.3 0 17l7.1 7.1c4.7 4.7 12.3 4.7 17 0l117.8-116c4.6-4.7 4.6-12.3-.1-17z"/>\n            </symbol>\n            <symbol id="svg-angle-double-left" viewBox="0 0 320 512">\n                <path d="M153.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L192.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L153 264.5c-4.6-4.7-4.6-12.3.1-17zm-128 17l117.8 116c4.7 4.7 12.3 4.7 17 0l7.1-7.1c4.7-4.7 4.7-12.3 0-17L64.7 256l102.2-100.4c4.7-4.7 4.7-12.3 0-17l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L25 247.5c-4.6 4.7-4.6 12.3.1 17z"/>\n            </symbol>\n            <symbol id="svg-trash" viewBox="0 0 448 512">\n                <path d="M336 64l-33.6-44.8C293.3 7.1 279.1 0 264 0h-80c-15.1 0-29.3 7.1-38.4 19.2L112 64H24C10.7 64 0 74.7 0 88v2c0 3.3 2.7 6 6 6h26v368c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V96h26c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24h-88zM184 32h80c5 0 9.8 2.4 12.8 6.4L296 64H152l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm200 432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V96h320v368zm-176-44V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm-80 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm160 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12z"/>\n            </symbol>\n        </svg>\n        ';
        ns["foreground-color"] = [];
        for (const t of At)
          ns["foreground-color"].push({
            classes: "small-button",
            content:
              '<span style="border-radius:50%;width:32px;height:32px; box-sizing: border-box; border: 3px solid ' +
              t +
              '"></span>',
            command: '["applyStyle",{"color":"' + t + '"}]',
          });
        ns["background-color"] = [];
        for (const t of Mt)
          ns["background-color"].push({
            classes: "small-button",
            content:
              '<span style="border-radius:50%;width:32px;height:32px; background:' +
              t +
              '"></span>',
            command: '["applyStyle",{"backgroundColor":"' + t + '"}]',
          });
        (os = {
          ...ns,
        }),
          Object.keys(os).forEach((t) => {
            os[t] = os[t].slice();
          });
        const i = "abcdefghijklmnopqrstuvwxyz";
        // for (let t = 0; t < 26; t++) {
        //     const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" [t];
        //     os[e] || (os[e] = []), os[e].unshift({
        //         latex: "\\mathbb{" + e + "}",
        //         aside: "blackboard",
        //         insert: "\\mathbb{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathbf{" + e + "}",
        //         aside: "bold",
        //         insert: "\\mathbf{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathsf{" + e + "}",
        //         aside: "sans",
        //         insert: "\\mathsf{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathtt{" + e + "}",
        //         aside: "monospace",
        //         insert: "\\mathtt{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathcal{" + e + "}",
        //         aside: "script",
        //         insert: "\\mathcal{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathfrak{" + e + "}",
        //         aside: "fraktur",
        //         insert: "\\mathfrak{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathbb{" + i[t] + "}",
        //         aside: "blackboard",
        //         insert: "\\mathbb{" + i[t] + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathbf{" + i[t] + "}",
        //         aside: "bold",
        //         insert: "\\mathbf{" + i[t] + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathsf{" + i[t] + "}",
        //         aside: "sans",
        //         insert: "\\mathsf{" + i[t] + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathcal{" + i[t] + "}",
        //         aside: "script",
        //         insert: "\\mathcal{" + i[t] + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathfrak{" + i[t] + "}",
        //         aside: "fraktur",
        //         insert: "\\mathfrak{" + i[t] + "}"
        //     })
        // }
        // for (let t = 0; t <= 26; t++) {
        //     const e = i[t];
        //     os[e] || (os[e] = []), os[e].unshift({
        //         latex: "\\mathsf{" + e + "}",
        //         aside: "sans",
        //         insert: "\\mathbb{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathbf{" + e + "}",
        //         aside: "bold",
        //         insert: "\\mathbf{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathtt{" + e + "}",
        //         aside: "monospace",
        //         insert: "\\mathtt{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathfrak{" + e + "}",
        //         aside: "fraktur",
        //         insert: "\\mathfrak{" + e + "}"
        //     })
        // }
        // for (let t = 0; t < 10; t++) {
        //     const e = "0123456789" [t];
        //     os[e] || (os[e] = []), os[e].unshift({
        //         latex: "\\mathbf{" + e + "}",
        //         aside: "bold",
        //         insert: "\\mathbf{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathsf{" + e + "}",
        //         aside: "sans",
        //         insert: "\\mathsf{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathtt{" + e + "}",
        //         aside: "monospace",
        //         insert: "\\mathtt{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathcal{" + e + "}",
        //         aside: "script",
        //         insert: "\\mathcal{" + e + "}"
        //     }), os[e].unshift({
        //         latex: "\\mathfrak{" + e + "}",
        //         aside: "fraktur",
        //         insert: "\\mathfrak{" + e + "}"
        //     })
        // }
        let a = t.config.virtualKeyboards;
        a || (a = "all"),
          (a = a.replace(/\ball\b/i, "calculus1 roman greek functions"));
        // a || (a = "all"), a = a.replace(/\ball\b/i, "calculus1 numeric roman greek functions command");
        const r = Object.assign(
            {},
            ls,
            t.config.customVirtualKeyboardLayers || {}
          ),
          n = Object.assign({}, as, t.config.customVirtualKeyboards || {}),
          o = a.replace(/\s+/g, " ").split(" ");
        for (const e of o) {
          if (!n[e]) break;
          let i = n[e].layers || [];
          n[e].layer && i.push(n[e].layer), (i = Array.from(new Set(i)));
          for (const n of i) {
            if (!r[n]) break;
            if ("object" == typeof r[n]) {
              let t = "";
              if (
                (r[n].styles && (t += `<style>${r[n].styles}</style>`),
                r[n].backdrop && (t += `<div class='${r[n].backdrop}'>`),
                r[n].container && (t += `<div class='${r[n].container}'>`),
                r[n].rows)
              ) {
                t += "<div class='rows'>";
                for (const e of r[n].rows) {
                  t += "<ul>";
                  for (const s of e)
                    (t += "<li"),
                      s.class && (t += ` class="${s.class}"`),
                      s.key && (t += ` data-key="${s.key}"`),
                      s.command &&
                        ("string" == typeof s.command
                          ? (t += ` data-command='"${s.command}"'`)
                          : ((t += " data-command='"),
                            (t += JSON.stringify(s.command)),
                            (t += "'"))),
                      s.insert && (t += ` data-insert="${s.insert}"`),
                      s.latex && (t += ` data-latex="${s.latex}"`),
                      s.aside && (t += ` data-aside="${s.aside}"`),
                      s.altKeys && (t += ` data-alt-keys="${s.altKeys}"`),
                      s.shifted && (t += ` data-shifted="${s.shifted}"`),
                      s.shiftedCommand &&
                        (t += ` data-shifted-command="${s.shiftedCommand}"`),
                      (t += `>${s.label ? s.label : ""}</li>`);
                  t += "</ul>";
                }
                (t += "</div>"),
                  r[n].container && (t += "</div'>"),
                  r[n].backdrop && (t += "</div'>");
              }
              r[n] = t;
            }
            (s +=
              "<div tabindex=\"-1\" class='keyboard-layer' data-layer='" +
              n +
              "'>"),
              (s += hs(t, a, e));
            const i = "function" == typeof r[n] ? r[n]() : r[n];
            (s += ms(t, i)), (s += "</div>");
          }
        }
        const l = document.createElement("div");
        (l.className = "ML__keyboard"),
          e
            ? l.classList.add(e)
            : t.config.virtualKeyboardTheme
            ? l.classList.add(t.config.virtualKeyboardTheme)
            : /android|cros/i.test(navigator.userAgent) &&
              l.classList.add("material"),
          (l.innerHTML = s),
          ds(
            t,
            l.querySelectorAll(".keycap, .action, .fnbutton, .bigfnbutton")
          );
        const c = l.getElementsByClassName("layer-switch");
        for (let e = 0; e < c.length; ++e)
          c[e].classList.contains("shift")
            ? t._attachButtonHandlers(c[e], {
                pressed: ["shiftKeyboardLayer", "shift"],
                default: [
                  "switchKeyboardLayer",
                  c[e].getAttribute("data-layer"),
                ],
                pressAndHoldEnd: "unshiftKeyboardLayer",
              })
            : t._attachButtonHandlers(c[e], {
                default: [
                  "switchKeyboardLayer",
                  c[e].getAttribute("data-layer"),
                ],
              });
        const h = l.getElementsByClassName("keyboard-layer");
        return (
          Array.from(h).forEach((t) => {
            t.addEventListener("mousedown", (t) => {
              t.preventDefault(), t.stopPropagation();
            }),
              t.addEventListener("touchstart", (t) => {
                t.preventDefault(), t.stopPropagation();
              });
          }),
          h[0].classList.add("is-visible"),
          window.addEventListener("mouseup", function () {
            t.hideAlternateKeys_(), t.unshiftKeyboardLayer_();
          }),
          window.addEventListener("blur", function () {
            t.hideAlternateKeys_(), t.unshiftKeyboardLayer_();
          }),
          window.addEventListener("touchend", function () {
            t.hideAlternateKeys_(), t.unshiftKeyboardLayer_();
          }),
          window.addEventListener("touchcancel", function () {
            t.hideAlternateKeys_(), t.unshiftKeyboardLayer_();
          }),
          l
        );
      },
      makeKeycap: ds,
    };
    const us = {
        "−": "-",
        "-": "-",
        "\\alpha": "alpha",
        "\\beta": "beta",
        "\\gamma": "gamma",
        "\\delta": "delta",
        "\\epsilon": "epsilon",
        "\\varepsilon": "varepsilon",
        "\\zeta": "zeta",
        "\\eta": "eta",
        "\\theta": "theta",
        "\\vartheta": "vartheta",
        "\\iota": "iota",
        "\\kappa": "kappa",
        "\\lambda": "lambda",
        "\\mu": "mu",
        "\\nu": "nu",
        "\\xi": "xi",
        "\\pi": "pi",
        "\\rho": "rho",
        "\\sigma": "sigma",
        "\\tau": "tau",
        "\\upsilon": "upsilon",
        "\\phi": "phi",
        "\\varphi": "varphi",
        "\\chi": "chi",
        "\\psi": "psi",
        "\\omega": "omega",
        "\\Gamma": "Gamma",
        "\\Delta": "Delta",
        "\\Theta": "Theta",
        "\\Lambda": "Lambda",
        "\\Xi": "Xi",
        "\\Pi": "Pi",
        "\\Sigma": "Sigma",
        "\\Phi": "Phi",
        "\\Psi": "Psi",
        "\\Omega": "Omega",
      },
      fs = {
        "\\pm": "+-",
        "\\times": "xx",
        "\\colon": ":",
        "\\vert": "|",
        "\\Vert": "||",
        "\\mid": "|",
        "\\lbrace": "{",
        "\\rbrace": "}",
        "\\langle": "(:",
        "\\rangle": ":)",
      };

    function gs(t, e) {
      if (!t) return "";
      if (Array.isArray(t)) {
        let e = "";
        if (0 === t.length) return "";
        if (("first" === t[0].type && t.shift(), 0 === t.length)) return "";
        if ("text" === t[0].mode) {
          let s = 0;
          for (e = '"'; t[s] && "text" === t[s].mode; ) (e += t[s].body), s++;
          e += '"' + gs(t.slice(s));
        } else if ("math" === t[0].mode) {
          let s = 0;
          for (; t[s] && "math" === t[s].mode; ) (e += gs(t[s])), s++;
          e += gs(t.slice(s));
        }
        return e.trim();
      }
      if ("text" === t.mode) return '"' + t.body + '"';
      let s = "";
      const i = t.symbol;
      let a;
      switch (t.type) {
        case "group":
        case "root":
          s = gs(t.body);
          break;
        case "array":
          break;
        case "genfrac":
          (t.leftDelim || t.rightDelim) &&
            (s += "." !== t.leftDelim && t.leftDelim ? t.leftDelim : "{:"),
            t.hasBarLine
              ? ((s += "("),
                (s += gs(t.numer)),
                (s += ")/("),
                (s += gs(t.denom)),
                (s += ")"))
              : ((s += "(" + gs(t.numer) + "),"),
                (s += "(" + gs(t.denom) + ")")),
            (t.leftDelim || t.rightDelim) &&
              (s += "." !== t.rightDelim && t.rightDelim ? t.rightDelim : "{:");
          break;
        case "surd":
          t.index
            ? (s += "root(" + gs(t.index) + ")(" + gs(t.body) + ")")
            : (s += "sqrt(" + gs(t.body) + ")");
          break;
        case "leftright":
          (s += "." !== t.leftDelim && t.leftDelim ? t.leftDelim : "{:"),
            (s += gs(t.body)),
            (s += "." !== t.rightDelim && t.rightDelim ? t.rightDelim : "{:");
          break;
        case "sizeddelim":
        case "delim":
        case "accent":
          break;
        case "line":
        case "overlap":
        case "overunder":
          break;
        case "mord":
          (s = us[i] || i || ("string" == typeof t.body ? t.body : "")),
            "\\" === s[0] && (s += ""),
            (a = i ? i.match(/[{]?\\char"([0-9abcdefABCDEF]*)[}]?/) : null),
            a
              ? (s = String.fromCharCode(parseInt("0x" + a[1])))
              : s.length > 0 &&
                "\\" === s.charAt(0) &&
                (s = "string" == typeof t.body ? t.body.charAt(0) : t.symbol);
          break;
        case "mbin":
        case "mrel":
        case "textord":
        case "minner":
          s = i && us[i] ? us[i] : i && fs[i] ? fs[i] : t.body;
          break;
        case "mopen":
        case "mclose":
          s += t.body;
          break;
        case "mpunct":
          s = fs[i] || i;
          break;
        case "mop":
          "​" !== t.body &&
            ((s = ""),
            (s += "\\operatorname" === i ? gs(t.body) : t.body || i),
            (s += " "));
          break;
        case "mathstyle":
        case "box":
        case "spacing":
        case "enclose":
          break;
        case "space":
          s = " ";
      }
      if (t.subscript) {
        s += "_";
        const e = gs(t.subscript);
        e.length > 1 && !/^(-)?\d+(\.\d*)?$/.test(e)
          ? (s += "(" + e + ")")
          : (s += e);
      }
      if (t.superscript) {
        s += "^";
        const e = gs(t.superscript);
        e.length > 1 && !/^(-)?\d+(\.\d*)?$/.test(e)
          ? (s += "(" + e + ")")
          : (s += e);
      }
      return s;
    }
    const ys = {
      "\\pm": "&#177;",
      "\\times": "&#215;",
      "\\colon": ":",
      "\\vert": "|",
      "\\Vert": "∥",
      "\\mid": "∣",
      "\\lbrace": "{",
      "\\rbrace": "}",
      "\\langle": "⟨",
      "\\rangle": "⟩",
      "\\lfloor": "⌊",
      "\\rfloor": "⌋",
      "\\lceil": "⌈",
      "\\rceil": "⌉",
      "\\vec": "&#x20d7;",
      "\\acute": "&#x00b4;",
      "\\grave": "&#x0060;",
      "\\dot": "&#x02d9;",
      "\\ddot": "&#x00a8;",
      "\\tilde": "&#x007e;",
      "\\bar": "&#x00af;",
      "\\breve": "&#x02d8;",
      "\\check": "&#x02c7;",
      "\\hat": "&#x005e;",
    };

    function bs(t) {
      return t
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function xs(t, e) {
      return t && e.generateID ? ' extid="' + t + '"' : "";
    }

    function vs(t, e, s) {
      let i = !1;
      e = e || t.atoms.length;
      let a = "",
        r = "",
        n = -1,
        o = -1;
      const l = t.atoms[t.index];
      if (
        (t.index < e &&
          ("mord" === l.type || "textord" === l.type) &&
          "0123456789,.".indexOf(l.body) < 0 &&
          ((r = l.toMathML(s)),
          l.superscript && (n = t.index),
          l.subscript && (o = t.index),
          (t.index += 1)),
        r.length > 0)
      ) {
        if (
          ((i = !0),
          ks(t) && ((n = t.index), (t.index += 1)),
          ws(t) && ((o = t.index), (t.index += 1)),
          n >= 0 && o >= 0)
        )
          (a = "<msubsup>" + r),
            (a += Ls(t.atoms[o].subscript, 0, 0, s).mathML),
            (a += Ls(t.atoms[n].superscript, 0, 0, s).mathML),
            (a += "</msubsup>");
        else if (n >= 0) {
          if (((a = "<msup>" + r), ks(t))) {
            const e = Ls(t.atoms[n].superscript, 0, 0, s).mathML,
              i = Ls(t.atoms[n + 1].superscript, 0, 0, s).mathML;
            a +=
              ("<mi>′</mi>" !== e && "<mi>&#x2032;</mi>" !== e) ||
              ("<mi>′</mi>" !== i && "<mi>&#x2032;</mi>" !== i)
                ? "<mi>′</mi>" === e || "<mi>&#x2032;</mi>" === e
                  ? "<mi>&#x2032;</mi>"
                  : e
                : "<mi>&#x2033;</mi>";
          } else a += Ls(t.atoms[n].superscript, 0, 0, s).mathML;
          a += "</msup>";
        } else
          o >= 0
            ? ((a = "<msub>" + r),
              (a += Ls(t.atoms[o].subscript, 0, 0, s).mathML),
              (a += "</msub>"))
            : (a = r);
        ("mi" !== t.lastType &&
          "mn" !== t.lastType &&
          "mtext" !== t.lastType &&
          "fence" !== t.lastType) ||
          /^<mo>(.*)<\/mo>$/.test(a) ||
          (a = "<mo>&#8290;</mo>" + a),
          r.endsWith(">f</mi>") || r.endsWith(">g</mi>")
            ? ((a += "<mo>&x2061;</mo>"), (t.lastType = "applyfunction"))
            : (t.lastType = /^<mo>(.*)<\/mo>$/.test(a) ? "mo" : "mi"),
          (t.mathML += a);
      }
      return i;
    }

    function ks(t) {
      return (
        t.index < t.atoms.length &&
        t.atoms[t.index].superscript &&
        "msubsup" === t.atoms[t.index].type
      );
    }

    function ws(t) {
      return (
        t.index < t.atoms.length &&
        t.atoms[t.index].subscript &&
        "msubsup" === t.atoms[t.index].type
      );
    }

    function Ss(t, e, s) {
      let i = !1,
        a = "",
        r = e.atoms[e.index - 1];
      return (
        !!r &&
        (r.superscript ||
          r.subscript ||
          ((ks(e) || ws(e)) && ((r = e.atoms[e.index]), (e.index += 1))),
        !!r &&
          (r.superscript && r.subscript
            ? ((a = "<msubsup>" + t),
              (a += Ls(r.subscript, 0, 0, s).mathML),
              (a += Ls(r.superscript, 0, 0, s).mathML),
              (a += "</msubsup>"))
            : r.superscript
            ? ((a = "<msup>" + t),
              (a += Ls(r.superscript, 0, 0, s).mathML),
              (a += "</msup>"))
            : r.subscript &&
              ((a = "<msub>" + t),
              (a += Ls(r.subscript, 0, 0, s).mathML),
              (a += "</msub>")),
          a.length > 0 && ((i = !0), (e.mathML += a), (e.lastType = "")),
          i))
      );
    }

    function Ms(t, e, s) {
      let i = !1;
      e = e || t.atoms.length;
      const a = t.index;
      let r = "";
      for (; t.index < e && "text" === t.atoms[t.index].mode; )
        (r += t.atoms[t.index].body ? t.atoms[t.index].body : " "),
          (t.index += 1);
      return (
        r.length > 0 &&
          ((i = !0),
          (r = "<mtext" + xs(t.atoms[a].id, s) + ">" + r + "</mtext>"),
          (t.mathML += r),
          (t.lastType = "mtext")),
        i
      );
    }

    function As(t, e, s) {
      let i = !1;
      e = e || t.atoms.length;
      const a = t.index;
      let r = "",
        n = (function (t) {
          let e = -1,
            s = t.index,
            i = !1,
            a = !1;
          for (; s < t.atoms.length && !i && !a; )
            (i =
              "mord" !== t.atoms[s].type ||
              "0123456789,.".indexOf(t.atoms[s].body) < 0),
              (a = !i && t.atoms[s].superscript),
              s++;
          return a && (e = s - 1), e;
        })(t);
      for (
        n >= 0 && n < e && (e = n);
        t.index < e &&
        "mord" === t.atoms[t.index].type &&
        "0123456789,.".indexOf(t.atoms[t.index].body) >= 0;

      )
        (r += t.atoms[t.index].body), (t.index += 1);
      return (
        r.length > 0 &&
          ((i = !0),
          (r = "<mn" + xs(t.atoms[a].id, s) + ">" + r + "</mn>"),
          n < 0 && ks(t) && ((n = t.index), (t.index += 1)),
          n >= 0 &&
            ((r = "<msup>" + r),
            (r += Ls(t.atoms[n].superscript, 0, 0, s).mathML),
            (r += "</msup>")),
          (t.mathML += r),
          (t.lastType = "mn")),
        i
      );
    }

    function _s(t, e, s) {
      let i = !1;
      e = e || t.atoms.length;
      let a = "",
        r = "";
      if (t.index < e && "mopen" === t.atoms[t.index].type) {
        let n = !1,
          o = 0;
        const l = t.index;
        let c = -1,
          h = l + 1;
        for (; h < e && !n; )
          "mopen" === t.atoms[h].type
            ? (o += 1)
            : "mclose" === t.atoms[h].type && (o -= 1),
            -1 === o && ((n = !0), (c = h)),
            (h += 1);
        n &&
          ((a = "<mrow>"),
          (a += zs(t.atoms[l], s)),
          (a += Ls(t.atoms, l + 1, c, s).mathML),
          (a += zs(t.atoms[c], s)),
          (a += "</mrow>"),
          ("mi" !== t.lastType &&
            "mn" !== t.lastType &&
            "mfrac" !== t.lastType &&
            "fence" !== t.lastType) ||
            (a = "<mo>&#8290;</mo>" + a),
          (t.index = c + 1),
          Ss(a, t, s) && ((i = !0), (t.lastType = ""), (a = "")),
          (r = "fence"));
      }
      return a.length > 0 && ((i = !0), (t.mathML += a), (t.lastType = r)), i;
    }

    function Cs(t, e, s) {
      let i = !1;
      e = e || t.atoms.length;
      let a = "",
        r = "";
      const n = t.atoms[t.index];
      if (t.index < e && ("mbin" === n.type || "mrel" === n.type))
        (a += t.atoms[t.index].toMathML(s)), (t.index += 1), (r = "mo");
      else if (t.index < e && "mop" === n.type) {
        if ("limits" === n.limits && (n.superscript || n.subscript)) {
          const t = zs(n, s);
          n.superscript && n.subscript
            ? ((a +=
                ("nolimits" !== n.limits ? "<munderover>" : "<msubsup>") + t),
              (a += Ls(n.subscript, 0, 0, s).mathML),
              (a += Ls(n.superscript, 0, 0, s).mathML),
              (a += "nolimits" !== n.limits ? "</munderover>" : "</msubsup>"))
            : n.superscript
            ? ((a += ("nolimits" !== n.limits ? "<mover>" : "<msup>") + t),
              (a += Ls(n.superscript, 0, 0, s).mathML),
              (a += "nolimits" !== n.limits ? "</mover>" : "</msup>"))
            : ((a += ("nolimits" !== n.limits ? "<munder>" : "<msub>") + t),
              (a += Ls(n.subscript, 0, 0, s).mathML),
              (a += "nolimits" !== n.limits ? "</munder>" : "</msub>")),
            (r = "mo");
        } else {
          const e = t.atoms[t.index],
            n = "\\operatorname" === e.symbol,
            o = n
              ? '<mi class="MathML-Unit"' +
                xs(e.id, s) +
                ">" +
                $s(e.body) +
                "</mi>"
              : zs(e, s);
          (a += o),
            (t.index += 1),
            Ss(a, t, s) && ((i = !0), (t.lastType = ""), (a = "")),
            (t.index -= 1),
            n || /^<mo>(.*)<\/mo>$/.test(o)
              ? (r = n ? "mi" : "mo")
              : ((a += "<mo>&#x2061;</mo>"), (r = "applyfunction"));
        }
        ("mi" !== t.lastType && "mn" !== t.lastType) ||
          /^<mo>(.*)<\/mo>$/.test(a) ||
          (a = "<mo>&#8290;</mo>" + a),
          (t.index += 1);
      }
      return a.length > 0 && ((i = !0), (t.mathML += a), (t.lastType = r)), i;
    }

    function Ls(t, e, s, i) {
      const a = {
        atoms: t,
        index: e || 0,
        mathML: "",
        lastType: "",
      };
      if (
        ((s = s || (t ? t.length : 0)),
        "number" == typeof t || "boolean" == typeof t)
      )
        a.mathML = t.toString();
      else if ("string" == typeof t) a.mathML = t;
      else if (t && "function" == typeof t.toMathML) a.mathML = t.toMathML(i);
      else if (Array.isArray(t)) {
        let t = 0;
        for (; a.index < s; )
          if (
            Ms(a, s, i) ||
            As(a, s, i) ||
            vs(a, s, i) ||
            Cs(a, s, i) ||
            _s(a, s, i)
          )
            t += 1;
          else if (a.index < s) {
            let e = a.atoms[a.index].toMathML(i);
            "mn" === a.lastType &&
              e.length > 0 &&
              "genfrac" === a.atoms[a.index].type &&
              (e = "<mo>&#x2064;</mo>" + e),
              "genfrac" === a.atoms[a.index].type
                ? (a.lastType = "mfrac")
                : (a.lastType = ""),
              e.length > 0 && ((a.mathML += e), (t += 1)),
              (a.index += 1);
          }
        t > 1 && (a.mathML = "<mrow>" + a.mathML + "</mrow>");
      }
      return a;
    }

    function zs(t, e) {
      let s = "";
      const i = $s(t.body);
      return i && (s = "<mo" + xs(t.id, e) + ">" + i + "</mo>"), s;
    }

    function $s(t) {
      if (!t) return "";
      if ("string" == typeof t) return bs(t);
      if (!Array.isArray(t) && "string" == typeof t.body) return bs(t.body);
      let e = "";
      for (const s of t) "string" == typeof s.body && (e += s.body);
      return bs(e);
    }
    (Zt.prototype.toMathML = function (t) {
      const e = {
          widehat: "^",
          widecheck: "ˇ",
          widetilde: "~",
          utilde: "~",
          overleftarrow: "←",
          underleftarrow: "←",
          xleftarrow: "←",
          overrightarrow: "→",
          underrightarrow: "→",
          xrightarrow: "→",
          underbrace: "⏟",
          overbrace: "⏞",
          overgroup: "⏠",
          undergroup: "⏡",
          overleftrightarrow: "↔",
          underleftrightarrow: "↔",
          xleftrightarrow: "↔",
          Overrightarrow: "⇒",
          xRightarrow: "⇒",
          overleftharpoon: "↼",
          xleftharpoonup: "↼",
          overrightharpoon: "⇀",
          xrightharpoonup: "⇀",
          xLeftarrow: "⇐",
          xLeftrightarrow: "⇔",
          xhookleftarrow: "↩",
          xhookrightarrow: "↪",
          xmapsto: "↦",
          xrightharpoondown: "⇁",
          xleftharpoondown: "↽",
          xrightleftharpoons: "⇌",
          xleftrightharpoons: "⇋",
          xtwoheadleftarrow: "↞",
          xtwoheadrightarrow: "↠",
          xlongequal: "=",
          xtofrom: "⇄",
          xrightleftarrows: "⇄",
          xrightequilibrium: "⇌",
          xleftequilibrium: "⇋",
        },
        s = {
          "\\exponentialE": "&#x02147;",
          "\\imaginaryI": "&#x2148;",
          "\\differentialD": "&#x2146;",
          "\\capitalDifferentialD": "&#x2145;",
          "\\alpha": "&#x03b1;",
          "\\pi": "&#x03c0;",
          "\\infty": "&#x221e;",
          "\\forall": "&#x2200;",
          "\\nexists": "&#x2204;",
          "\\exists": "&#x2203;",
          "\\hbar": "ℏ",
          "\\cdotp": "⋅",
          "\\ldots": "…",
          "\\cdots": "⋯",
          "\\ddots": "⋱",
          "\\vdots": "⋮",
          "\\ldotp": ".",
        },
        i = {
          "\\!": -3 / 18,
          "\\ ": 6 / 18,
          "\\,": 3 / 18,
          "\\:": 4 / 18,
          "\\;": 5 / 18,
          "\\enspace": 0.5,
          "\\quad": 1,
          "\\qquad": 2,
          "\\enskip": 0.5,
        };
      let a,
        r,
        n,
        o,
        l,
        c,
        h = "",
        d = "",
        m =
          {
            cal: "script",
            frak: "fraktur",
            bb: "double-struck",
            scr: "script",
            cmtt: "monospace",
            cmss: "sans-serif",
          }[this.fontFamily || this.font] || "";
      m && (m = ' mathvariant="' + m + '"');
      const p = this.symbol;
      if ("text" === this.mode)
        h = "<mi" + xs(this.id, t) + ">" + this.body + "</mi>";
      else
        switch (this.type) {
          case "first":
            break;
          case "group":
          case "root":
            h = Ls(this.body, 0, 0, t).mathML;
            break;
          case "array":
            if (
              (((this.lFence && "." !== this.lFence) ||
                (this.rFence && "." !== this.rFence)) &&
                ((h += "<mrow>"),
                this.lFence &&
                  "." !== this.lFence &&
                  (h += "<mo>" + (ys[this.lFence] || this.lFence) + "</mo>")),
              (h += "<mtable"),
              this.colFormat)
            ) {
              for (h += ' columnalign="', n = 0; n < this.colFormat.length; n++)
                this.colFormat[n].align &&
                  (h +=
                    {
                      l: "left",
                      c: "center",
                      r: "right",
                    }[this.colFormat[n].align] + " ");
              h += '"';
            }
            for (h += ">", r = 0; r < this.array.length; r++) {
              for (h += "<mtr>", a = 0; a < this.array[r].length; a++)
                h += "<mtd>" + Ls(this.array[r][a], 0, 0, t).mathML + "</mtd>";
              h += "</mtr>";
            }
            (h += "</mtable>"),
              ((this.lFence && "." !== this.lFence) ||
                (this.rFence && "." !== this.rFence)) &&
                (this.rFence &&
                  "." !== this.rFence &&
                  (h += "<mo>" + (ys[this.lFence] || this.rFence) + "</mo>"),
                (h += "</mrow>"));
            break;
          case "genfrac":
            (this.leftDelim || this.rightDelim) && (h += "<mrow>"),
              this.leftDelim &&
                "." !== this.leftDelim &&
                (h +=
                  "<mo" +
                  xs(this.id, t) +
                  ">" +
                  (ys[this.leftDelim] || this.leftDelim) +
                  "</mo>"),
              this.hasBarLine
                ? ((h += "<mfrac>"),
                  (h += Ls(this.numer, 0, 0, t).mathML || "<mi>&nbsp;</mi>"),
                  (h += Ls(this.denom, 0, 0, t).mathML || "<mi>&nbsp;</mi>"),
                  (h += "</mfrac>"))
                : ((h += "<mtable" + xs(this.id, t) + ">"),
                  (h += "<mtr>" + Ls(this.numer, 0, 0, t).mathML + "</mtr>"),
                  (h += "<mtr>" + Ls(this.denom, 0, 0, t).mathML + "</mtr>"),
                  (h += "</mtable>")),
              this.rightDelim &&
                "." !== this.rightDelim &&
                (h +=
                  "<mo" +
                  xs(this.id, t) +
                  ">" +
                  (ys[this.rightDelim] || this.rightDelim) +
                  "</mo>"),
              (this.leftDelim || this.rightDelim) && (h += "</mrow>");
            break;
          case "surd":
            this.index
              ? ((h += "<mroot" + xs(this.id, t) + ">"),
                (h += Ls(this.body, 0, 0, t).mathML),
                (h += Ls(this.index, 0, 0, t).mathML),
                (h += "</mroot>"))
              : ((h += "<msqrt" + xs(this.id, t) + ">"),
                (h += Ls(this.body, 0, 0, t).mathML),
                (h += "</msqrt>"));
            break;
          case "leftright":
            (h = "<mrow>"),
              this.leftDelim &&
                "." !== this.leftDelim &&
                (h +=
                  "<mo" +
                  xs(this.id, t) +
                  ">" +
                  (ys[this.leftDelim] || this.leftDelim) +
                  "</mo>"),
              this.body && (h += Ls(this.body, 0, 0, t).mathML),
              this.rightDelim &&
                "." !== this.rightDelim &&
                (h +=
                  "<mo" +
                  xs(this.id, t) +
                  ">" +
                  (ys[this.rightDelim] || this.rightDelim) +
                  "</mo>"),
              (h += "</mrow>");
            break;
          case "sizeddelim":
          case "delim":
            h +=
              '<mo separator="true"' +
              xs(this.id, t) +
              ">" +
              (ys[this.delim] || this.delim) +
              "</mo>";
            break;
          case "accent":
            (h += '<mover accent="true"' + xs(this.id, t) + ">"),
              (h += Ls(this.body, 0, 0, t).mathML),
              (h += "<mo>" + (ys[p] || this.accent) + "</mo>"),
              (h += "</mover>");
            break;
          case "line":
          case "overlap":
            break;
          case "overunder":
            (l = this.overscript),
              (o = this.underscript),
              (this.svgAbove || l) && (this.svgBelow || o)
                ? (c = this.body)
                : l
                ? ((c = this.body),
                  this.body && this.body[0] && this.body[0].underscript
                    ? ((o = this.body[0].underscript), (c = this.body[0].body))
                    : this.body &&
                      this.body[0] &&
                      "first" === this.body[0].type &&
                      this.body[1] &&
                      this.body[1].underscript &&
                      ((o = this.body[1].underscript), (c = this.body[1].body)))
                : o &&
                  ((c = this.body),
                  this.body && this.body[0] && this.body[0].overscript
                    ? ((l = this.body[0].overscript), (c = this.body[0].body))
                    : this.body &&
                      this.body[0] &&
                      "first" === this.body[0].type &&
                      this.body[1] &&
                      this.body[1].overscript &&
                      ((l = this.body[1].overscript), (c = this.body[1].body))),
              (this.svgAbove || l) && (this.svgBelow || o)
                ? ((h += `<munderover ${m} ${xs(this.id, t)}>`),
                  (h += e[this.svgBody] || Ls(c, 0, 0, t).mathML),
                  (h += e[this.svgBelow] || Ls(o, 0, 0, t).mathML),
                  (h += e[this.svgAbove] || Ls(l, 0, 0, t).mathML),
                  (h += "</munderover>"))
                : this.svgAbove || l
                ? ((h +=
                    `<mover ${m} ${xs(this.id, t)}>` +
                    (e[this.svgBody] || Ls(c, 0, 0, t).mathML)),
                  (h += e[this.svgAbove] || Ls(l, 0, 0, t).mathML),
                  (h += "</mover>"))
                : (this.svgBelow || o) &&
                  ((h +=
                    `<munder ${m} ${xs(this.id, t)}>` +
                    (e[this.svgBody] || Ls(c, 0, 0, t).mathML)),
                  (h += e[this.svgBelow] || Ls(o, 0, 0, t).mathML),
                  (h += "</munder>"));
            break;
          case "placeholder":
          case "mord": {
            h = s[p] || p || ("string" == typeof this.body ? this.body : "");
            const e = p ? p.match(/[{]?\\char"([0-9abcdefABCDEF]*)[}]?/) : null;
            e
              ? (h = "&#x" + e[1] + ";")
              : h.length > 0 &&
                "\\" === h.charAt(0) &&
                (h =
                  "string" == typeof this.body && this.body.charCodeAt(0) > 255
                    ? "&#x" +
                      ("000000" + this.body.charCodeAt(0).toString(16)).substr(
                        -4
                      ) +
                      ";"
                    : "string" == typeof this.body
                    ? this.body.charAt(0)
                    : this.body);
            const i = /\d/.test(h) ? "mn" : "mi";
            h = "<" + i + m + xs(this.id, t) + ">" + bs(h) + "</" + i + ">";
            break;
          }
          case "mbin":
          case "mrel":
          case "textord":
          case "minner":
            h =
              p && s[p]
                ? "<mi" + xs(this.id, t) + ">" + s[p] + "</mi>"
                : p && ys[p]
                ? "<mo" + xs(this.id, t) + ">" + ys[p] + "</mo>"
                : zs(this, t);
            break;
          case "mpunct":
            h =
              '<mo separator="true"' +
              xs(this.id, t) +
              ">" +
              (ys[p] || p) +
              "</mo>";
            break;
          case "mop":
            "​" !== this.body &&
              ((h = "<mo" + xs(this.id, t) + ">"),
              (h += "\\operatorname" === p ? this.body : p || this.body),
              (h += "</mo>"));
            break;
          case "mathstyle":
            break;
          case "box":
            (h = '<menclose notation="box"'),
              this.backgroundcolor &&
                (h += ' mathbackground="' + Ct(this.backgroundcolor) + '"'),
              (h +=
                xs(this.id, t) +
                ">" +
                Ls(this.body, 0, 0, t).mathML +
                "</menclose>");
            break;
          case "spacing":
            h += '<mspace width="' + (i[p] || 0) + 'em"/>';
            break;
          case "enclose":
            h = '<menclose notation="';
            for (const t in this.notation)
              Object.prototype.hasOwnProperty.call(this.notation, t) &&
                this.notation[t] &&
                ((h += d + t), (d = " "));
            h +=
              xs(this.id, t) +
              '">' +
              Ls(this.body, 0, 0, t).mathML +
              "</menclose>";
            break;
          case "space":
            h += "&nbsp;";
        }
      return h;
    }),
      (Zt.toMathML = function (t, e) {
        return Ls(t, 0, 0, e).mathML;
      });
    const Ts = {
        "\\imaginaryI": "ⅈ",
        "\\imaginaryJ": "ⅉ",
        "\\pi": "π",
        "\\exponentialE": "ℯ",
        "﹢": "+",
        "＋": "+",
        "−": "-",
        "-": "-",
        "﹣": "-",
        "－": "-",
        "\\times": "*",
        "\\cdot": "*",
        "⨉": "*",
        "️✖": "*",
        "️×": "*",
        ".": "*",
        "÷": "/",
        "⁄": "/",
        "／": "/",
        "!": "factorial",
        "\\mp": "minusplus",
        "\\ne": "!=",
        "\\coloneq": ":=",
        "\\questeq": "?=",
        "\\approx": "approx",
        "\\cong": "congruent",
        "\\sim": "similar",
        "\\equiv": "equiv",
        "\\pm": "plusminus",
        "\\land": "and",
        "\\wedge": "and",
        "\\lor": "or",
        "\\vee": "or",
        "\\oplus": "xor",
        "\\veebar": "xor",
        "\\lnot": "not",
        "\\neg": "not",
        "\\exists": "exists",
        "\\nexists": "!exists",
        "\\forall": "forAll",
        "\\backepsilon": "suchThat",
        "\\therefore": "therefore",
        "\\because": "because",
        "\\nabla": "nabla",
        "\\circ": "circle",
        "\\ominus": "ominus",
        "\\odot": "odot",
        "\\otimes": "otimes",
        "\\zeta": "Zeta",
        "\\Gamma": "Gamma",
        "\\min": "min",
        "\\max": "max",
        "\\mod": "mod",
        "\\lim": "lim",
        "\\sum": "sum",
        "\\prod": "prod",
        "\\int": "integral",
        "\\iint": "integral2",
        "\\iiint": "integral3",
        "\\Re": "Re",
        "\\gothicCapitalR": "Re",
        "\\Im": "Im",
        "\\gothicCapitalI": "Im",
        "\\binom": "nCr",
        "\\partial": "partial",
        "\\differentialD": "differentialD",
        "\\capitalDifferentialD": "capitalDifferentialD",
        "\\Finv": "Finv",
        "\\Game": "Game",
        "\\wp": "wp",
        "\\ast": "ast",
        "\\star": "star",
        "\\asymp": "asymp",
        "\\to": "to",
        "\\gets": "gets",
        "\\in": "elementof",
        "\\notin": "!elementof",
        "\\ni": "ownedby",
        "\\owns": "ownedby",
        "\\subset": "subset",
        "\\supset": "superset",
        "\\complement": "complement",
        "\\rightarrow": "shortLogicalImplies",
        "\\leftarrow": "shortLogicalImpliedBy",
        "\\leftrightarrow": "shortLogicalEquivalent",
        "\\longrightarrow": "logicalImplies",
        "\\longleftarrow": "logicalImpliedBy",
        "\\longleftrightarrow": "logicalEquivalent",
        "\\Rightarrow": "shortImplies",
        "\\Leftarrow": "shortImpliedBy",
        "\\Leftrightarrow": "shortEquivalent",
        "\\implies": "implies",
        "\\Longrightarrow": "implies",
        "\\impliedby": "impliedBy",
        "\\Longleftarrow": "impliedBy",
        "\\iff": "equivalent",
        "\\Longleftrightarrow": "equivalent",
      },
      Ds = {
        "+": "add",
        "*": "multiply",
        "-": "subtract",
        "/": "divide",
        "=": "equal",
        ":=": "assign",
        "!=": "ne",
        "?=": "questeq",
        approx: "approx",
        congruent: "congruent",
        similar: "similar",
        equiv: "equiv",
        "<": "lt",
        ">": "gt",
        "<=": "le",
        ">=": "ge",
        "≤": "le",
        "≥": "ge",
        ">>": "gg",
        "<<": "ll",
        "**": "pow",
        "++": "increment",
        "--": "decrement",
      },
      Fs = {
        equal: "%0 = %1",
        ne: "%0 \\ne %1",
        questeq: "%0 \\questeq %1",
        approx: "%0 \\approx %1",
        congruent: "%0 \\cong %1",
        similar: "%0 \\sim %1",
        equiv: "%0 \\equiv %1",
        assign: "%0 := %1",
        lt: "%0 < %1",
        gt: "%0 > %1",
        le: "%0 \\le %1",
        ge: "%0 \\ge %1",
        sin: "\\sin%_%^ %0",
        cos: "\\cos%_%^ %0",
        tan: "\\tan%_%^ %0",
        cot: "\\cot%_%^ %0",
        sec: "\\sec%_%^ %0",
        csc: "\\csc%_%^ %0",
        sinh: "\\sinh %0",
        cosh: "\\cosh %0",
        tanh: "\\tanh %0",
        csch: "\\csch %0",
        sech: "\\sech %0",
        coth: "\\coth %0",
        arcsin: "\\arcsin %0",
        arccos: "\\arccos %0",
        arctan: "\\arctan %0",
        arccot: "\\arcctg %0",
        arcsec: "\\arcsec %0",
        arccsc: "\\arccsc %0",
        arsinh: "\\arsinh %0",
        arcosh: "\\arcosh %0",
        artanh: "\\artanh %0",
        arcsch: "\\arcsch %0",
        arsech: "\\arsech %0",
        arcoth: "\\arcoth %0",
        ln: "\\ln%_%^ %",
        log: "\\log%_%^ %",
        lg: "\\lg %",
        lb: "\\lb %",
        sum: "\\sum%_%^ %0",
        prod: "\\prod%_%^ %0",
        Zeta: "\\zeta%_%^ %",
        Gamma: "\\Gamma %",
        min: "\\min%_%^ %",
        max: "\\max%_%^ %",
        mod: "\\mod%_%^ %",
        lim: "\\lim%_%^ %",
        binom: "\\binom %",
        nabla: "\\nabla %",
        curl: "\\nabla\\times %0",
        div: "\\nabla\\cdot %0",
        floor: "\\lfloor %0 \\rfloor%_%^",
        ceil: "\\lceil %0 \\rceil%_%^",
        abs: "\\left| %0 \\right|%_%^",
        norm: "\\lVert %0 \\rVert%_%^",
        ucorner: "\\ulcorner %0 \\urcorner%_%^",
        lcorner: "\\llcorner %0 \\lrcorner%_%^",
        angle: "\\langle %0 \\rangle%_%^",
        group: "\\lgroup %0 \\rgroup%_%^",
        moustache: "\\lmoustache %0 \\rmoustache%_%^",
        brace: "\\lbrace %0 \\rbrace%_%^",
        "sqrt[]": "\\sqrt[%^]{%0}",
        sqrt: "\\sqrt{%0}",
        lcm: "\\operatorname{lcm}%",
        gcd: "\\operatorname{gcd}%",
        erf: "\\operatorname{erf}%",
        erfc: "\\operatorname{erfc}%",
        randomReal: "\\operatorname{randomReal}%",
        randomInteger: "\\operatorname{randomInteger}%",
        and: "%0 \\land %1",
        or: "%0 \\lor %1",
        xor: "%0 \\oplus %1",
        not: "%0 \\lnot %1",
        circle: "%0 \\circ %1",
        ast: "%0 \\ast %1",
        star: "%0 \\star %1",
        asymp: "%0 \\asymp %1",
        "/": "\\frac{%0}{%1}",
        Re: "\\Re{%0}",
        Im: "\\Im{%0}",
        factorial: "%0!",
        factorial2: "%0!!",
      },
      qs = {
        degree: 880,
        nabla: 740,
        curl: 740,
        partial: 740,
        differentialD: 740,
        capitalDifferentialD: 740,
        "**": 720,
        odot: 710,
        not: 680,
        div: 660,
        solidus: 660,
        "/": 660,
        setminus: 650,
        "%": 640,
        otimes: 410,
        union: 350,
        intersection: 350,
        "*": 390,
        ast: 390,
        ".": 390,
        oplus: 300,
        ominus: 300,
        "+": 275,
        "-": 275,
        "+-": 275,
        "-+": 275,
        circle: 265,
        circledast: 265,
        circledcirc: 265,
        star: 265,
        "..": 263,
        to: 262,
        in: 262,
        "|": 261,
        congruent: 265,
        equiv: 260,
        "=": 260,
        "!=": 255,
        "?=": 255,
        similar: 250,
        approx: 247,
        "<": 245,
        ">": 243,
        ">=": 242,
        "≥": 242,
        "<=": 241,
        complement: 240,
        subset: 240,
        superset: 240,
        elementof: 240,
        "!elementof": 240,
        exists: 230,
        "!exists": 230,
        forall: 230,
        and: 200,
        xor: 195,
        or: 190,
        suchThat: 110,
        ":": 100,
        assign: 80,
        ":=": 80,
        therefore: 70,
        because: 70,
        shortLogicalImplies: 52,
        shortImplies: 51,
        logicalImplies: 50,
        implies: 49,
        shortLogicalImpliedBy: 48,
        shortImpliedBy: 47,
        logicalImpliedBy: 46,
        impliedBy: 45,
        shortLogicalEquivalent: 44,
        shortEquivalent: 43,
        logicalEquivalent: 42,
        equivalent: 41,
        ",": 40,
        ";": 30,
      };

    function Es(t, e) {
      return Array.isArray(t.arg) ? t.arg[e] : void 0;
    }

    function Ps(t) {
      return (t && qs[t]) || -1;
    }

    function Bs(t) {
      return /=|=>/.test(t) ? "right" : "left";
    }

    function Ks(t) {
      if ("f" === t || "g" === t) return !0;
      const e = Fs[t];
      return !!e && !!/%[^01_^]?/.test(e);
    }

    function Os(t) {
      t = (t || "").trim();
      let e = Ts[t];
      if (!e)
        if (/^\\[^{}]+$/.test(t)) {
          const s = ft(t, "math", {});
          e = (s && s.value) || t.slice(1);
        } else e = t;
      return e;
    }

    function Rs(t) {
      if (!t) return null;
      const e = Os(js(t)),
        s = [Ps(e), Bs(e)];
      return s[0] <= 0 ? null : s;
    }

    function Is(t) {
      return null !== Rs(t);
    }
    const Ns = {
        "\\lfloor\\rfloor": "floor",
        "\\lceil\\rceil": "ceil",
        "\\vert\\vert": "abs",
        "\\lvert\\rvert": "abs",
        "||": "abs",
        "\\Vert\\Vert": "norm",
        "\\lVert\\rVert": "norm",
        "\\ulcorner\\urcorner": "ucorner",
        "\\llcorner\\lrcorner": "lcorner",
        "\\langle\\rangle": "angle",
        "\\lgroup\\rgroup": "group",
        "\\lmoustache\\rmoustache": "moustache",
        "\\lbrace\\rbrace": "brace",
      },
      Hs = {
        "!": "factorial",
        "\\dag": "dagger",
        "\\dagger": "dagger",
        "\\ddagger": "dagger2",
        "\\maltese": "maltese",
        "\\backprime": "backprime",
        "\\backdoubleprime": "backprime2",
        "\\prime": "prime",
        "\\doubleprime": "prime2",
        "\\$": "$",
        "\\%": "%",
        "\\_": "_",
        "\\degree": "degree",
      },
      Ws = {
        "+": "add",
        "-": "add",
        "*": "multiply",
        "=": "equal",
        ",": "list",
        ";": "list2",
        and: "and",
        or: "or",
        xor: "xor",
        union: "union",
        shortLogicalEquivalent: "logicalEquivalent",
        logicalEquivalent: "logicalEquivalent",
        shortEquivalent: "equivalent",
        equivalent: "equivalent",
      },
      Vs = {
        ",": "list",
        ";": "list2",
      };

    function js(t) {
      if ("string" == typeof t) return t;
      if (Array.isArray(t)) {
        let e = "";
        for (const s of t) e += js(s);
        return e;
      }
      if (
        t.symbol &&
        !/^\\math(op|bin|rel|open|punct|ord|inner)/.test(t.symbol)
      )
        return t.symbol;
      if ("leftright" === t.type) return "";
      if ("string" == typeof t.body) return t.body;
      if (Array.isArray(t.body)) {
        let e = "";
        for (const s of t.body) e += js(s);
        return e;
      }
      return "";
    }

    function Us(t) {
      return "string" == typeof t.sym
        ? (function (t) {
            let e = Fs[t];
            if (e)
              return e.replace("%1", "").replace("%0", "").replace("%", "");
            if (t.length > 1) {
              const s = ft("\\" + t, "math");
              !s ||
                (s.fontFamily &&
                  "cmr" !== s.fontFamily &&
                  "ams" !== s.fontFamily) ||
                (e = "\\" + t);
            }
            return e || (e = dt("math", t)), e;
          })(t.sym) || t.sym
        : "";
    }

    function Gs(t) {
      return parseFloat(t.num);
    }

    function Zs(t) {
      return "object" == typeof t && void 0 !== t.num;
    }

    function Xs(t) {
      let e = 0;
      return (
        Zs(t) &&
          (e =
            "object" == typeof t.num
              ? void 0 !== t.num.re
                ? fi(t.num.re)
                : 0
              : parseFloat(t.num)),
        e
      );
    }

    function Ys(t) {
      let e = 0;
      return (
        Zs(t) &&
          "object" == typeof t.num &&
          (e = void 0 !== t.num.im ? fi(t.num.im) : 0),
        e
      );
    }

    function Js(t) {
      return t && void 0 !== t.sup;
    }

    function Qs(t) {
      return t && void 0 !== t.sub;
    }

    function ti(t, e, s) {
      let i = !1;
      const a = t.atoms[t.index];
      return a && a.type === e && (i = void 0 === s || js(a) === s), i;
    }

    function ei(t, ...e) {
      const s = {
        fn: t,
      };
      if (e) {
        const t = [];
        for (const s of e) s && t.push(s);
        t.length > 0 && (s.arg = t);
      }
      return s;
    }

    function si(t) {
      return "number" == typeof t
        ? {
            num: t.toString(),
          }
        : "string" == typeof t || "object" == typeof t
        ? {
            num: t,
          }
        : void 0;
    }

    function ii(t) {
      if (Zs(t)) {
        const e = Xs(t),
          s = Ys(t);
        return (
          0 !== s
            ? (0 !== e && (t.num.re = (-e).toString()),
              (t.num.im = (-s).toString()))
            : (t.num = (-e).toString()),
          t
        );
      }
      return ei("negate", t);
    }

    function ai(t) {
      const e = t.atoms[t.index + 1];
      return e && "msubsup" === e.type;
    }

    function ri(t, e) {
      let s = t.atoms[t.index];
      return (
        !s || (void 0 === s.superscript && void 0 === s.subscript)
          ? (s = null)
          : (t.index += 1),
        s ||
          ((s = t.atoms[t.index + 1]),
          s && "msubsup" === s.type && (s.superscript || s.subscript)
            ? (t.index += 2)
            : (s = null)),
        s
          ? (void 0 !== s.subscript && (t.ast.sub = mi(s.subscript, e)),
            void 0 !== s.superscript &&
              ("msubsup" === s.type
                ? /['\u2032]|\\prime/.test(js(s.superscript))
                  ? ((t.index += 1),
                    (s = t.atoms[t.index + 1]),
                    s &&
                    "msubsup" === s.type &&
                    /['\u2032]|\\prime/.test(js(s.superscript))
                      ? (t.ast.sup = {
                          sym: "″",
                        })
                      : ((t.ast.sup = {
                          sym: "′",
                        }),
                        (t.index -= 1)))
                  : /['\u2033]|\\doubleprime/.test(js(s.superscript))
                  ? (t.ast.sup = {
                      sym: "″",
                    })
                  : t.ast && (t.ast.sup = mi(s.superscript, e))
                : (t.ast.sup = mi(s.superscript, e))))
          : (t.index += 1),
        t
      );
    }

    function ni(t, e) {
      const s = t.ast;
      if (li(t, "!!"))
        return (
          (t.index += 1), (t.ast = ei("factorial2", s)), ni((t = ri(t, e)), e)
        );
      if (li(t, "++"))
        return (
          (t.index += 1), (t.ast = ei("increment", s)), ni((t = ri(t, e)), e)
        );
      if (li(t, "--"))
        return (
          (t.index += 1), (t.ast = ei("decrement", s)), ni((t = ri(t, e)), e)
        );
      const i = t.atoms[t.index];
      return (
        i &&
          i.symbol &&
          Hs[i.symbol] &&
          ((t.ast = ei(Hs[i.symbol], s)), (t = ni((t = ri(t, e)), e))),
        t
      );
    }

    function oi(t, e, s, i) {
      if (
        ((t.index = t.index || 0),
        0 === t.atoms.length || t.index >= t.atoms.length)
      )
        return (t.ast = void 0), t;
      const a = t.minPrec;
      t.minPrec = 0;
      let r = t.atoms[t.index];
      if (e) {
        if ("mopen" === r.type && js(r) === e)
          (t.index += 1),
            (r = (t = hi(t, i)).atoms[t.index]),
            r &&
              "mclose" === r.type &&
              js(r) === s &&
              (ai(t) &&
                (t.ast = {
                  group: t.ast,
                }),
              (t = ni((t = ri(t, i)), i)));
        else if ("textord" === r.type && js(r) === e)
          (t.index += 1),
            (r = (t = hi(t, i)).atoms[t.index]),
            r &&
              "textord" === r.type &&
              js(r) === s &&
              ((t.index += 1), (t = ni((t = ri(t, i)), i)));
        else if ("\\lVert" === e && "textord" === r.type && "|" === r.symbol) {
          if (
            ((r = t.atoms[t.index + 1]),
            r && "textord" === r.type && "|" === r.symbol)
          ) {
            (t.index += 2), (r = (t = hi(t, i)).atoms[t.index]);
            const e = t.atoms[t.index + 1];
            r &&
              "textord" === r.type &&
              "|" === r.symbol &&
              e &&
              "textord" === e.type &&
              "|" === e.symbol &&
              ((t.index += 2), (t = ni((t = ri(t, i)), i)));
          }
        } else if ("sizeddelim" === r.type && r.delim === e)
          (t.index += 1),
            (r = (t = hi(t, i)).atoms[t.index]),
            r &&
              "sizeddelim" === r.type &&
              r.delim === s &&
              ((t.index += 1), (t = ni((t = ri(t, i)), i)));
        else {
          if (
            "leftright" !== r.type ||
            r.leftDelim !== e ||
            ("?" !== r.rightDelim && r.rightDelim !== s)
          )
            return;
          (t.ast = mi(r.body, i)),
            ai(t) &&
              (t.ast = {
                group: t.ast,
              }),
            (t = ni((t = ri(t, i)), i));
        }
        return (t.minPrec = a), t;
      }
      {
        let i = !0;
        if (
          ("mopen" === r.type
            ? ((e = r.symbol), (s = Q[e]))
            : "sizeddelim" === r.type
            ? ((e = r.delim), (s = Q[e]))
            : "leftright" === r.type
            ? ((i = !1),
              (e = r.leftDelim),
              "?" === (s = r.rightDelim) && (s = Q[e]))
            : "textord" === r.type && ((e = r.symbol), (s = Q[e])),
          e && s)
        ) {
          if ("|" === e && "|" === s) {
            const i = t.atoms[t.index + 1];
            i &&
              "textord" === i.type &&
              "|" === i.symbol &&
              ((e = "\\lVert"), (s = "\\rVert"));
          }
          if ((t = oi(t, e, s)))
            return (
              i && (t.index += 1),
              (t.ast = {
                fn: Ns[e + s] || e + s,
                arg: [t.ast],
              }),
              (t.minPrec = a),
              t
            );
        }
      }
    }

    function li(t, e) {
      return (
        (t.index = t.index || 0),
        !(t.atoms.length <= 1 || t.index >= t.atoms.length - 1) &&
          e === js(t.atoms[t.index]) + js(t.atoms[t.index + 1])
      );
    }

    function ci(t) {
      if (
        ((t.index = t.index || 0),
        !(t.atoms.length <= 1 || t.index >= t.atoms.length - 1))
      ) {
        if (!ti(t, "textord", "\\nabla")) {
          const e = t.atoms[t.index].symbol + t.atoms[t.index + 1].symbol,
            s = /^(>=|<=|>>|<<|:=|!=)$/.test(e) ? e : "";
          return s && (t.index += 1), s;
        }
        return (
          (t.index += 1),
          ti(t, "mbin", "\\times")
            ? ((t.index += 1), (t.ast = "curl"), t)
            : ti(t, "mbin", "\\cdot")
            ? ((t.index += 1), (t.ast = "div"), t)
            : void (t.index -= 1)
        );
      }
    }

    function hi(t, e) {
      if (
        ((t.index = t.index || 0),
        (t.ast = void 0),
        0 === t.atoms.length || t.index >= t.atoms.length)
      )
        return t;
      t.minPrec = t.minPrec || 0;
      let s = (function t(e, s) {
          if (
            ((e.index = e.index || 0),
            (e.ast = void 0),
            0 === e.atoms.length || e.index >= e.atoms.length)
          )
            return e;
          let i = e.atoms[e.index];
          if ("text" === i.mode) {
            let t = "";
            for (; e.atoms[e.index] && "text" === e.atoms[e.index].mode; )
              (t += e.atoms[e.index].body), (e.index += 1);
            return (
              (e.ast = {
                text: t,
              }),
              e
            );
          }
          const a = Os(js(i));
          if (ci(e)) e.ast = ei(e.ast, t(e, s).ast);
          else {
            if ("root" === i.type)
              return (e.index = 0), (e.atoms = i.body), t(e, s);
            if ("mbin" === i.type && "-" === a)
              (e.index += 1), ((e = t(e, s)).ast = ii(e.ast));
            else if ("mbin" === i.type && "+" === a)
              (e.index += 1), ((e = t(e, s)).ast = ei("add", e.ast));
            else if ("mord" === i.type && /^[0-9.]$/.test(i.symbol)) {
              let a = "",
                r = !1,
                n = /^[0-9.eEdD]$/;
              for (
                ;
                e.index < e.atoms.length &&
                !r &&
                (ti(e, "spacing") ||
                  ((ti(e, "mord") || ti(e, "mpunct", ",") || ti(e, "mbin")) &&
                    n.test(e.atoms[e.index].symbol)));

              )
                if ("spacing" === e.atoms[e.index].type) e.index += 1;
                else if (
                  void 0 !== e.atoms[e.index].superscript ||
                  void 0 !== e.atoms[e.index].subscript
                )
                  r = !0;
                else {
                  let t = e.atoms[e.index].symbol;
                  "d" === t || "D" === t
                    ? ((t = "e"), (n = /^[0-9+-.]$/))
                    : "e" === t || "E" === t
                    ? ai(e)
                      ? ((t = ""), (e.index -= 1), (r = !0))
                      : ((t = "E"), (n = /^[0-9+-.]$/))
                    : n === /^[0-9+-.]$/ && (n = /^[0-9]$/),
                    (a += "," === t ? "" : t),
                    (e.index += 1);
                }
              if (
                ((e.ast = a ? si(a) : void 0),
                (i = e.atoms[e.index]),
                i && "genfrac" === i.type && !isNaN(e.ast.num))
              ) {
                const i = e.ast;
                (e = t(e, s)).ast = ei("add", i, e.ast);
              }
              if (
                i &&
                "group" === i.type &&
                i.lsymbolatex &&
                i.symbol.startsWith("\\nicefrac")
              ) {
                const i = e.ast;
                (e = t(e, s)).ast = ei("add", i, e.ast);
              }
              i && "msubsup" === i.type && (e = ri(e, s)), (e = ni(e, s));
            } else if ("genfrac" === i.type || "surd" === i.type)
              (e.ast = i.toAST(s)), (e = ni((e = ri(e, s)), s));
            else if ("mord" === i.type || "mbin" === i.type) {
              if (Ks(a) && !Is(i)) {
                e.ast = {
                  fn: a,
                };
                const i = (e = ri(e, s)).ast,
                  r = t(e, s).ast;
                r && /^(list0|list|list2)$/.test(r.fn)
                  ? (i.arg = r.arg)
                  : r && (i.arg = [r]),
                  (e.ast = i);
              } else
                (e.ast = i.toAST(s)),
                  "ⅈ" === e.ast.sym &&
                    (e.ast = si({
                      im: "1",
                    })),
                  (e = ri(e));
              e = ni(e, s);
            } else if ("textord" === i.type) {
              if (!Is(i) && !Q[i.symbol || i.body])
                if (Ks(a)) {
                  e.ast = {
                    fn: a,
                  };
                  const i = (e = ri(e, s)).ast;
                  (e.index += 1),
                    (i.arg = [t(e, s).ast]),
                    (e.ast = i),
                    (e = ni(e, s));
                } else
                  (e.ast = i.toAST(s)),
                    void 0 === i.superscript && (e.index += 1),
                    (e = ni((e = ri(e, s)), s));
            } else if ("mop" === i.type) {
              if (
                (/^\\(mathop|operatorname|operatorname\*)/.test(i.symbol) ||
                  Ks(a)) &&
                !Is(i)
              )
                if (
                  ((e.ast = {
                    fn: /^\\(mathop|operatorname|operatorname\*)/.test(i.symbol)
                      ? js(i.body)
                      : a,
                  }),
                  Js((e = ri(e, s)).ast))
                ) {
                  const i = {
                    sin: "arcsin",
                    cos: "arccos",
                    tan: "arctan",
                    cot: "arccot",
                    sec: "arcsec",
                    csc: "arccsc",
                    sinh: "arsinh",
                    cosh: "arcosh",
                    tanh: "artanh",
                    csch: "arcsch",
                    sech: "arsech",
                    coth: "arcoth",
                  };
                  if (-1 === Gs(e.ast.sup) && i[a])
                    e.ast = ei(i[a], t(e, s).ast);
                  else {
                    const i = e.ast;
                    (i.arg = [t(e, s).ast]), (e.ast = i);
                  }
                } else {
                  const i = e.ast,
                    a = t(e, s).ast;
                  a && /^(list0|list|list2)$/.test(a.fn)
                    ? (i.arg = a.arg)
                    : a && (i.arg = [a]),
                    (e.ast = i);
                }
            } else if ("array" === i.type) (e.index += 1), (e.ast = i.toAST(s));
            else if ("group" === i.type) (e.index += 1), (e.ast = i.toAST(s));
            else {
              if ("mclose" === i.type) return e;
              if ("error" === i.type)
                return (
                  (e.index += 1),
                  (e.ast = {
                    error: i.symbol,
                  }),
                  e
                );
            }
          }
          if (void 0 === e.ast) {
            const t = oi(e, "(", ")", s) || oi(e, null, null, s);
            t
              ? (e = t)
              : Is(i) ||
                ("placeholder" === i.type
                  ? (e.ast = si(0))
                  : ((e.ast = {
                      text: "?",
                    }),
                    (e.ast.error = "Unexpected token '" + i.type + "'"),
                    i.latex
                      ? (e.ast.latex = i.latex)
                      : i.body && i.toLatex && (e.ast.latex = i.toLatex())),
                (e.index += 1));
          }
          if (
            ((i = e.atoms[e.index]),
            i &&
              ("mord" === i.type ||
                "surd" === i.type ||
                "mop" === i.type ||
                "mopen" === i.type ||
                "sizeddelim" === i.type ||
                "leftright" === i.type))
          ) {
            if ("sizeddelim" === i.type)
              for (const t in Q) if (i.delim === Q[t]) return (e.index += 1), e;
            if (
              ("mord" === i.type || "textord" === i.type || "mop" === i.type) &&
              Is(i)
            )
              return e;
            const a = e.ast;
            (e.ast = {}),
              (e = t(e, s)) && e.ast && a
                ? (Ks(a.fn) && void 0 === a.arg) ||
                  (Array.isArray(a.arg) && 0 === a.arg.length)
                  ? "list2" === e.ast.fn || "list" === e.ast.fn
                    ? (e.ast = ei(a.fn, e.ast.arg))
                    : (e.ast = ei("multiply", a, e.ast))
                  : "multiply" === e.ast.fn
                  ? e.ast.arg.unshift(a)
                  : 0 === Ys(a) &&
                    0 !== Xs(a) &&
                    1 === Ys(e.ast) &&
                    0 === Xs(e.ast)
                  ? (e.ast = si({
                      im: Xs(a).toString(),
                    }))
                  : (e.ast = ei("multiply", a, e.ast))
                : (e.ast = a);
          }
          return e;
        })(t, e).ast,
        i = !1;
      const a = t.minPrec;
      for (; !i; ) {
        const r = t.atoms[t.index],
          n = ci(t);
        let o, l;
        if (
          ((i = !r || "text" === r.mode || (!n && !Is(r))),
          i || (([o, l] = n ? [Ps(n), Bs(n)] : Rs(r)), (i = o < a)),
          !i)
        ) {
          const a = n || Os(js(r));
          if (
            ((t.minPrec = "left" === l ? o + 1 : o), (t.index += 1), "|" === a)
          )
            if (
              void 0 !== r.subscript ||
              (t.atoms[t.index] &&
                void 0 !== t.atoms[t.index].subscript &&
                "msubsup" === t.atoms[t.index].type)
            ) {
              t.ast = {};
              const i = ri(t, e).ast.sub;
              if (((s = ei("bind", s)), i && "equal" === i.fn && s.arg))
                s.arg.push(Es(i, 0)), s.arg.push(Es(i, 1));
              else if (i && s.arg && ("list" === i.fn || "list2" === i.fn)) {
                let t = {
                  sym: "x",
                };
                for (let e = 0; e < i.arg.length; e++)
                  "equal" === i.arg[e].fn
                    ? ((t = Es(i.arg[e], 0)),
                      s.arg.push(t),
                      s.arg.push(Es(i.arg[e], 1)))
                    : (s.arg.push(t), s.arg.push(i.arg[e]));
              } else
                i &&
                  (s.arg.push({
                    sym: "x",
                  }),
                  s.arg.push(i));
            } else i = !0;
          else {
            const i = hi(t, e).ast;
            let r = Vs[a];
            r && s && s.fn !== r && (s = ei(r, s)),
              "-" === a
                ? s && s.arg && "add" === s.fn
                  ? void 0 !== i && s.arg.push(ii(i))
                  : (s =
                      s && "subtract" === s.fn
                        ? ei("add", Es(s, 0), ii(Es(s, 1)), ii(i))
                        : !Zs(s) ||
                          Js(s) ||
                          !Zs(i) ||
                          Js(i) ||
                          (void 0 !== i.num.re && "0" !== i.num.re) ||
                          void 0 === i.num.im
                        ? ei("subtract", s, i)
                        : {
                            num: {
                              re: s.num,
                              im: (-parseFloat(i.num.im)).toString(),
                            },
                          })
                : ((r = Ws[a]),
                  "add" === r && s && "subtract" === s.fn
                    ? (s = ei("add", Es(s, 0), ii(Es(s, 1)), i))
                    : r && s && s.fn === r && !Js(s)
                    ? void 0 !== i &&
                      (i.fn === r && !Js(i) && i.arg
                        ? (s.arg = [...s.arg, ...i.arg])
                        : s.arg && s.arg.push(i))
                    : r && i && i.arg && i.fn === r
                    ? (i.arg.unshift(s), (s = i))
                    : (s =
                        "multiply" === r &&
                        Zs(s) &&
                        !Js(s) &&
                        i &&
                        10 === Gs(i) &&
                        Zs(i.sup)
                          ? si(Gs(s) * Math.pow(10, Gs(i.sup)))
                          : "add" === r &&
                            Zs(s) &&
                            !Js(s) &&
                            i &&
                            0 !== Ys(i) &&
                            !Js(i)
                          ? {
                              num: {
                                re: s.num,
                                im: i.num.im,
                              },
                            }
                          : ei(r || Ds[a] || a, s, i)));
          }
        }
      }
      return (t.ast = s), t;
    }

    function di(t) {
      if (!t) return [];
      let e;
      if (Array.isArray(t)) {
        e = [];
        for (const s of t) {
          const t = di(s);
          e = e.concat(t);
        }
      } else {
        if ("spacing" === t.type) return [];
        "first" === t.type || "box" === t.type
          ? (e = di(t.body))
          : (t.body && Array.isArray(t.body) && (t.body = di(t.body)),
            t.superscript &&
              Array.isArray(t.superscript) &&
              (t.superscript = di(t.superscript)),
            t.subscript &&
              Array.isArray(t.subscript) &&
              (t.subscript = di(t.subscript)),
            t.index && Array.isArray(t.index) && (t.index = di(t.index)),
            t.denom && Array.isArray(t.denom) && (t.denom = di(t.denom)),
            t.numer && Array.isArray(t.numer) && (t.numer = di(t.numer)),
            t.array &&
              Array.isArray(t.array) &&
              (t.array = t.array.map((t) => t.map((t) => di(t)))),
            (e = [t]));
      }
      return e;
    }

    function mi(t, e) {
      return (function (t, e) {
        (t.index = t.index || 0), (t.ast = void 0);
        const s = [];
        for (; t.atoms[t.index]; )
          if ("text" === t.atoms[t.index].mode) {
            let e = "";
            for (; t.atoms[t.index] && "text" === t.atoms[t.index].mode; )
              (e += t.atoms[t.index].body), (t.index += 1);
            s.push(ei("text", e));
          } else {
            const i = hi(t, e).ast;
            if (!i) return;
            s.push(i);
          }
        return s.length > 1 ? ei("sequence", ...s) : s[0] || void 0;
      })(
        {
          atoms: di(t),
        },
        e
      );
    }

    function pi(t, ...e) {
      t = t || ".. ";
      let s = "";
      if (e.length > 0) {
        "." !== t[0] && (s += t[0]);
        let i = "";
        for (const a of e) (s += i + a), (i = t[2]);
        "." !== t[1] && (s += t[1]);
      }
      return s;
    }

    function ui(t, e) {
      const s = t.length;
      t = t.substr(0, e.precision - 2);
      for (let s = 0; s < t.length - 16; s++) {
        const i = t.substr(0, s);
        for (let a = 0; a < 17; a++) {
          const r = t.substr(s, a + 1),
            n = Math.floor((t.length - i.length) / r.length);
          if (n > 1 && (i + r.repeat(n + 1)).startsWith(t))
            return "0" === r
              ? i.replace(/(\d{3})/g, "$1" + e.groupSeparator)
              : i.replace(/(\d{3})/g, "$1" + e.groupSeparator) +
                  e.beginRepeatingDigits +
                  r.replace(/(\d{3})/g, "$1" + e.groupSeparator) +
                  e.endRepeatingDigits;
        }
      }
      return (
        s !== t.length && (t += "\\ldots"),
        t.replace(/(\d{3})/g, "$1" + e.groupSeparator)
      );
    }

    function fi(t) {
      return parseFloat(parseFloat(t).toPrecision(15));
    }

    function gi(t, e) {
      let s = "";
      if ("number" == typeof e.precision) {
        if ("number" != typeof t) {
          let s = "",
            i = "";
          if (
            ("-" === t[0]
              ? ((s = "-"), (t = t.substr(1)))
              : "+" === t[0] && (t = t.substr(1)),
            t.indexOf(".") >= 0)
          ) {
            const a = t.match(/(\d*).(\d*)([e|E]([-+]?[0-9]*))?/),
              r = a[1],
              n = a[2].substring(
                0,
                Math.min(e.precision - r.length, a[2].length)
              );
            if (((i = a[4] || ""), "0" === r)) {
              let i = 0;
              for (; "0" === n[i] && i < n.length; ) i += 1;
              let a = "";
              if (i <= 4)
                (a = "0" + e.decimalMarker),
                  (a += n.substr(0, i)),
                  (a += ui(t.substr(a.length), e));
              else if (i + 1 >= e.precision) (a = "0"), (s = "");
              else {
                a = t[i];
                const s = ui(t.substr(i + 1), e);
                s && (a += e.decimalMarker + s);
              }
              "0" !== a &&
                (t.length - 1 > e.precision &&
                  !a.endsWith("}") &&
                  !a.endsWith("\\ldots") &&
                  (a += "\\ldots"),
                i > 4 &&
                  ((a += e.exponentProduct),
                  e.exponentMarker
                    ? (a += e.exponentMarker + (1 - i).toString())
                    : (a += "10^{" + (1 - i).toString() + "}"))),
                (t = a);
            } else {
              t = r.replace(/\B(?=(\d{3})+(?!\d))/g, e.groupSeparator);
              const s = ui(n, e);
              s && (t += e.decimalMarker + s);
            }
          } else if (t.length > e.precision) {
            const s = t.length;
            let i = t[0];
            const a = ui(t.substr(2), e);
            a &&
              ((i += e.decimalMarker + a),
              "}" !== i[i.length - 1] && (i += "\\ldots")),
              "1" !== i ? (i += e.exponentProduct) : (i = ""),
              e.exponentMarker
                ? (i += e.exponentMarker + (s - 2).toString())
                : (i += "10^{" + (s - 2).toString() + "}"),
              (t = i);
          } else t = t.replace(/\B(?=(\d{3})+(?!\d))/g, e.groupSeparator);
          return (
            i &&
              (i = e.exponentMarker
                ? e.exponentMarker + i
                : e.exponentProduct + " 10^{" + i + "}"),
            s + t + i
          );
        }
        t = fi(t);
      }
      if ("engineering" === e.scientificNotation)
        if (0 === t) s = "0";
        else {
          const i = Math.abs(t);
          let a = Math.round(Math.log10(i));
          (a -= a % 3), i < 1e3 && (a = 0);
          let r = i / Math.pow(10, a);
          const n = r.toString().match(/^(.*)\.(.*)$/);
          n && n[1] && n[2] && (r = n[1] + e.decimalMarker + n[2]),
            e.groupSeparator && (r = ui(r.toExponential(), e)),
            (a =
              0 === a
                ? ""
                : e.exponentMarker
                ? e.exponentMarker + a
                : e.exponentProduct + " 10^{" + a + "}"),
            (s = (t < 0 ? "-" : "") + r + a);
        }
      else {
        const i = "string" == typeof t ? t : t.toString();
        let a,
          r,
          n,
          o = i.match(/^(.*)[e|E]([-+]?[0-9]*)$/i);
        (a = i),
          (n = ""),
          o &&
            o[1] &&
            o[2] &&
            ((a = o[1]),
            (r = e.exponentMarker
              ? e.exponentMarker + o[2]
              : e.exponentProduct + " 10^{" + o[2] + "}")),
          (o = a.match(/^(.*)\.(.*)$/)),
          o && o[1] && o[2] && ((a = o[1]), (n = o[2])),
          e.groupSeparator &&
            ((a = a.replace(/\B(?=(\d{3})+(?!\d))/g, e.groupSeparator)),
            (n = ui(n, e))),
          n && (n = e.decimalMarker + n),
          (s = a + n + (r || ""));
      }
      return s;
    }
    (Zt.prototype.toAST = function (t) {
      let e,
        s,
        i,
        a,
        r = {},
        n = "",
        o = {
          "double-struck": "double-struck",
          calligraphic: "script",
          script: "script",
          fraktur: "fraktur",
          "sans-serif": "sans-serif",
          monospace: "monospace",
        }[
          this.variant +
            (this.variantStyle && "up" !== this.variantStyle
              ? "-" + this.variantStyle
              : "")
        ],
        l = "";
      "b" === this.fontSeries && (l += "bold"),
        "it" === this.fontShape && (l += "italic");
      const c = this.symbol;
      switch (this.type) {
        case "root":
        case "group":
          this.symbol && this.symbol.startsWith("\\nicefrac")
            ? ((e = this.symbol.slice(9).match(/({.*}|[^}])({.*}|[^}])/)),
              e
                ? ((s =
                    1 === e[1].length ? e[1] : e[1].substr(1, e[1].length - 2)),
                  (s = ge(s, "math", null, t.macros)),
                  (i =
                    1 === e[2].length ? e[2] : e[2].substr(1, e[2].length - 2)),
                  (i = ge(i, "math", null, t.macros)),
                  (r = ei("divide", mi(s, t), mi(i, t))))
                : (r.fn = "divide"))
            : (r.group = mi(this.body, t));
          break;
        case "genfrac":
          r = ei(
            "divide",
            mi(this.numer, t),
            this.denom && this.denom[0] && "placeholder" === this.denom[0].type
              ? si(1)
              : mi(this.denom, t)
          );
          break;
        case "surd":
          r = this.index
            ? ei(
                "pow",
                mi(this.body, t),
                ei("divide", si(1), mi(this.index, t))
              )
            : ei("sqrt", mi(this.body, t));
          break;
        case "rule":
          break;
        case "line":
        case "overlap":
        case "accent":
        case "overunder":
          break;
        case "mord":
        case "textord":
        case "mbin":
          (e = c ? c.match(/[{]?\\char"([0-9abcdefABCDEF]*)[}]?/) : void 0),
            e
              ? (n = String.fromCodePoint(parseInt(e[1], 16)))
              : ((n = Os(js(this))),
                n.length > 0 &&
                  "\\" === n.charAt(0) &&
                  "string" == typeof this.body &&
                  (n = this.body)),
            (a = ct(n, o, l)
              .replace(/[\\]/g, "\\\\")
              .replace(/["]/g, '\\"')
              .replace(/[\b]/g, "\\b")
              .replace(/[\f]/g, "\\f")
              .replace(/[\n]/g, "\\n")
              .replace(/[\r]/g, "\\r")
              .replace(/[\t]/g, "\\t")),
            a !== n
              ? ((r = {
                  sym: a,
                }),
                (o = "normal"))
              : (r = {
                  sym: n,
                });
          break;
        case "minner":
        case "mop":
          break;
        case "box":
          r = mi(this.body, t);
          break;
        case "enclose":
          break;
        case "array":
          if ("cardinality" === this.env.name)
            r = ei("card", mi(this.array, t));
          else if (/array|matrix|pmatrix|bmatrix/.test(this.env.name)) {
            r = {
              fn: "array",
              args: [],
            };
            for (const e of this.array) r.args.push(e.map((e) => mi(e, t)));
          } else if ("cases" === this.env.name) {
            r = {
              fn: "cases",
              args: [],
            };
            for (const e of this.array)
              if (e[0]) {
                const s = [];
                s.push(mi(e[0], t));
                let i = mi(e[1], t);
                i &&
                  "text" === i.fn &&
                  i.arg &&
                  /^(if|when|for)$/i.test(i.arg[0].trim()) &&
                  (i = i.arg.filter((t) => "string" != typeof t)),
                  s.push(i || {}),
                  r.args.push(s);
              }
          }
          break;
        case "spacing":
        case "space":
        case "mathstyle":
          break;
        default:
          r = void 0;
      }
      return (
        r && o && "normal" !== o && (r.variant = o),
        r && "string" == typeof this.cssClass && (r.class = this.cssClass),
        r && "string" == typeof this.cssId && (r.id = this.cssId),
        r
      );
    }),
      (Zt.toAST = function (t, e) {
        return mi(t, e);
      });
    const yi = {
      "\\alpha": "alpha ",
      "\\mu": "mew ",
      "\\sigma": "sigma ",
      "\\pi": "pie ",
      "\\imaginaryI": "eye ",
      "\\sum": "Summation ",
      "\\prod": "Product ",
      a: '<phoneme alphabet="ipa" ph="eɪ">a</phoneme>',
      A: 'capital <phoneme alphabet="ipa" ph="eɪ">A</phoneme>',
      "+": "plus ",
      "-": "minus ",
      ";": '<break time="150ms"/> semi-colon <break time="150ms"/>',
      ",": '<break time="150ms"/> comma  <break time="150ms"/>',
      "|": '<break time="150ms"/>Vertical bar<break time="150ms"/>',
      "(": '<break time="150ms"/>Open paren. <break time="150ms"/>',
      ")": '<break time="150ms"/> Close paren. <break time="150ms"/>',
      "=": "equals ",
      "<": "is less than ",
      "\\lt": "is less than ",
      "<=": "is less than or equal to ",
      "\\le": "is less than or equal to ",
      "\\gt": "is greater than ",
      ">": "is greater than ",
      "\\ge": "is greater than or equal to ",
      "\\geq": "is greater than or equal to ",
      "\\leq": "is less than or equal to ",
      "!": "factorial ",
      "\\sin": "sine ",
      "\\cos": "cosine ",
      "​": "",
      "−": "minus ",
      ":": '<break time="150ms"/> such that <break time="200ms"/> ',
      "\\colon": '<break time="150ms"/> such that <break time="200ms"/> ',
      "\\hbar": "etch bar ",
      "\\iff": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
      "\\Longleftrightarrow":
        '<break time="200ms"/>if, and only if, <break time="200ms"/>',
      "\\land": "and ",
      "\\lor": "or ",
      "\\neg": "not ",
      "\\div": "divided by ",
      "\\forall": "for all ",
      "\\exists": "there exists ",
      "\\nexists": "there does not exists ",
      "\\in": "element of ",
      "\\N":
        'the set <break time="150ms"/><say-as interpret-as="character">n</say-as>',
      "\\C":
        'the set <break time="150ms"/><say-as interpret-as="character">c</say-as>',
      "\\Z":
        'the set <break time="150ms"/><say-as interpret-as="character">z</say-as>',
      "\\Q":
        'the set <break time="150ms"/><say-as interpret-as="character">q</say-as>',
      "\\infty": "infinity ",
      "\\nabla": "nabla ",
      "\\partial": "partial derivative of ",
      "\\cdots": "dot dot dot ",
      "\\Rightarrow": "implies ",
      "\\lbrace": '<break time="150ms"/>open brace<break time="150ms"/>',
      "\\{": '<break time="150ms"/>open brace<break time="150ms"/>',
      "\\rbrace": '<break time="150ms"/>close brace<break time="150ms"/>',
      "\\}": '<break time="150ms"/>close brace<break time="150ms"/>',
      "\\langle":
        '<break time="150ms"/>left angle bracket<break time="150ms"/>',
      "\\rangle":
        '<break time="150ms"/>right angle bracket<break time="150ms"/>',
      "\\lfloor": '<break time="150ms"/>open floor<break time="150ms"/>',
      "\\rfloor": '<break time="150ms"/>close floor<break time="150ms"/>',
      "\\lceil": '<break time="150ms"/>open ceiling<break time="150ms"/>',
      "\\rceil": '<break time="150ms"/>close ceiling<break time="150ms"/>',
      "\\vert": '<break time="150ms"/>vertical bar<break time="150ms"/>',
      "\\mvert": '<break time="150ms"/>divides<break time="150ms"/>',
      "\\lvert": '<break time="150ms"/>left vertical bar<break time="150ms"/>',
      "\\rvert": '<break time="150ms"/>right vertical bar<break time="150ms"/>',
      "\\lbrack":
        '<break time="150ms"/> open square bracket <break time="150ms"/>',
      "\\rbrack":
        '<break time="150ms"/> close square bracket <break time="150ms"/>',
      mm: "millimeters",
      cm: "centimeters",
      km: "kilometers",
      kg: "kilograms",
    };

    function bi(t) {
      let e = 0;
      if (t && Array.isArray(t))
        for (const s of t) "first" !== s.type && (e += 1);
      return 1 === e;
    }

    function xi(t) {
      let e = "";
      if (t && Array.isArray(t))
        for (const s of t)
          "first" !== s.type && "string" == typeof s.body && (e += s.body);
      return e;
    }

    function vi(t, e, s, i) {
      e = e.split(" ");
      for (const a of e) {
        const e = a.match(/(.*):(.*)/);
        if (e) {
          const a = i || {};
          "active" === e[2] ? (a.passive = !1) : (a[e[2]] = !0),
            t.addEventListener(e[1], s, a);
        } else t.addEventListener(a, s, i);
      }
    }

    function ki(t, e, s, i) {
      e = e.split(" ");
      for (const a of e) {
        const e = a.match(/(.*):(.*)/);
        if (e) {
          const a = i || {};
          "active" === e[2] ? (a.passive = !1) : (a[e[2]] = !0),
            t.removeEventListener(e[1], s, a);
        } else t.removeEventListener(a, s, i);
      }
    }

    function wi(t, e) {
      let s = document.getElementById(t);
      return (
        s
          ? s.setAttribute(
              "data-refcount",
              parseInt(s.getAttribute("data-refcount")) + 1
            )
          : ((s = document.createElement("div")),
            s.setAttribute("aria-hidden", "true"),
            s.setAttribute("data-refcount", "1"),
            (s.className = e),
            (s.id = t),
            document.body.appendChild(s)),
        s
      );
    }

    function Si(t) {
      if (!t) return null;
      const e = parseInt(t.getAttribute("data-refcount"));
      return (
        e && 1 !== e ? t.setAttribute("data-refcount", e - 1) : t.remove(), t
      );
    }

    function Mi(t) {
      return t.element && t.element.mathfield === t;
    }
    (Zt.toSpeakableFragment = function (t, e) {
      function s(t) {
        return "<emphasis>" + t + "</emphasis>";
      }
      if (!t) return "";
      let i = "";
      if (
        (t.id &&
          "math" === e.speechMode &&
          (i += '<mark name="' + t.id.toString() + '"/>'),
        Array.isArray(t))
      ) {
        let a = !1,
          r = !1;
        for (let n = 0; n < t.length; n++)
          "text" !== t[n].mode && (r = !1),
            n < t.length - 2 &&
            "mopen" === t[n].type &&
            "mclose" === t[n + 2].type &&
            "mord" === t[n + 1].type
              ? ((i += " of "),
                (i += s(Zt.toSpeakableFragment(t[n + 1], e))),
                (n += 2))
              : "text" === t[n].mode
              ? r
                ? (i += t[n].body ? t[n].body : " ")
                : ((r = !0), (i += Zt.toSpeakableFragment(t[n], e)))
              : "mord" === t[n].type && /[0123456789,.]/.test(t[n].body)
              ? a
                ? (i += t[n].body)
                : ((a = !0), (i += Zt.toSpeakableFragment(t[n], e)))
              : ((a = !1), (i += Zt.toSpeakableFragment(t[n], e)));
      } else if ("text" === t.mode) i += t.body;
      else {
        let a = "",
          r = "",
          n = "",
          o = !1;
        switch (t.type) {
          case "group":
          case "root":
            i += Zt.toSpeakableFragment(t.body, e);
            break;
          case "genfrac":
            if (
              ((a = Zt.toSpeakableFragment(t.numer, e)),
              (r = Zt.toSpeakableFragment(t.denom, e)),
              bi(t.numer) && bi(t.denom))
            ) {
              const e = {
                "1/2": " half ",
                "1/3": " one third ",
                "2/3": " two third",
                "1/4": " one quarter ",
                "3/4": " three quarter ",
                "1/5": " one fifth ",
                "2/5": " two fifths ",
                "3/5": " three fifths ",
                "4/5": " four fifths ",
                "1/6": " one sixth ",
                "5/6": " five sixths ",
                "1/8": " one eight ",
                "3/8": " three eights ",
                "5/8": " five eights ",
                "7/8": " seven eights ",
                "1/9": " one ninth ",
                "2/9": " two ninths ",
                "4/9": " four ninths ",
                "5/9": " five ninths ",
                "7/9": " seven ninths ",
                "8/9": " eight ninths ",
              }[xi(t.numer) + "/" + xi(t.denom)];
              e ? (i = e) : (i += a + " over " + r);
            } else
              i +=
                ' the fraction <break time="150ms"/>' +
                a +
                ', over <break time="150ms"/>' +
                r +
                '.<break time="150ms"/> End fraction.<break time="150ms"/>';
            break;
          case "surd":
            if (((n = Zt.toSpeakableFragment(t.body, e)), t.index)) {
              let s = Zt.toSpeakableFragment(t.index, e);
              s = s.trim();
              const a = s.replace(/<mark([^/]*)\/>/g, "");
              i +=
                "3" === a
                  ? ' the cube root of <break time="200ms"/>' +
                    n +
                    '. <break time="200ms"/> End cube root'
                  : "n" === a
                  ? ' the nth root of <break time="200ms"/>' +
                    n +
                    '. <break time="200ms"/> End root'
                  : ' the root with index: <break time="200ms"/>' +
                    s +
                    ', of <break time="200ms"/>' +
                    n +
                    '. <break time="200ms"/> End root';
            } else
              bi(t.body)
                ? (i += " the square root of " + n + " , ")
                : (i +=
                    ' the square root of <break time="200ms"/>' +
                    n +
                    '. <break time="200ms"/> End square root');
            break;
          case "accent":
            break;
          case "leftright":
            (i += yi[t.leftDelim] || t.leftDelim),
              (i += Zt.toSpeakableFragment(t.body, e)),
              (i += yi[t.rightDelim] || t.rightDelim);
            break;
          case "line":
          case "rule":
          case "overunder":
          case "overlap":
            break;
          case "placeholder":
            i += "placeholder " + t.body;
            break;
          case "delim":
          case "sizeddelim":
          case "mord":
          case "minner":
          case "mbin":
          case "mrel":
          case "mpunct":
          case "mopen":
          case "mclose":
          case "textord": {
            const s = t.symbol;
            if (
              "\\mathbin" === s ||
              "\\mathrel" === s ||
              "\\mathopen" === s ||
              "\\mathclose" === s ||
              "\\mathpunct" === s ||
              "\\mathord" === s ||
              "\\mathinner" === s
            ) {
              i = Zt.toSpeakableFragment(t.body, e);
              break;
            }
            let a = t.body,
              r = t.symbol;
            if (
              (("delim" !== t.type && "sizeddelim" !== t.type) ||
                (a = r = t.delim),
              "text" === e.speechMode)
            )
              i += a;
            else {
              if (("mbin" === t.type && (i += '<break time="150ms"/>'), a)) {
                const t = yi[a] || (r ? yi[r.trim()] : "");
                if (t) i += " " + t;
                else {
                  const t = r
                    ? (function (t) {
                        let e = ss.NOTES[t];
                        return (
                          e ||
                            "\\" !== t.charAt(0) ||
                            (e = " " + t.replace("\\", "") + " "),
                          Array.isArray(e) && (e = e[0]),
                          e
                        );
                      })(r.trim())
                    : "";
                  i +=
                    t ||
                    (function (t) {
                      let s = "";
                      return (
                        e.textToSpeechMarkup
                          ? /[a-z]/.test(t)
                            ? (s +=
                                ' <say-as interpret-as="character">' +
                                t +
                                "</say-as>")
                            : /[A-Z]/.test(t)
                            ? (s += "capital " + t.toLowerCase())
                            : (s += t)
                          : /[a-z]/.test(t)
                          ? (s += " '" + t.toUpperCase() + "'")
                          : /[A-Z]/.test(t)
                          ? (s += " 'capital " + t.toUpperCase() + "'")
                          : (s += t),
                        s
                      );
                    })(a);
                }
              } else i += Zt.toSpeakableFragment(t.body, e);
              "mbin" === t.type && (i += '<break time="150ms"/>');
            }
            break;
          }
          case "mop":
            if ("​" !== t.body) {
              const a = t.symbol;
              if ("\\sum" === a)
                if (t.superscript && t.subscript) {
                  let s = Zt.toSpeakableFragment(t.superscript, e);
                  s = s.trim();
                  let a = Zt.toSpeakableFragment(t.subscript, e);
                  (a = a.trim()),
                    (i +=
                      ' the summation from <break time="200ms"/>' +
                      a +
                      '<break time="200ms"/> to  <break time="200ms"/>' +
                      s +
                      '<break time="200ms"/> of <break time="150ms"/>'),
                    (o = !0);
                } else if (t.subscript) {
                  let s = Zt.toSpeakableFragment(t.subscript, e);
                  (s = s.trim()),
                    (i +=
                      ' the summation from <break time="200ms"/>' +
                      s +
                      '<break time="200ms"/> of <break time="150ms"/>'),
                    (o = !0);
                } else i += " the summation of";
              else if ("\\prod" === a)
                if (t.superscript && t.subscript) {
                  let s = Zt.toSpeakableFragment(t.superscript, e);
                  s = s.trim();
                  let a = Zt.toSpeakableFragment(t.subscript, e);
                  (a = a.trim()),
                    (i +=
                      ' the product from <break time="200ms"/>' +
                      a +
                      '<break time="200ms"/> to <break time="200ms"/>' +
                      s +
                      '<break time="200ms"/> of <break time="150ms"/>'),
                    (o = !0);
                } else if (t.subscript) {
                  let s = Zt.toSpeakableFragment(t.subscript, e);
                  (s = s.trim()),
                    (i +=
                      ' the product from <break time="200ms"/>' +
                      s +
                      '<break time="200ms"/> of <break time="150ms"/>'),
                    (o = !0);
                } else i += " the product  of ";
              else if ("\\int" === a)
                if (t.superscript && t.subscript) {
                  let a = Zt.toSpeakableFragment(t.superscript, e);
                  a = a.trim();
                  let r = Zt.toSpeakableFragment(t.subscript, e);
                  (r = r.trim()),
                    (i +=
                      ' the integral from <break time="200ms"/>' +
                      s(r) +
                      '<break time="200ms"/> to <break time="200ms"/>' +
                      s(a) +
                      ' <break time="200ms"/> of '),
                    (o = !0);
                } else i += ' the integral of <break time="200ms"/> ';
              else if ("string" == typeof t.body) {
                i += yi[t.body] || yi[t.symbol] || " " + t.body;
              } else
                t.symbol &&
                  ("\\" === t.symbol[0]
                    ? (i += " " + t.symbol.substr(1))
                    : (i += " " + t.symbol));
            }
            break;
          case "enclose":
            (n = Zt.toSpeakableFragment(t.body, e)),
              bi(t.body)
                ? (i += " crossed out " + n + " , ")
                : (i += " crossed out " + n + ". End cross out");
        }
        if (!o && t.superscript) {
          let s = Zt.toSpeakableFragment(t.superscript, e);
          s = s.trim();
          const a = s.replace(/<[^>]*>/g, "");
          if (bi(t.superscript)) {
            if ("math" === e.speechMode) {
              const e = (function (t) {
                if (t && Array.isArray(t))
                  for (const e of t)
                    if ("first" !== e.type && e.id) return e.id.toString();
                return "";
              })(t.superscript);
              e && (i += '<mark name="' + e + '"/>');
            }
            "′" === a
              ? (i += " prime ")
              : "2" === a
              ? (i += " squared ")
              : "3" === a
              ? (i += " cubed ")
              : isNaN(parseInt(a))
              ? (i += " to the " + s + "; ")
              : (i +=
                  ' to the <say-as interpret-as="ordinal">' +
                  a +
                  "</say-as> power; ");
          } else
            isNaN(parseInt(a))
              ? (i += " raised to the " + s + "; ")
              : (i +=
                  ' raised to the <say-as interpret-as="ordinal">' +
                  a +
                  "</say-as> power; ");
        }
        if (!o && t.subscript) {
          let s = Zt.toSpeakableFragment(t.subscript, e);
          (s = s.trim()),
            bi(t.subscript)
              ? (i += " sub " + s)
              : (i += " subscript " + s + ". End subscript. ");
        }
      }
      return i;
    }),
      (Zt.toSpeakableText = function (t, e) {
        const s = e
          ? JSON.parse(JSON.stringify(e))
          : {
              textToSpeechMarkup: "",
              textToSpeechRules: "mathlive",
            };
        if (
          ((s.speechMode = "math"), window.sre && "sre" === s.textToSpeechRules)
        ) {
          s.atomIdsSettings = {
            seed: "random",
          };
          const e = Zt.toMathML(t, s);
          return e
            ? (s.textToSpeechMarkup &&
                ((s.textToSpeechRulesOptions =
                  s.textToSpeechRulesOptions || {}),
                (s.textToSpeechRulesOptions.markup = s.textToSpeechMarkup),
                "ssml" === s.textToSpeechRulesOptions.markup &&
                  (s.textToSpeechRulesOptions.markup = "ssml_step"),
                (s.textToSpeechRulesOptions.rate = s.speechEngineRate)),
              s.textToSpeechRulesOptions &&
                window.sre.System.getInstance().setupEngine(
                  s.textToSpeechRulesOptions
                ),
              window.sre.System.getInstance().toSpeech(e))
            : "";
        }
        let i = Zt.toSpeakableFragment(t, s);
        if ("ssml" === s.textToSpeechMarkup) {
          let t = "";
          s.speechEngineRate &&
            (t = '<prosody rate="' + s.speechEngineRate + '">'),
            (i =
              '<?xml version="1.0"?><speak version="1.1" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><amazon:auto-breaths>' +
              t +
              "<p><s>" +
              i +
              "</s></p>" +
              (t ? "</prosody>" : "") +
              "</amazon:auto-breaths></speak>");
        } else
          i =
            "mac" === s.textToSpeechMarkup &&
            "mac" ===
              (function (t) {
                let e = "other";
                return (
                  navigator &&
                    navigator.platform &&
                    navigator.userAgent &&
                    (/^(mac)/i.test(navigator.platform)
                      ? (e = "mac")
                      : /^(win)/i.test(navigator.platform)
                      ? (e = "win")
                      : /(android)/i.test(navigator.userAgent)
                      ? (e = "android")
                      : /(iphone)/i.test(navigator.userAgent) ||
                        /(ipod)/i.test(navigator.userAgent) ||
                        /(ipad)/i.test(navigator.userAgent)
                      ? (e = "ios")
                      : /\bCrOS\b/i.test(navigator.userAgent) &&
                        (e = "chromeos")),
                  e === t ? t : "!" + t
                );
              })("mac")
              ? i
                  .replace(/<mark([^/]*)\/>/g, "")
                  .replace(/<emphasis>/g, "[[emph+]]")
                  .replace(/<\/emphasis>/g, "")
                  .replace(/<break time="([0-9]*)ms"\/>/g, "[[slc $1]]")
                  .replace(/<say-as[^>]*>/g, "")
                  .replace(/<\/say-as>/g, "")
              : i.replace(/<[^>]*>/g, "").replace(/\s{2,}/g, " ");
        return i;
      });
    let Ai,
      _i = 0;
    class Ci {
      constructor(t, e) {
        this.$setConfig(e || {}),
          (this.element = t),
          (t.mathfield = this),
          (this.originalContent = t.innerHTML);
        let s = this.element.textContent;
        s && (s = s.trim());
        let i = "";
        this.config.substituteTextArea
          ? "string" == typeof this.config.substituteTextArea
            ? (i += this.config.substituteTextArea)
            : (i += "<span></span>")
          : /android|ipad|ipod|iphone/i.test(navigator.userAgent)
          ? (i +=
              "<span class='ML__textarea'>\n                <span class='ML__textarea__textarea'\n                    tabindex=\"0\" role=\"textbox\"\n                    style='display:inline-block;height:1px;width:1px' >\n                </span>\n            </span>")
          : (i +=
              '<span class="ML__textarea"><textarea class="ML__textarea__textarea" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" aria-hidden="true" tabindex="0"></textarea></span>'),
          (i +=
            '<span class="ML__fieldcontainer"><span class="ML__fieldcontainer__field"></span>'),
          this.config.virtualKeyboardMode ||
            (this.config.virtualKeyboardMode =
              window.matchMedia &&
              window.matchMedia("(any-pointer: coarse)").matches
                ? "onfocus"
                : "off"),
          "manual" === this.config.virtualKeyboardMode
            ? ((i += `<button class="ML__virtual-keyboard-toggle" data-tooltip="${is(
                "tooltip.toggle virtual keyboard"
              )}">`),
              this.config.virtualKeyboardToggleGlyph
                ? (i += this.config.virtualKeyboardToggleGlyph)
                : (i +=
                    '<span style="width: 21px; margin-top: 4px;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M528 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h480c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.823-7.177 16-16 16H48c-8.823 0-16-7.177-16-16V112c0-8.823 7.177-16 16-16h480c8.823 0 16 7.177 16 16v288zM168 268v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-336 80v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm384 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zM120 188v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-96 152v-8c0-6.627-5.373-12-12-12H180c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h216c6.627 0 12-5.373 12-12z"/></svg></span>'),
              (i += "</button>"))
            : (i += "<span ></span>"),
          (i += "</span>"),
          (i +=
            '\n        <div class="sr-only">\n            <span aria-live="assertive" aria-atomic="true"></span>\n            <span></span>\n        </div>\n    '),
          (this.element.innerHTML = i);
        let a = 0;
        "function" == typeof this.config.substituteTextArea
          ? (this.textarea = this.config.substituteTextArea())
          : (this.textarea = this.element.children[a++].firstElementChild),
          (this.field = this.element.children[a].children[0]),
          this.field.addEventListener(
            "wheel",
            (t) => {
              t.preventDefault(), t.stopPropagation();
              let e = void 0 === t.deltaX ? t.detail : -t.deltaX;
              isFinite(e) || (e = t.wheelDelta / 10),
                this.field.scroll({
                  top: 0,
                  left: this.field.scrollLeft - 5 * e,
                });
            },
            {
              passive: !1,
            }
          ),
          (this.virtualKeyboardToggleDOMNode =
            this.element.children[a++].children[1]),
          this._attachButtonHandlers(this.virtualKeyboardToggleDOMNode, {
            default: "toggleVirtualKeyboard",
            alt: "toggleVirtualKeyboardAlt",
            shift: "toggleVirtualKeyboardShift",
          }),
          (this.ariaLiveText = this.element.children[a].children[0]),
          (this.accessibleNode = this.element.children[a++].children[1]),
          (this.popover = wi("mathlive-popover-panel", "ML__popover")),
          (this.keystrokeCaption = wi(
            "mathlive-keystroke-caption-panel",
            "ML__keystroke-caption"
          )),
          (this.keystrokeCaptionVisible = !1),
          (this.virtualKeyboardVisible = !1),
          (this.keystrokeBuffer = ""),
          (this.keystrokeBufferStates = []),
          (this.keystrokeBufferResetTimer = null),
          (this.suggestionIndex = 0),
          (this.mode = e.defaultMode || "math"),
          (this.smartModeSuppressed = !1),
          (this.style = {}),
          (this.blurred = !0),
          vi(this.element, "focus", this),
          vi(this.element, "blur", this),
          vi(this.textarea, "cut", this),
          vi(this.textarea, "copy", this),
          vi(this.textarea, "paste", this),
          Ye.delegateKeyboardEvents(this.textarea, {
            container: this.element,
            allowDeadKey: () => "text" === this.mode,
            typedText: this._onTypedText.bind(this),
            paste: this._onPaste.bind(this),
            keystroke: this._onKeystroke.bind(this),
            focus: this._onFocus.bind(this),
            blur: this._onBlur.bind(this),
          }),
          window.PointerEvent
            ? vi(this.field, "pointerdown", this)
            : vi(this.field, "touchstart:active mousedown", this),
          vi(window, "resize", this);
        const r = {
          ...e,
        };
        (r.onSelectionDidChange =
          Ci.prototype._onSelectionDidChange.bind(this)),
          (r.onContentDidChange = Ci.prototype._onContentDidChange.bind(this)),
          (r.onAnnounce = this.config.onAnnounce),
          (r.macros = this.config.macros),
          (r.removeExtraneousParentheses =
            this.config.removeExtraneousParentheses),
          (this.mathlist = new Ve.EditableMathlist(r, this)),
          (this.undoManager = new (class {
            constructor(t) {
              (this.mathlist = t),
                (this.maximumDepth = 1e3),
                (this.record = !1),
                (this.canCoalesce = !1),
                this.reset();
            }
            reset() {
              (this.stack = []), (this.index = -1);
            }
            startRecording() {
              this.record = !0;
            }
            canUndo() {
              return this.index > 0;
            }
            canRedo() {
              return this.index !== this.stack.length - 1;
            }
            undo(t) {
              this.canUndo() &&
                (t &&
                  "function" == typeof t.onUndoStateWillChange &&
                  t.onUndoStateWillChange(this.mathlist.target, "undo"),
                this.restore(this.stack[this.index - 1], t),
                (this.index -= 1),
                t &&
                  "function" == typeof t.onUndoStateDidChange &&
                  t.onUndoStateDidChange(this.mathlist.target, "undo"),
                (this.canCoalesce = !1));
            }
            redo(t) {
              this.canRedo() &&
                (t &&
                  "function" === t.onUndoStateWillChange &&
                  t.onUndoStateWillChange(this.mathlist.target, "redo"),
                (this.index += 1),
                this.restore(this.stack[this.index], t),
                t &&
                  "function" == typeof t.onUndoStateDidChange &&
                  t.onUndoStateDidChange(this.mathlist.target, "redo"),
                (this.canCoalesce = !1));
            }
            pop() {
              this.canUndo() && ((this.index -= 1), this.stack.pop());
            }
            snapshot(t) {
              this.record &&
                (t &&
                  "function" === t.onUndoStateWillChange &&
                  t.onUndoStateWillChange(this.mathlist.target, "snapshot"),
                this.stack.splice(
                  this.index + 1,
                  this.stack.length - this.index - 1
                ),
                this.stack.push({
                  latex: this.mathlist.root.toLatex(),
                  selection: this.mathlist.toString(),
                }),
                this.index++,
                this.stack.length > this.maximumDepth && this.stack.shift(),
                t &&
                  "function" == typeof t.onUndoStateDidChange &&
                  t.onUndoStateDidChange(this.mathlist.target, "snapshot"),
                (this.canCoalesce = !1));
            }
            snapshotAndCoalesce(t) {
              this.canCoalesce && this.pop(),
                this.snapshot(t),
                (this.canCoalesce = !0);
            }
            save() {
              return {
                latex: this.mathlist.root.toLatex(),
                selection: this.mathlist.toString(),
              };
            }
            restore(t, e) {
              const s = this.mathlist.suppressChangeNotifications;
              void 0 !== e.suppressChangeNotifications &&
                (this.mathlist.suppressChangeNotifications =
                  e.suppressChangeNotifications),
                this.mathlist.insert(t ? t.latex : "", {
                  mode: "math",
                  insertionMode: "replaceAll",
                  selectionMode: "after",
                  format: "latex",
                  ...e,
                }),
                this.mathlist.setPath(
                  t
                    ? t.selection
                    : [
                        {
                          relation: "body",
                          offset: 0,
                        },
                      ]
                ),
                (this.mathlist.suppressChangeNotifications = s);
            }
          })(this.mathlist)),
          s.length > 0 && this.$latex(s),
          this.undoManager.startRecording(),
          this.undoManager.snapshot(this.config);
      }
      handleEvent(t) {
        switch (t.type) {
          case "focus":
            this._onFocus(t);
            break;
          case "blur":
            this._onBlur(t);
            break;
          case "touchstart":
          case "mousedown":
          case "pointerdown":
            this._onPointerDown(t);
            break;
          case "resize":
            this._resizeTimer && window.cancelAnimationFrame(this._resizeTimer),
              (this._resizeTimer = window.requestAnimationFrame(
                () => Mi(this) && this._onResize()
              ));
            break;
          case "cut":
            this._onCut(t);
            break;
          case "copy":
            this._onCopy(t);
            break;
          case "paste":
            this._onPaste(t);
        }
      }
      $revertToOriginalContent() {
        (this.element.innerHTML = this.originalContent),
          (this.element.mathfield = null),
          delete this.accessibleNode,
          delete this.ariaLiveText,
          delete this.field,
          ki(this.textarea, "cut", this),
          ki(this.textarea, "copy", this),
          ki(this.textarea, "paste", this),
          this.textarea.remove(),
          delete this.textarea,
          this.virtualKeyboardToggleDOMNode.remove(),
          delete this.virtualKeyboardToggleDOMNode,
          Si(this.popover),
          Si(this.keystrokeCaption),
          Si(this.virtualKeyboard),
          Si(document.getElementById("mathlive-alternate-keys-panel")),
          ki(this.element, "pointerdown", this),
          ki(this.element, "touchstart:active mousedown", this),
          ki(this.element, "focus", this),
          ki(this.element, "blur", this),
          ki(window, "resize", this),
          delete this.element;
      }
      _resetKeystrokeBuffer() {
        (this.keystrokeBuffer = ""),
          (this.keystrokeBufferStates = []),
          clearTimeout(this.keystrokeBufferResetTimer);
      }
      _getCaretPosition() {
        const t = (function t(e) {
          if (
            e.classList.contains("ML__caret") ||
            e.classList.contains("ML__text-caret") ||
            e.classList.contains("ML__command-caret")
          )
            return e;
          let s;
          return (
            Array.from(e.children).forEach(function (e) {
              s = s || t(e);
            }),
            s
          );
        })(this.field);
        if (t) {
          const e = t.getBoundingClientRect();
          return {
            x: e.right,
            y: e.bottom,
            height: e.height,
          };
        }
        return null;
      }
      _getSelectionBounds() {
        const t = this.field.querySelectorAll(".ML__selected");
        if (t && t.length > 0) {
          const e = {
            top: 1 / 0,
            bottom: -1 / 0,
            left: 1 / 0,
            right: -1 / 0,
          };
          t.forEach((t) => {
            const s = t.getBoundingClientRect();
            s.left < e.left && (e.left = s.left),
              s.right > e.right && (e.right = s.right),
              s.bottom > e.bottom && (e.bottom = s.bottom),
              s.top < e.top && (e.top = s.top);
          });
          const s = this.field.getBoundingClientRect(),
            i = e.right - e.left,
            a = e.bottom - e.top;
          return (
            (e.left = Math.ceil(e.left - s.left + this.field.scrollLeft)),
            (e.right = e.left + i),
            (e.top = Math.ceil(e.top - s.top)),
            (e.bottom = e.top + a),
            e
          );
        }
        return null;
      }
      _pathFromPoint(t, e, s) {
        let i;
        (s = s || {}).bias = s.bias || 0;
        const a = (function t(e, s, i) {
            let a = {
                element: null,
                distance: Number.POSITIVE_INFINITY,
              },
              r = !0;
            if (e.getAttribute("data-atom-id")) {
              a.element = e;
              const t = e.getBoundingClientRect(),
                n = s - (t.left + t.right) / 2,
                o = i - (t.top + t.bottom) / 2;
              (a.distance = n * n + o * o), (r = s >= t.left && s <= t.right);
            }
            return (
              r &&
                e.children &&
                Array.from(e.children).forEach(function (e) {
                  const r = t(e, s, i);
                  r.element && r.distance <= a.distance && (a = r);
                }),
              a
            );
          })(this.field, t, e).element,
          r = a ? a.getAttribute("data-atom-id") : null;
        if (r) {
          const e = this.mathlist.filter(function (t, e) {
            return e.captureSelection
              ? e.filter((t) => t.id === r).length > 0
              : e.id === r;
          });
          if (e && e.length > 0)
            if (((i = xe.pathFromString(e[0]).path), 0 === s.bias)) {
              const e = a.getBoundingClientRect();
              t < e.left + e.width / 2 &&
                !a.classList.contains("ML__placeholder") &&
                (i[i.length - 1].offset = Math.max(
                  0,
                  i[i.length - 1].offset - 1
                ));
            } else
              s.bias < 0 &&
                (i[i.length - 1].offset = Math.min(
                  this.mathlist.siblings().length - 1,
                  Math.max(0, i[i.length - 1].offset + s.bias)
                ));
        }
        return i;
      }
      _onPointerDown(t) {
        const e = this;
        let s,
          i = !1,
          a = !1,
          r = !1;
        if (1 !== t.buttons) return;
        let n = !1,
          o = !1;
        const l = t.touches ? t.touches[0].clientX : t.clientX,
          c = t.touches ? t.touches[0].clientY : t.clientY,
          h = Date.now(),
          d = setInterval(() => {
            n
              ? e.field.scroll({
                  top: 0,
                  left: e.field.scrollLeft - 16,
                })
              : o &&
                e.field.scroll({
                  top: 0,
                  left: e.field.scrollLeft + 16,
                });
          }, 32);

        function m(t) {
          window.PointerEvent
            ? (ki(e.field, "pointermove", p),
              ki(e.field, "pointerend pointerleave pointercancel", m),
              e.field.releasePointerCapture(t.pointerId))
            : (ki(e.field, "touchmove", p),
              ki(e.field, "touchend touchleave", m),
              ki(window, "mousemove", p),
              ki(window, "mouseup blur", m)),
            (i = !1),
            clearInterval(d),
            e.element
              .querySelectorAll(".ML__scroller")
              .forEach((t) => t.parentNode.removeChild(t)),
            t.preventDefault(),
            t.stopPropagation();
        }

        function p(t) {
          const i = t.touches ? t.touches[0].clientX : t.clientX,
            r = t.touches ? t.touches[0].clientY : t.clientY,
            d = "touch" === t.pointerType ? 20 : 5;
          if (
            Date.now() < h + 500 &&
            Math.abs(l - i) < d &&
            Math.abs(c - r) < d
          )
            return t.preventDefault(), void t.stopPropagation();
          const m = e.field.getBoundingClientRect();
          (o = i > m.right), (n = i < m.left);
          let p = s;
          window.PointerEvent
            ? t.isPrimary ||
              (p = e._pathFromPoint(t.clientX, t.clientY, {
                bias: 0,
              }))
            : t.touches &&
              2 === t.touches.length &&
              (p = e._pathFromPoint(
                t.touches[1].clientX,
                t.touches[1].clientY,
                {
                  bias: 0,
                }
              ));
          const u = e._pathFromPoint(i, r, {
            bias: i <= l ? (i === l ? 0 : -1) : 1,
          });
          u &&
            e.mathlist.setRange(p, u, {
              extendToWordBoundary: a,
            }) &&
            e._requestUpdate(),
            t.preventDefault(),
            t.stopPropagation();
        }
        Ai &&
        Math.abs(Ai.x - l) < 5 &&
        Math.abs(Ai.y - c) < 5 &&
        Date.now() < Ai.time + 500
          ? ((_i += 1), (Ai.time = h))
          : ((Ai = {
              x: l,
              y: c,
              time: h,
            }),
            (_i = 1));
        const u = this.field.getBoundingClientRect();
        if (l >= u.left && l <= u.right && c >= u.top && c <= u.bottom) {
          this.$hasFocus() ||
            ((r = !0), this.textarea.focus && this.textarea.focus()),
            this._resetKeystrokeBuffer(),
            (this.smartModeSuppressed = !1);
          const n = this.field
            .querySelector(".ML__mathlive")
            .getBoundingClientRect();
          if (
            ((s =
              l > n.right
                ? [
                    {
                      relation: "body",
                      offset: this.mathlist.root.body.length - 1,
                    },
                  ]
                : this._pathFromPoint(l, c, {
                    bias: 0,
                  })),
            s)
          ) {
            let n = document.createElement("div");
            (n.className = "ML__scroller"),
              this.element.appendChild(n),
              (n.style.left = u.left - 200 + "px"),
              (n = document.createElement("div")),
              (n.className = "ML__scroller"),
              this.element.appendChild(n),
              (n.style.left = u.right + "px"),
              t.shiftKey
                ? (this.mathlist.setRange(this.mathlist.path, s),
                  (s = xe.clone(this.mathlist.path)),
                  (s[s.length - 1].offset -= 1))
                : this.mathlist.setPath(s, 0),
              (r = !0),
              (this.style = {}),
              3 === t.detail || _i > 2
                ? (m(t),
                  (3 !== t.detail && 3 !== _i) || this.mathlist.selectAll_())
                : i ||
                  ((i = !0),
                  window.PointerEvent
                    ? (vi(e.field, "pointermove", p),
                      vi(e.field, "pointerend pointercancel pointerup", m),
                      e.field.setPointerCapture(t.pointerId))
                    : (vi(window, "blur", m),
                      t.touches
                        ? (vi(t.target, "touchmove", p),
                          vi(t.target, "touchend", m))
                        : (vi(window, "mousemove", p),
                          vi(window, "mouseup", m))),
                  (2 !== t.detail && 2 !== _i) ||
                    ((a = !0), this.mathlist.selectGroup_()));
          }
        } else Ai = null;
        r && this._requestUpdate(), t.preventDefault();
      }
      _onSelectionDidChange() {
        this.mathlist.commitCommandStringBeforeInsertionPoint();
        const t = Xt("math", this.mathlist.getSelectedAtoms()).toLatex(!1);
        t
          ? ((this.textarea.value = t),
            this.$hasFocus() && this.textarea.select && this.textarea.select())
          : ((this.textarea.value = ""),
            this.textarea.setAttribute("aria-label", ""));
        {
          const t = this.mode;
          (this.mode = this.mathlist.anchorMode() || this.config.defaultMode),
            this.mode !== t &&
              "function" == typeof this.config.onModeChange &&
              this.config.onModeChange(this, this.mode),
            "command" === t &&
              "command" !== this.mode &&
              (ss.hidePopover(this), this.mathlist.removeCommandString());
        }
        ss.updatePopoverPosition(this, {
          deferred: !0,
        }),
          "function" == typeof this.config.onSelectionDidChange &&
            this.config.onSelectionDidChange(this);
      }
      _onContentDidChange() {
        this.undoManager.canRedo()
          ? this.element.classList.add("can-redo")
          : this.element.classList.remove("can-redo"),
          this.undoManager.canUndo()
            ? this.element.classList.add("can-undo")
            : this.element.classList.remove("can-undo"),
          "function" == typeof this.config.onContentDidChange &&
            this.config.onContentDidChange(this);
      }
      _nextAtomSpeechText(t) {
        function e(t, e) {
          return "body" === e.relation
            ? {
                enclose: "cross out",
                leftright: "fence",
                surd: "square root",
                root: "math field",
              }[t.type]
            : {
                numer: "numerator",
                denom: "denominator",
                index: "index",
                body: "parent",
                subscript: "subscript",
                superscript: "superscript",
              }[e.relation];
        }
        const s = t ? t.path : [],
          i = this.mathlist.path,
          a = i[i.length - 1];
        let r = "";
        for (; s.length > i.length; )
          (r += "out of " + e(t.parent(), s[s.length - 1]) + "; "), s.pop();
        if (!this.mathlist.isCollapsed())
          return Li(this, "", this.mathlist.getSelectedAtoms());
        const n = e(this.mathlist.parent(), a);
        0 === a.offset && (r += (n ? "start of " + n : "unknown") + ": ");
        const o = this.mathlist.sibling(Math.max(1, this.mathlist.extent));
        return (
          o
            ? (r += Li(this, "", o))
            : 0 !== a.offset && (r += n ? "end of " + n : "unknown"),
          r
        );
      }
      _announce(t, e, s) {
        "function" == typeof this.config.onAnnounce &&
          this.config.onAnnounce(this, t, e, s);
      }
      _onFocus() {
        this.config.readOnly ||
          (this.blurred &&
            ((this.blurred = !1),
            this.textarea.focus && this.textarea.focus(),
            "onfocus" === this.config.virtualKeyboardMode &&
              this.showVirtualKeyboard_(),
            ss.updatePopoverPosition(this),
            this.config.onFocus && this.config.onFocus(this),
            this._requestUpdate()));
      }
      _onBlur() {
        this.blurred ||
          ((this.blurred = !0),
          (this.ariaLiveText.textContent = ""),
          "onfocus" === this.config.virtualKeyboardMode &&
            this.hideVirtualKeyboard_(),
          this.complete_({
            discard: !0,
          }),
          this._requestUpdate(),
          this.config.onBlur && this.config.onBlur(this));
      }
      _onResize() {
        this.element.classList.remove(
          "ML__isNarrowWidth",
          "ML__isWideWidth",
          "ML__isExtendedWidth"
        ),
          window.innerWidth >= 1024
            ? this.element.classList.add("ML__isExtendedWidth")
            : window.innerWidth >= 768
            ? this.element.classList.add("ML__isWideWidth")
            : this.element.classList.add("ML__isNarrowWidth"),
          ss.updatePopoverPosition(this);
      }
      toggleKeystrokeCaption_() {
        (this.keystrokeCaptionVisible = !this.keystrokeCaptionVisible),
          (this.keystrokeCaption.innerHTML = ""),
          this.keystrokeCaptionVisible ||
            (this.keystrokeCaption.style.visibility = "hidden");
      }
      _showKeystroke(t) {
        const e = this.keystrokeCaption;
        if (e && this.keystrokeCaptionVisible) {
          const s = this.element.getBoundingClientRect();
          (e.style.left = s.left + "px"),
            (e.style.top = s.top - 64 + "px"),
            (e.innerHTML =
              "<span>" + (Ce.stringify(t) || t) + "</span>" + e.innerHTML),
            (e.style.visibility = "visible"),
            setTimeout(function () {
              e.childNodes.length > 0 &&
                e.removeChild(e.childNodes[e.childNodes.length - 1]),
                0 === e.childNodes.length && (e.style.visibility = "hidden");
            }, 3e3);
        }
      }
      $perform(t) {
        if (!t) return !1;
        let e,
          s = !1,
          i = [],
          a = !1;
        if (
          (Array.isArray(t) ? ((e = t[0]), (i = t.slice(1))) : (e = t),
          (e = e.replace(/-\w/g, (t) => t[1].toUpperCase())),
          (e += "_"),
          "function" == typeof this.mathlist[e])
        ) {
          if (
            (/^(delete|transpose|add)/.test(e) && this._resetKeystrokeBuffer(),
            /^(delete|transpose|add)/.test(e) &&
              "command" !== this.mode &&
              (this.undoManager.pop(), this.undoManager.snapshot(this.config)),
            this.mathlist[e](...i),
            /^(delete|transpose|add)/.test(e) &&
              "command" !== this.mode &&
              this.undoManager.snapshot(this.config),
            /^(delete)/.test(e) && "command" === this.mode)
          ) {
            const t = gt(
              this.mathlist.extractCommandStringAroundInsertionPoint()
            );
            0 === t.length
              ? ss.hidePopover(this)
              : ss.showPopoverWithLatex(this, t[0].match, t.length > 1);
          }
          (a = !0), (s = !0);
        } else "function" == typeof this[e] && ((a = this[e](...i)), (s = !0));
        return (
          (this.mathlist.isCollapsed() &&
            !/^(transpose|paste|complete|((moveToNextChar|moveToPreviousChar|extend).*))_$/.test(
              e
            )) ||
            (this._resetKeystrokeBuffer(), (this.style = {})),
          a && this._requestUpdate(),
          s
        );
      }
      performWithFeedback_(t) {
        return (
          this.$focus(),
          this.config.keypressVibration &&
            navigator.vibrate &&
            navigator.vibrate(3),
          "moveToNextPlaceholder" ===
            (t = t.replace(/-\w/g, (t) => t[1].toUpperCase())) ||
          "moveToPreviousPlaceholder" === t ||
          "complete" === t
            ? this.returnKeypressSound
              ? (this.returnKeypressSound.load(),
                this.returnKeypressSound.play().catch((t) => {}))
              : this.keypressSound &&
                (this.keypressSound.load(),
                this.keypressSound.play().catch((t) => {}))
            : ("deletePreviousChar" !== t &&
                "deleteNextChar" !== t &&
                "deletePreviousWord" !== t &&
                "deleteNextWord" !== t &&
                "deleteToGroupStart" !== t &&
                "deleteToGroupEnd" !== t &&
                "deleteToMathFieldStart" !== t &&
                "deleteToMathFieldEnd" !== t) ||
              !this.deleteKeypressSound
            ? this.keypressSound &&
              (this.keypressSound.load(),
              this.keypressSound.play().catch((t) => {}))
            : (this.deleteKeypressSound.load(),
              this.deleteKeypressSound.play().catch((t) => {})),
          this.$perform(t)
        );
      }
      convertLastAtomsToText_(t, e) {
        "function" == typeof t && ((e = t), (t = 1 / 0)),
          void 0 === t && (t = 1 / 0);
        let s = 0,
          i = !1;
        for (this.mathlist.contentWillChange(); !i; ) {
          const a = this.mathlist.sibling(s);
          (i =
            0 === t ||
            !a ||
            "math" !== a.mode ||
            !(
              /mord|textord|mpunct/.test(a.type) ||
              ("mop" === a.type && /[a-zA-Z]+/.test(a.body))
            ) ||
            a.superscript ||
            a.subscript ||
            (e && !e(a))),
            i ||
              (a.applyStyle({
                mode: "text",
              }),
              (a.symbol = a.body),
              (a.latex = "")),
            (s -= 1),
            (t -= 1);
        }
        this.mathlist.contentDidChange();
      }
      convertLastAtomsToMath_(t, e) {
        "function" == typeof t && ((e = t), (t = 1 / 0)),
          void 0 === t && (t = 1 / 0),
          this.mathlist.contentWillChange();
        let s = 0,
          i = !1;
        for (; !i; ) {
          const a = this.mathlist.sibling(s);
          (i =
            0 === t ||
            !a ||
            "text" !== a.mode ||
            " " === a.body ||
            (e && !e(a))),
            i ||
              a.applyStyle({
                mode: "math",
                type: "mord",
              }),
            (s -= 1),
            (t -= 1);
        }
        this.removeIsolatedSpace_(), this.mathlist.contentDidChange();
      }
      removeIsolatedSpace_() {
        let t = 0;
        for (
          ;
          this.mathlist.sibling(t) && "math" === this.mathlist.sibling(t).mode;

        )
          t -= 1;
        if (
          this.mathlist.sibling(t) &&
          "text" === this.mathlist.sibling(t).mode &&
          " " === this.mathlist.sibling(t).body &&
          (!this.mathlist.sibling(t - 1) ||
            "math" === this.mathlist.sibling(t - 1).mode)
        ) {
          this.mathlist.contentWillChange(),
            this.mathlist.siblings().splice(t - 1, 1),
            this.mathlist.contentDidChange();
          const e = this.mathlist.suppressChangeNotifications;
          (this.mathlist.suppressChangeNotifications = !0),
            this.mathlist.setSelection(this.mathlist.anchorOffset() - 1),
            (this.mathlist.suppressChangeNotifications = e);
        }
      }
      getTextBeforeAnchor_() {
        let t = "",
          e = 0,
          s = !1;
        for (; !s; ) {
          const i = this.mathlist.sibling(e);
          (s = !(
            i &&
            (("text" === i.mode && !i.type) ||
              ("math" === i.mode && /mord|textord|mpunct/.test(i.type)))
          )),
            s || (t = i.body + t),
            (e -= 1);
        }
        return t;
      }
      smartMode_(t, e) {
        if (this.smartModeSuppressed) return !1;
        if (this.mathlist.endOffset() < this.mathlist.siblings().length - 1)
          return !1;
        if (!e || e.ctrlKey || e.metaKey) return !1;
        const s = Ye.eventToChar(e);
        if (s.length > 1) return !1;
        if (!this.mathlist.isCollapsed())
          return !("text" !== this.mode || !/[/_^]/.test(s));
        const i = this.getTextBeforeAnchor_() + s;
        if ("text" === this.mode) {
          if ("Esc" === t || /[/\\]/.test(s)) return !0;
          if (/[\^_]/.test(s))
            return (
              /(^|\s)[a-zA-Z][^_]$/.test(i) && this.convertLastAtomsToMath_(1),
              !0
            );
          const e = {
            ")": "(",
            "}": "{",
            "]": "[",
          }[s];
          if (
            e &&
            this.mathlist.parent() &&
            "leftright" === this.mathlist.parent().type &&
            this.mathlist.parent().leftDelim === e
          )
            return !0;
          if (/(^|[^a-zA-Z])(a|I)[ ]$/.test(i)) return !1;
          if (/[$€£₤₺¥¤฿¢₡₧₨₹₩₱]/u.test(s)) return !0;
          if (/(^|[^a-zA-Z'’])[a-zA-Z][ ]$/.test(i))
            return this.convertLastAtomsToMath_(1), !1;
          if (/[^0-9]\.[^0-9\s]$/.test(i)) {
            this.convertLastAtomsToMath_(1);
            const t = this.mathlist.sibling(0);
            return (
              (t.body = "⋅"),
              (t.variant = "auto"),
              (t.symbol = "\\cdot"),
              (t.latex = ""),
              !0
            );
          }
          if (/(^|\s)[a-zA-Z][^a-zA-Z]$/.test(i))
            return this.convertLastAtomsToMath_(1), !0;
          if (/\.[0-9]$/.test(i)) return this.convertLastAtomsToMath_(1), !0;
          if (/[(][0-9+\-.]$/.test(i))
            return this.convertLastAtomsToMath_(1), !0;
          if (/[(][a-z][,;]$/.test(i))
            return this.convertLastAtomsToMath_(2), !0;
          if (/[0-9+\-=><*|]$/.test(s)) return this.removeIsolatedSpace_(), !0;
        } else {
          if ("Spacebar" === t)
            return (
              this.convertLastAtomsToText_((t) => /[a-z][:,;.]$/.test(t.body)),
              !0
            );
          if (/[a-zA-Z]{3,}$/.test(i) && !/(dxd|abc|xyz|uvw)$/.test(i))
            return (
              this.convertLastAtomsToText_((t) => /[a-zA-Z:,;.]/.test(t.body)),
              !0
            );
          if (/(^|\W)(if|If)$/i.test(i))
            return this.convertLastAtomsToText_(1), !0;
          if (
            /(\u0393|\u0394|\u0398|\u039b|\u039E|\u03A0|\u03A3|\u03a5|\u03a6|\u03a8|\u03a9|[\u03b1-\u03c9]|\u03d1|\u03d5|\u03d6|\u03f1|\u03f5){3,}$/u.test(
              i
            ) &&
            !/(αβγ)$/.test(i)
          )
            return (
              this.convertLastAtomsToText_((t) =>
                /(:|,|;|.|\u0393|\u0394|\u0398|\u039b|\u039E|\u03A0|\u03A3|\u03a5|\u03a6|\u03a8|\u03a9|[\u03b1-\u03c9]|\u03d1|\u03d5|\u03d6|\u03f1|\u03f5)/u.test(
                  t.body
                )
              ),
              !0
            );
          if (/\?|\./.test(s)) return !0;
        }
        return !1;
      }
      _onKeystroke(t, e) {
        if (
          (this._showKeystroke(t),
          clearTimeout(this.keystrokeBufferResetTimer),
          this.config.onKeystroke && !this.config.onKeystroke(this, t, e))
        )
          return (
            e && e.preventDefault && (e.preventDefault(), e.stopPropagation()),
            !1
          );
        let s,
          i,
          a,
          r = !1;
        if ("command" !== this.mode && (!e || (!e.ctrlKey && !e.metaKey))) {
          const t = Ye.eventToChar(e);
          if ("Backspace" !== t)
            if (!t || t.length > 1) this._resetKeystrokeBuffer();
            else {
              const e = this.keystrokeBuffer + t;
              let a = 0;
              for (; !s && a < e.length; ) {
                let t;
                if (this.keystrokeBufferStates[a]) {
                  const e = new Ve.EditableMathlist();
                  (e.root = Xt(
                    "math",
                    ge(
                      this.keystrokeBufferStates[a].latex,
                      this.config.default,
                      null,
                      this.config.macros
                    )
                  )),
                    e.setPath(this.keystrokeBufferStates[a].selection),
                    (t = e.siblings());
                } else t = this.mathlist.siblings();
                (s = Ce.forString(this.mode, t, e.slice(a), this.config)),
                  (a += 1);
              }
              (i = a - 1),
                (this.keystrokeBuffer += t),
                this.keystrokeBufferStates.push(this.undoManager.save()),
                Ce.startsWithString(e, this.config).length <= 1
                  ? (r = !0)
                  : this.config.inlineShortcutTimeout &&
                    (this.keystrokeBufferResetTimer = setTimeout(() => {
                      this._resetKeystrokeBuffer();
                    }, this.config.inlineShortcutTimeout));
            }
        }
        if (this.config.smartMode) {
          const i = this.mode;
          s
            ? (this.mode = "math")
            : this.smartMode_(t, e) &&
              ((this.mode = {
                math: "text",
                text: "math",
              }[this.mode]),
              (a = "")),
            this.mode !== i &&
              "function" == typeof this.config.onModeChange &&
              this.config.onModeChange(this, this.mode);
        }
        if ((s || a || (a = Ce.selectorForKeystroke(this.mode, t)), !s && !a))
          return !0;
        if (this.config.readOnly && "insert" === a[0]) return !0;
        this.mathlist.decorateCommandStringAroundInsertionPoint(!1);
        const n = this.mathlist.parent();
        if (
          ("moveAfterParent" === a &&
            n &&
            "leftright" === n.type &&
            this.mathlist.endOffset() === this.mathlist.siblings().length - 1 &&
            this.config.smartFence &&
            this.mathlist._insertSmartFence(".") &&
            ((a = ""), this._requestUpdate()),
          "math" === this.mode && "Spacebar" === t && !s)
        ) {
          const t = this.mathlist.sibling(1),
            e = this.mathlist.sibling(-1);
          ((t && "text" === t.mode) || (e && "text" === e.mode)) &&
            this.mathlist.insert(" ", {
              mode: "text",
            });
        }
        if (((a && !this.$perform(a)) || s) && s) {
          if (
            !/^(\\{|\\}|\\[|\\]|\\@|\\#|\\$|\\%|\\^|\\_|\\backslash)$/.test(s)
          ) {
            const t = {
              ...this.mathlist.anchorStyle(),
              ...this.style,
            };
            this.mathlist.insert(Ye.eventToChar(e), {
              suppressChangeNotifications: !0,
              mode: this.mode,
              style: t,
            });
            const s = this.mode;
            this.undoManager.snapshotAndCoalesce(this.config),
              this.undoManager.restore(this.keystrokeBufferStates[i], {
                ...this.config,
                suppressChangeNotifications: !0,
              }),
              (this.mode = s);
          }
          this.mathlist.contentWillChange();
          const t = this.mathlist.suppressChangeNotifications;
          this.mathlist.suppressChangeNotifications = !0;
          const a = {
            ...this.mathlist.anchorStyle(),
            ...this.style,
          };
          this.mathlist.insert(s, {
            format: "latex",
            mode: this.mode,
            style: a,
            smartFence: !0,
          }),
            this.removeIsolatedSpace_(),
            s.endsWith(" ") &&
              ((this.mode = "text"),
              this.mathlist.insert(" ", {
                mode: "text",
                style: a,
              })),
            (this.mathlist.suppressChangeNotifications = t),
            this.mathlist.contentDidChange(),
            this.undoManager.snapshot(this.config),
            this._requestUpdate(),
            this._announce("replacement"),
            r && this._resetKeystrokeBuffer();
        }
        return (
          this.scrollIntoView(),
          e && e.preventDefault && (e.preventDefault(), e.stopPropagation()),
          !1
        );
      }
      _onTypedText(t, e) {
        if (this.config.readOnly) return void this._announce("plonk");
        if (
          ((e = e || {}).focus && this.$focus(),
          e.feedback &&
            (this.config.keypressVibration &&
              navigator.vibrate &&
              navigator.vibrate(3),
            this.keypressSound &&
              (this.keypressSound.load(),
              this.keypressSound.play().catch((t) => {}))),
          e.commandMode &&
            "command" !== this.mode &&
            this.switchMode_("command"),
          this.mathlist.decorateCommandStringAroundInsertionPoint(!1),
          e.simulateKeystroke)
        ) {
          const e = t.charAt(0),
            s = Ye.charToEvent(e);
          if (!this.$keystroke(Ye.keyboardEventToString(s), s)) return;
        }
        let s = "",
          i = !1;
        if (this.pasteInProgress)
          (this.pasteInProgress = !1),
            this.mathlist.insert(t, {
              smartFence: this.config.smartFence,
              mode: "math",
            });
        else {
          const e = {
              ...this.mathlist.anchorStyle(),
              ...this.style,
            },
            a = ae(t);
          for (const t of a)
            if ("command" === this.mode) {
              this.mathlist.removeSuggestion(), (this.suggestionIndex = 0);
              const e =
                  this.mathlist.extractCommandStringAroundInsertionPoint(),
                a = gt(e + t);
              (i = a.length > 1),
                0 === a.length
                  ? (this.mathlist.insert(t, {
                      mode: "command",
                    }),
                    /^\\[a-zA-Z\\*]+$/.test(e + t) &&
                      this.mathlist.decorateCommandStringAroundInsertionPoint(
                        !0
                      ),
                    ss.hidePopover(this))
                  : (this.mathlist.insert(t, {
                      mode: "command",
                    }),
                    a[0].match !== e + t &&
                      this.mathlist.insertSuggestion(
                        a[0].match,
                        -a[0].match.length + e.length + 1
                      ),
                    (s = a[0].match));
            } else if ("math" === this.mode) {
              const s = {
                "^": "moveToSuperscript",
                _: "moveToSubscript",
                " ": "moveAfterParent",
              }[t];
              if (s) {
                if ("moveToSuperscript" === s) {
                  if (this._superscriptDepth() >= this.config.scriptDepth[1])
                    return void this._announce("plonk");
                } else if (
                  "moveToSubscript" === s &&
                  this._subscriptDepth() >= this.config.scriptDepth[0]
                )
                  return void this._announce("plonk");
                this.$perform(s);
              } else
                this.config.smartSuperscript &&
                "superscript" === this.mathlist.relation() &&
                /[0-9]/.test(t) &&
                0 ===
                  this.mathlist.siblings().filter((t) => "first" !== t.type)
                    .length
                  ? (this.mathlist.insert(t, {
                      mode: "math",
                      style: e,
                    }),
                    this.mathlist.moveAfterParent_())
                  : this.mathlist.insert(t, {
                      mode: "math",
                      style: e,
                      smartFence: this.config.smartFence,
                    });
            } else
              "text" === this.mode &&
                this.mathlist.insert(t, {
                  mode: "text",
                  style: e,
                });
        }
        "command" !== this.mode &&
          this.undoManager.snapshotAndCoalesce(this.config),
          this._requestUpdate(),
          this.scrollIntoView(),
          ss.showPopoverWithLatex(this, s, i);
      }
      _hash() {
        let t = 0;
        const e = this.mathlist.root.toLatex(!1);
        for (let s = 0; s < e.length; s++)
          (t = 31 * t + e.charCodeAt(s)), (t |= 0);
        return Math.abs(t);
      }
      _requestUpdate() {
        this.dirty ||
          ((this.dirty = !0),
          requestAnimationFrame((t) => Mi(this) && this._render()));
      }
      _render(t) {
        (t = t || {}),
          (this.dirty = !1),
          window.mathlive || (window.mathlive = {}),
          this.mathlist.anchor() ||
            (this.mathlist.path = [
              {
                relation: "body",
                offset: 0,
              },
            ]),
          this.mathlist.forEach((t) => {
            (t.caret = ""), (t.isSelected = !1), (t.containsCaret = !1);
          });
        const e = this.$hasFocus();
        if (
          (this.mathlist.isCollapsed()
            ? (this.mathlist.anchor().caret =
                e && !this.config.readOnly ? this.mode : "")
            : this.mathlist.forEachSelected((t) => {
                t.isSelected = !0;
              }),
          e && !this.config.readOnly)
        ) {
          let t = this.mathlist.ancestor(1),
            e = 1,
            s = !1;
          for (; t && !s; )
            ("surd" !== t.type && "leftright" !== t.type) ||
              ((t.containsCaret = !0), (s = !0)),
              (e += 1),
              (t = this.mathlist.ancestor(e));
        }
        const s = I(
          Gt(
            {
              mathstyle: k.displaystyle,
              letterShapeStyle: this.config.letterShapeStyle,
              atomIdsSettings: {
                seed: this._hash(),
                groupNumbers: t.forHighlighting,
              },
              smartFence: this.config.smartFence,
              macros: this.config.macros,
            },
            this.mathlist.root
          ),
          "ML__base"
        );
        s.attributes = {
          translate: "no",
          "aria-hidden": "true",
        };
        const i = H(s, "ML__mathlive");
        (this.field.innerHTML = i.toMarkup(
          0,
          this.config.horizontalSpacingScale
        )),
          this.field.classList.toggle(
            "ML__focused",
            e && !this.config.readOnly
          ),
          (this.accessibleNode.innerHTML =
            "<math xmlns='http://www.w3.org/1998/Math/MathML'>" +
            Zt.toMathML(this.mathlist.root, this.config) +
            "</math>");
        const a = this._getSelectionBounds();
        if (a) {
          const t = document.createElement("div");
          t.classList.add("ML__selection"),
            (t.style.position = "absolute"),
            (t.style.left = a.left + "px"),
            (t.style.top = a.top + "px"),
            (t.style.width = Math.ceil(a.right - a.left) + "px"),
            (t.style.height = Math.ceil(a.bottom - a.top - 1) + "px"),
            this.field.insertBefore(t, this.field.childNodes[0]);
        }
      }
      _onPaste() {
        return (this.pasteInProgress = !0), !0;
      }
      _onCut() {
        return (
          setTimeout(
            function () {
              this.$clearSelection(), this._requestUpdate();
            }.bind(this),
            0
          ),
          !0
        );
      }
      _onCopy(t) {
        this.mathlist.isCollapsed()
          ? (t.clipboardData.setData(
              "text/plain",
              "$$" + this.$text("latex-expanded") + "$$"
            ),
            t.clipboardData.setData("application/json", this.$text("json")),
            t.clipboardData.setData("application/xml", this.$text("mathML")))
          : (t.clipboardData.setData(
              "text/plain",
              "$$" + this.$selectedText("latex-expanded") + "$$"
            ),
            t.clipboardData.setData(
              "application/json",
              this.$selectedText("json")
            ),
            t.clipboardData.setData(
              "application/xml",
              this.$selectedText("mathML")
            )),
          t.preventDefault();
      }
      formatMathlist(t, e) {
        let s = "";
        if ("latex" === (e = e || "latex") || "latex-expanded" === e)
          s = t.toLatex("latex-expanded" === e);
        else if ("mathML" === e) s = t.toMathML(this.config);
        else if ("spoken" === e) s = Zt.toSpeakableText(t, this.config);
        else if ("spoken-text" === e) {
          const e = this.config.textToSpeechMarkup;
          (this.config.textToSpeechMarkup = ""),
            (s = Zt.toSpeakableText(t, this.config)),
            (this.config.textToSpeechMarkup = e);
        } else if (
          "spoken-ssml" === e ||
          "spoken-ssml-withHighlighting" === e
        ) {
          const i = this.config.textToSpeechMarkup,
            a = this.config.atomIdsSettings;
          (this.config.textToSpeechMarkup = "ssml"),
            "spoken-ssml-withHighlighting" === e &&
              (this.config.atomIdsSettings = {
                seed: "random",
              }),
            (s = Zt.toSpeakableText(t, this.config)),
            (this.config.textToSpeechMarkup = i),
            (this.config.atomIdsSettings = a);
        } else if ("json" === e) {
          const e = Zt.toAST(t, this.config);
          s = JSON.stringify(e);
        } else if ("json-2" === e) {
          const e = Zt.toAST(t, this.config);
          s = JSON.stringify(e, null, 2);
        } else "ASCIIMath" === e && (s = gs(t, this.config));
        return s;
      }
      $text(t) {
        return this.formatMathlist(this.mathlist.root, t);
      }
      $selectedText(t) {
        const e = this.mathlist.getSelectedAtoms();
        if (!e) return "";
        const s = Xt("math", e);
        return this.formatMathlist(s, t);
      }
      $selectionIsCollapsed() {
        return this.mathlist.isCollapsed();
      }
      $selectionDepth() {
        return this.mathlist.path.length;
      }
      _superscriptDepth() {
        let t = 0,
          e = 0,
          s = this.mathlist.ancestor(e),
          i = !1;
        for (; s; )
          (s.superscript || s.subscript) && (t += 1),
            s.superscript ? (i = !0) : s.subscript && (i = !1),
            (e += 1),
            (s = this.mathlist.ancestor(e));
        return i ? t : 0;
      }
      _subscriptDepth() {
        let t = 0,
          e = 0,
          s = this.mathlist.ancestor(e),
          i = !1;
        for (; s; )
          (s.superscript || s.subscript) && (t += 1),
            s.superscript ? (i = !1) : s.subscript && (i = !0),
            (e += 1),
            (s = this.mathlist.ancestor(e));
        return i ? t : 0;
      }
      $selectionAtStart() {
        return 0 === this.mathlist.startOffset();
      }
      $selectionAtEnd() {
        return this.mathlist.endOffset() >= this.mathlist.siblings().length - 1;
      }
      groupIsSelected() {
        return (
          0 === this.mathlist.startOffset() &&
          this.mathlist.endOffset() >= this.mathlist.siblings().length - 1
        );
      }
      $latex(t, e) {
        return t
          ? (t !== this.mathlist.root.toLatex() &&
              ((e = e || {}),
              this.mathlist.insert(
                t,
                Object.assign({}, this.config, {
                  insertionMode: "replaceAll",
                  selectionMode: "after",
                  format: "latex",
                  mode: "math",
                  suppressChangeNotifications: e.suppressChangeNotifications,
                })
              ),
              this.undoManager.snapshot(this.config),
              this._requestUpdate()),
            t)
          : this.mathlist.root.toLatex();
      }
      $el() {
        return this.element;
      }
      undo() {
        return this.complete_(), this.undoManager.undo(this.config), !0;
      }
      redo() {
        return this.complete_(), this.undoManager.redo(this.config), !0;
      }
      scrollIntoView() {
        this.dirty && this._render();
        let t = this._getCaretPosition();
        const e = this.field.getBoundingClientRect();
        if (!t) {
          const s = this._getSelectionBounds();
          s &&
            (t = {
              x: s.right + e.left - this.field.scrollLeft,
              y: s.top + e.top - this.field.scrollTop,
            });
        }
        if (t) {
          const s = t.x - window.scrollX;
          s < e.left
            ? this.field.scroll({
                top: 0,
                left: s - e.left + this.field.scrollLeft - 20,
                behavior: "smooth",
              })
            : s > e.right &&
              this.field.scroll({
                top: 0,
                left: s - e.right + this.field.scrollLeft + 20,
                behavior: "smooth",
              });
        }
      }
      scrollToStart() {
        this.field.scroll(0, 0);
      }
      scrollToEnd() {
        const t = this.field.getBoundingClientRect();
        this.field.scroll(t.left - window.scrollX, 0);
      }
      enterCommandMode_() {
        this.switchMode_("command");
      }
      copyToClipboard_() {
        return (
          this.$focus(),
          this.mathlist.isCollapsed() && this.$select(),
          document.execCommand("copy"),
          !1
        );
      }
      cutToClipboard_() {
        return this.$focus(), document.execCommand("cut"), !0;
      }
      pasteFromClipboard_() {
        return this.$focus(), document.execCommand("paste"), !0;
      }
      $insert(t, e) {
        if ("string" == typeof t && t.length > 0) {
          if (
            ((e = e || {}).focus && this.$focus(),
            e.feedback &&
              (this.config.keypressVibration &&
                navigator.vibrate &&
                navigator.vibrate(3),
              this.keypressSound &&
                (this.keypressSound.load(), this.keypressSound.play())),
            "\\\\" === t)
          )
            this.mathlist.addRowAfter_();
          else if ("&" === t) this.mathlist.addColumnAfter_();
          else {
            const s = this.style;
            this.mathlist.insert(t, {
              mode: this.mode,
              style: this.mathlist.anchorStyle(),
              ...e,
            }),
              e.resetStyle && (this.style = s);
          }
          return (
            this.undoManager.snapshot(this.config), this._requestUpdate(), !0
          );
        }
        return !1;
      }
      switchMode_(t, e, s) {
        this._resetKeystrokeBuffer(),
          (this.smartModeSuppressed =
            /text|math/.test(this.mode) && /text|math/.test(t)),
          e &&
            this.$insert(e, {
              format: "latex",
              mode: {
                math: "text",
                text: "math",
              }[t],
            }),
          this.mathlist.decorateCommandStringAroundInsertionPoint(!1),
          "command" === t
            ? (this.mathlist.removeSuggestion(),
              ss.hidePopover(this),
              (this.suggestionIndex = 0),
              this.virtualKeyboardVisible &&
                this.switchKeyboardLayer_("lower-command"),
              this.mathlist.insert("", {
                mode: "math",
              }))
            : (this.mode = t),
          s &&
            this.$insert(s, {
              format: "latex",
              mode: t,
            }),
          "function" == typeof this.config.onModeChange &&
            this.config.onModeChange(this, this.mode),
          this._requestUpdate();
      }
      complete_(t) {
        if (((t = t || {}), ss.hidePopover(this), t.discard))
          return (
            this.mathlist.spliceCommandStringAroundInsertionPoint(null),
            this.switchMode_("math"),
            !0
          );
        const e = this.mathlist.extractCommandStringAroundInsertionPoint(
          !t.acceptSuggestion
        );
        if (e) {
          if ("\\(" === e || "\\)" === e)
            this.mathlist.spliceCommandStringAroundInsertionPoint([]),
              this.mathlist.insert(e.slice(1), {
                mode: this.mode,
              });
          else {
            const t = "math";
            if (
              (function (t, e) {
                return (
                  !(!X[e] || (X[e].mode && !X[e].mode.includes(t))) ||
                  !!{
                    text: tt,
                    math: G,
                  }[t][e]
                );
              })(t, e)
            ) {
              const s = ge(e, t, null, this.config.macros);
              this.mathlist.spliceCommandStringAroundInsertionPoint(s);
            } else {
              const s = ge(e, t, null, this.config.macros);
              s
                ? this.mathlist.spliceCommandStringAroundInsertionPoint(s)
                : this.mathlist.decorateCommandStringAroundInsertionPoint(!0);
            }
          }
          return (
            this.undoManager.snapshot(this.config),
            this._announce("replacement"),
            !0
          );
        }
        return !1;
      }
      _updateSuggestion() {
        this.mathlist.positionInsertionPointAfterCommitedCommand(),
          this.mathlist.removeSuggestion();
        const t = this.mathlist.extractCommandStringAroundInsertionPoint(),
          e = gt(t);
        if (0 === e.length)
          ss.hidePopover(this),
            this.mathlist.decorateCommandStringAroundInsertionPoint(!0);
        else {
          const s = this.suggestionIndex % e.length,
            i = t.length - e[s].match.length;
          0 !== i && this.mathlist.insertSuggestion(e[s].match, i),
            ss.showPopoverWithLatex(this, e[s].match, e.length > 1);
        }
        this._requestUpdate();
      }
      nextSuggestion_() {
        return (this.suggestionIndex += 1), this._updateSuggestion(), !1;
      }
      previousSuggestion_() {
        if (((this.suggestionIndex -= 1), this.suggestionIndex < 0)) {
          this.mathlist.removeSuggestion();
          const t = gt(
            this.mathlist.extractCommandStringAroundInsertionPoint()
          );
          this.suggestionIndex = t.length - 1;
        }
        return this._updateSuggestion(), !1;
      }
      _attachButtonHandlers(t, e) {
        const s = this;
        let i, a, r, n, o;
        "object" == typeof e && (e.default || e.pressed)
          ? (e.default &&
              t.setAttribute(
                "data-" + this.config.namespace + "command",
                JSON.stringify(e.default)
              ),
            e.alt &&
              t.setAttribute(
                "data-" + this.config.namespace + "command-alt",
                JSON.stringify(e.alt)
              ),
            e.altshift &&
              t.setAttribute(
                "data-" + this.config.namespace + "command-altshift",
                JSON.stringify(e.altshift)
              ),
            e.shift &&
              t.setAttribute(
                "data-" + this.config.namespace + "command-shift",
                JSON.stringify(e.shift)
              ),
            e.pressed &&
              t.setAttribute(
                "data-" + this.config.namespace + "command-pressed",
                JSON.stringify(e.pressed)
              ),
            e.pressAndHoldStart &&
              t.setAttribute(
                "data-" + this.config.namespace + "command-pressAndHoldStart",
                JSON.stringify(e.pressAndHoldStart)
              ),
            e.pressAndHoldEnd &&
              t.setAttribute(
                "data-" + this.config.namespace + "command-pressAndHoldEnd",
                JSON.stringify(e.pressAndHoldEnd)
              ))
          : t.setAttribute(
              "data-" + this.config.namespace + "command",
              JSON.stringify(e)
            ),
          vi(t, "mousedown touchstart:passive", function (e) {
            if ("mousedown" !== e.type || 1 === e.buttons) {
              e.stopPropagation(),
                e.preventDefault(),
                t.classList.add("pressed"),
                (i = Date.now()),
                "touchstart" === e.type && (r = e.changedTouches[0].identifier);
              const n = t.getAttribute(
                "data-" + s.config.namespace + "command-pressed"
              );
              n && s.$perform(JSON.parse(n));
              const l = t.getAttribute(
                "data-" + s.config.namespace + "command-pressAndHoldStart"
              );
              l &&
                ((a = t),
                o && clearTimeout(o),
                (o = window.setTimeout(function () {
                  t.classList.contains("pressed") && s.$perform(JSON.parse(l));
                }, 300)));
            }
          }),
          vi(t, "mouseleave touchcancel", function () {
            t.classList.remove("pressed");
          }),
          vi(t, "touchmove:passive", function (t) {
            t.preventDefault();
            for (let e = 0; e < t.changedTouches.length; e++)
              if (t.changedTouches[e].identifier === r) {
                const s = document.elementFromPoint(
                  t.changedTouches[e].clientX,
                  t.changedTouches[e].clientY
                );
                s !== n &&
                  n &&
                  (n.dispatchEvent(new MouseEvent("mouseleave"), {
                    bubbles: !0,
                  }),
                  (n = null)),
                  s &&
                    ((n = s),
                    s.dispatchEvent(
                      new MouseEvent("mouseenter", {
                        bubbles: !0,
                        buttons: 1,
                      })
                    ));
              }
          }),
          vi(t, "mouseenter", function (e) {
            1 === e.buttons && t.classList.add("pressed");
          }),
          vi(t, "mouseup touchend click", function (e) {
            if (n) {
              e.stopPropagation(), e.preventDefault();
              const t = n;
              return (
                (n = null),
                void t.dispatchEvent(
                  new MouseEvent("mouseup", {
                    bubbles: !0,
                  })
                )
              );
            }
            if (
              (t.classList.remove("pressed"),
              t.classList.add("active"),
              "click" === e.type && 0 !== e.detail)
            )
              return e.stopPropagation(), void e.preventDefault();
            window.setTimeout(function () {
              t.classList.remove("active");
            }, 150);
            let r = t.getAttribute(
              "data-" + s.config.namespace + "command-pressAndHoldEnd"
            );
            const o = Date.now();
            (t !== a || o < i + 300) && (r = void 0),
              !r &&
                e.altKey &&
                e.shiftKey &&
                (r = t.getAttribute(
                  "data-" + s.config.namespace + "command-altshift"
                )),
              !r &&
                e.altKey &&
                (r = t.getAttribute(
                  "data-" + s.config.namespace + "command-alt"
                )),
              !r &&
                e.shiftKey &&
                (r = t.getAttribute(
                  "data-" + s.config.namespace + "command-shift"
                )),
              r ||
                (r = t.getAttribute("data-" + s.config.namespace + "command")),
              r && s.$perform(JSON.parse(r)),
              e.stopPropagation(),
              e.preventDefault();
          });
      }
      _makeButton(t, e, s, i) {
        const a = document.createElement("span");
        return (
          (a.innerHTML = t),
          e && a.classList.add([].slice.call(e.split(" "))),
          s && a.setAttribute("aria-label", s),
          this._attachButtonHandlers(a, i),
          a
        );
      }
      showAlternateKeys_(t, e) {
        const s = wi(
          "mathlive-alternate-keys-panel",
          "ML__keyboard alternate-keys"
        );
        this.virtualKeyboard.classList.contains("material") &&
          s.classList.add("material"),
          e.length >= 7
            ? (s.style.width = "286px")
            : 4 === e.length || 2 === e.length
            ? (s.style.width = "146px")
            : 1 === e.length
            ? (s.style.width = "86px")
            : (s.style.width = "146px"),
          (s.style.height = "auto");
        let i = "";
        for (const t of e)
          (i += "<li"),
            "string" == typeof t
              ? (i += ' data-latex="' + t.replace(/"/g, "&quot;") + '"')
              : (t.latex &&
                  (i +=
                    ' data-latex="' + t.latex.replace(/"/g, "&quot;") + '"'),
                t.content &&
                  (i +=
                    ' data-content="' +
                    t.content.replace(/"/g, "&quot;") +
                    '"'),
                t.insert &&
                  (i +=
                    ' data-insert="' + t.insert.replace(/"/g, "&quot;") + '"'),
                t.command &&
                  (i +=
                    " data-command='" +
                    t.command.replace(/"/g, "&quot;") +
                    "'"),
                t.aside &&
                  (i +=
                    ' data-aside="' + t.aside.replace(/"/g, "&quot;") + '"'),
                t.classes && (i += ' data-classes="' + t.classes + '"')),
            (i += ">"),
            (i += t.label || ""),
            (i += "</li>");
        (i = "<ul>" + i + "</ul>"),
          (s.innerHTML = i),
          ps.makeKeycap(
            this,
            s.getElementsByTagName("li"),
            "performAlternateKeys"
          );
        const a = this.virtualKeyboard
          .querySelector(
            'div.keyboard-layer.is-visible div.rows ul li[data-alt-keys="' +
              t +
              '"]'
          )
          .getBoundingClientRect();
        if (a) {
          a.top - s.clientHeight < 0 &&
            ((s.style.width = "auto"),
            e.length <= 6
              ? (s.style.height = "56px")
              : e.length <= 12
              ? (s.style.height = "108px")
              : (s.style.height = "205px"));
          const t = (a.top - s.clientHeight + 5).toString() + "px",
            i =
              Math.max(
                0,
                Math.min(
                  window.innerWidth - s.offsetWidth,
                  (a.left + a.right - s.offsetWidth) / 2
                )
              ) + "px";
          (s.style.transform = "translate(" + i + "," + t + ")"),
            s.classList.add("is-visible");
        }
        return !1;
      }
      hideAlternateKeys_() {
        const t = document.getElementById("mathlive-alternate-keys-panel");
        return (
          t && (t.classList.remove("is-visible"), (t.innerHTML = ""), Si(t)), !1
        );
      }
      performAlternateKeys_(t) {
        return this.hideAlternateKeys_(), this.$perform(t);
      }
      switchKeyboardLayer_(t) {
        if ("off" !== this.config.virtualKeyboardMode) {
          "lower-command" !== t &&
            "upper-command" !== t &&
            "symbols-command" !== t &&
            this.complete_(),
            this.showVirtualKeyboard_(),
            this.hideAlternateKeys_(),
            this.unshiftKeyboardLayer_();
          const e =
            this.virtualKeyboard.getElementsByClassName("keyboard-layer");
          let s = !1;
          for (let i = 0; i < e.length; i++)
            if (e[i].dataset.layer === t) {
              s = !0;
              break;
            }
          if (s)
            for (let s = 0; s < e.length; s++)
              e[s].dataset.layer === t
                ? e[s].classList.add("is-visible")
                : e[s].classList.remove("is-visible");
          this.$focus();
        }
        return !0;
      }
      shiftKeyboardLayer_() {
        const t = this.virtualKeyboard.querySelectorAll(
          "div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action"
        );
        if (t)
          for (let e = 0; e < t.length; e++) {
            const s = t[e];
            let i = s.getAttribute("data-shifted");
            if (i || /^[a-z]$/.test(s.innerHTML)) {
              s.setAttribute("data-unshifted-content", s.innerHTML),
                i || (i = s.innerHTML.toUpperCase()),
                (s.innerHTML = i);
              const t = s.getAttribute(
                "data-" + this.config.namespace + "command"
              );
              if (t) {
                s.setAttribute("data-unshifted-command", t);
                const e = s.getAttribute("data-shifted-command");
                if (e)
                  s.setAttribute(
                    "data-" + this.config.namespace + "command",
                    e
                  );
                else {
                  const e = JSON.parse(t);
                  Array.isArray(e) && (e[1] = e[1].toUpperCase()),
                    s.setAttribute(
                      "data-" + this.config.namespace + "command",
                      JSON.stringify(e)
                    );
                }
              }
            }
          }
        return !1;
      }
      unshiftKeyboardLayer_() {
        const t = this.virtualKeyboard.querySelectorAll(
          "div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action"
        );
        if (t)
          for (let e = 0; e < t.length; e++) {
            const s = t[e],
              i = s.getAttribute("data-unshifted-content");
            i && (s.innerHTML = i);
            const a = s.getAttribute("data-unshifted-command");
            a && s.setAttribute("data-" + this.config.namespace + "command", a);
          }
        return !1;
      }
      insertAndUnshiftKeyboardLayer_(t) {
        return this.$insert(t), this.unshiftKeyboardLayer_(), !0;
      }
      toggleVirtualKeyboardAlt_() {
        let t = !1;
        return (
          this.virtualKeyboard &&
            ((t = this.virtualKeyboard.classList.contains("material")),
            this.virtualKeyboard.remove(),
            delete this.virtualKeyboard,
            (this.virtualKeyboard = null)),
          this.showVirtualKeyboard_(t ? "" : "material"),
          !1
        );
      }
      toggleVirtualKeyboardShift_() {
        this.config.virtualKeyboardLayout = {
          qwerty: "azerty",
          azerty: "qwertz",
          qwertz: "dvorak",
          dvorak: "colemak",
          colemak: "qwerty",
        }[this.config.virtualKeyboardLayout];
        let t = this.virtualKeyboard
          ? this.virtualKeyboard.querySelector("div.keyboard-layer.is-visible")
          : null;
        return (
          (t = t ? t.id : ""),
          this.virtualKeyboard &&
            (this.virtualKeyboard.remove(),
            delete this.virtualKeyboard,
            (this.virtualKeyboard = null)),
          this.showVirtualKeyboard_(),
          t && this.switchKeyboardLayer_(t),
          !1
        );
      }
      showVirtualKeyboard_(t) {
        return (
          (this.virtualKeyboardVisible = !1), this.toggleVirtualKeyboard_(t), !1
        );
      }
      hideVirtualKeyboard_() {
        return (
          (this.virtualKeyboardVisible = !0), this.toggleVirtualKeyboard_(), !1
        );
      }
      toggleVirtualKeyboard_(t) {
        return (
          (this.virtualKeyboardVisible = !this.virtualKeyboardVisible),
          this.virtualKeyboardVisible
            ? (this.virtualKeyboard
                ? this.virtualKeyboard.classList.add("is-visible")
                : ((this.virtualKeyboard = ps.make(this, t)),
                  vi(
                    this.virtualKeyboard,
                    "touchstart:passive mousedown",
                    () => {
                      this.$focus();
                    }
                  ),
                  document.body.appendChild(this.virtualKeyboard)),
              window.setTimeout(() => {
                this.virtualKeyboard.classList.add("is-visible");
              }, 1))
            : this.virtualKeyboard &&
              this.virtualKeyboard.classList.remove("is-visible"),
          "function" == typeof this.config.onVirtualKeyboardToggle &&
            this.config.onVirtualKeyboardToggle(
              this,
              this.virtualKeyboardVisible,
              this.virtualKeyboard
            ),
          !1
        );
      }
      $applyStyle(t) {
        if (
          (this._resetKeystrokeBuffer(),
          (t = (function (t) {
            const e = {};
            return (
              "string" == typeof t.mode && (e.mode = t.mode.toLowerCase()),
              "string" == typeof t.color && (e.color = t.color),
              "string" == typeof t.backgroundColor &&
                (e.backgroundColor = t.backgroundColor),
              "string" == typeof t.fontFamily && (e.fontFamily = t.fontFamily),
              "string" == typeof t.series && (e.fontSeries = t.series),
              "string" == typeof t.fontSeries &&
                (e.fontSeries = t.fontSeries.toLowerCase()),
              e.fontSeries &&
                (e.fontSeries =
                  {
                    bold: "b",
                    medium: "m",
                    normal: "mn",
                  }[e.fontSeries] || e.fontSeries),
              "string" == typeof t.shape && (e.fontShape = t.shape),
              "string" == typeof t.fontShape &&
                (e.fontShape = t.fontShape.toLowerCase()),
              e.fontShape &&
                (e.fontShape =
                  {
                    italic: "it",
                    up: "n",
                    upright: "n",
                    normal: "n",
                  }[e.fontShape] || e.fontShape),
              "string" == typeof t.size
                ? (e.fontSize = t.size)
                : "number" == typeof t.size &&
                  (e.fontSize = "size" + Math.min(0, Math.max(10, t.size))),
              "string" == typeof t.fontSize &&
                (e.fontSize = t.fontSize.toLowerCase()),
              e.fontSize &&
                (e.fontSize =
                  {
                    tiny: "size1",
                    scriptsize: "size2",
                    footnotesize: "size3",
                    small: "size4",
                    normal: "size5",
                    normalsize: "size5",
                    large: "size6",
                    Large: "size7",
                    LARGE: "size8",
                    huge: "size9",
                    Huge: "size10",
                  }[e.fontSize] || e.fontSize),
              e
            );
          })(t)).mode)
        ) {
          if (this.mathlist.isCollapsed()) this.switchMode_(t.mode);
          else {
            const t = this.mode,
              e =
                "math" === (this.mathlist.anchorMode() || this.config.default)
                  ? "text"
                  : "math";
            let s = this.$selectedText("ASCIIMath");
            if (
              ("math" === e && /^"[^"]+"$/.test(s) && (s = s.slice(1, -1)),
              this.$insert(s, {
                mode: e,
                selectionMode: "item",
                format: "text" === e ? "text" : "ASCIIMath",
              }),
              (this.mode = e),
              this.groupIsSelected())
            ) {
              const t = this.mathlist.parent();
              !t || ("group" !== t.type && "root" !== t.type) || (t.mode = e);
            }
            this.mode !== t &&
              "function" == typeof this.config.onModeChange &&
              this.config.onModeChange(this, this.mode);
          }
          delete t.mode;
        }
        return (
          this.mathlist.isCollapsed()
            ? (this.style.fontSeries &&
                t.fontSeries === this.style.fontSeries &&
                (t.fontSeries = "auto"),
              t.fontShape &&
                t.fontShape === this.style.fontShape &&
                (t.fontShape = "auto"),
              t.color && t.color === this.style.color && (t.color = "none"),
              t.backgroundColor &&
                t.backgroundColor === this.style.backgroundColor &&
                (t.backgroundColor = "none"),
              t.fontSize &&
                t.fontSize === this.style.fontSize &&
                (t.fontSize = "auto"),
              (this.style = {
                ...this.style,
                ...t,
              }))
            : (this.mathlist._applyStyle(t),
              this.undoManager.snapshot(this.config)),
          !0
        );
      }
      $hasFocus() {
        return document.hasFocus() && document.activeElement === this.textarea;
      }
      $focus() {
        this.$hasFocus() ||
          (this.textarea.focus && this.textarea.focus(),
          this._announce("line"));
      }
      $blur() {
        this.$hasFocus() && this.textarea.blur && this.textarea.blur();
      }
      $select() {
        this.mathlist.selectAll_();
      }
      $clearSelection() {
        this.mathlist.delete_();
      }
      $keystroke(t, e) {
        return this._onKeystroke(t, e);
      }
      $typedText(t) {
        this._onTypedText(t);
      }
      typedText_(t, e) {
        return this._onTypedText(t, e);
      }
      $setConfig(t) {
        if (
          (this.config ||
            (this.config = {
              namespace: "",
              overrideDefaultInlineShortcuts: !1,
              readOnly: !1,
              removeExtraneousParentheses: !0,
              scriptDepth: [1 / 0, 1 / 0],
              smartFence: !0,
              smartSuperscript: !0,
              virtualKeyboard: "",
              virtualKeyboardLayout: "qwerty",
            }),
          (this.config = {
            ...this.config,
            ...t,
          }),
          void 0 !== this.config.scriptDepth &&
            !Array.isArray(this.config.scriptDepth))
        ) {
          const t = parseInt(this.config.scriptDepth);
          this.config.scriptDepth = [t, t];
        }
        if (
          (void 0 === this.config.removeExtraneousParentheses &&
            (this.config.removeExtraneousParentheses = !0),
          (this.config.onAnnounce = t.onAnnounce || zi),
          (this.config.macros = Object.assign({}, J, this.config.macros)),
          !/^[a-z]*[-]?$/.test(this.config.namespace))
        )
          throw Error(
            "options.namespace must be a string of lowercase characters only"
          );
        /-$/.test(this.config.namespace) || (this.config.namespace += "-"),
          (is.locale = this.config.locale || is.locale),
          is.merge(this.config.strings),
          (this.config.virtualKeyboardLayout =
            t.virtualKeyboardLayout ||
            {
              fr: "azerty",
              be: "azerty",
              al: "qwertz",
              ba: "qwertz",
              cz: "qwertz",
              de: "qwertz",
              hu: "qwertz",
              sk: "qwertz",
              ch: "qwertz",
            }[is.locale.substring(0, 2)] ||
            "qwerty"),
          (this.config.letterShapeStyle &&
            "auto" !== this.config.letterShapeStyle) ||
            ("fr" === is.locale.substring(0, 2)
              ? (this.config.letterShapeStyle = "french")
              : (this.config.letterShapeStyle = "tex")),
          (this.keypressSound = void 0),
          (this.spacebarKeypressSound = void 0),
          (this.returnKeypressSound = void 0),
          (this.deleteKeypressSound = void 0),
          this.config.keypressSound &&
            ("string" == typeof this.config.keypressSound
              ? ((this.keypressSound = new Audio()),
                (this.keypressSound.preload = "none"),
                (this.keypressSound.src = this.config.keypressSound),
                (this.keypressSound.volume = 0.5),
                (this.spacebarKeypressSound = this.keypressSound),
                (this.returnKeypressSound = this.keypressSound),
                (this.deleteKeypressSound = this.keypressSound))
              : ((this.keypressSound = new Audio()),
                (this.keypressSound.preload = "none"),
                (this.keypressSound.src = this.config.keypressSound.default),
                (this.keypressSound.volume = 0.5),
                (this.spacebarKeypressSound = this.keypressSound),
                (this.returnKeypressSound = this.keypressSound),
                (this.deleteKeypressSound = this.keypressSound),
                this.config.keypressSound.spacebar &&
                  ((this.spacebarKeypressSound = new Audio()),
                  (this.spacebarKeypressSound.preload = "none"),
                  (this.spacebarKeypressSound.src =
                    this.config.keypressSound.spacebar),
                  (this.spacebarKeypressSound.volume = 0.5)),
                this.config.keypressSound.return &&
                  ((this.returnKeypressSound = new Audio()),
                  (this.returnKeypressSound.preload = "none"),
                  (this.returnKeypressSound.src =
                    this.config.keypressSound.return),
                  (this.returnKeypressSound.volume = 0.5)),
                this.config.keypressSound.delete &&
                  ((this.deleteKeypressSound = new Audio()),
                  (this.deleteKeypressSound.preload = "none"),
                  (this.deleteKeypressSound.src =
                    this.config.keypressSound.delete),
                  (this.deleteKeypressSound.volume = 0.5)))),
          this.config.plonkSound &&
            ((this.plonkSound = new Audio()),
            (this.plonkSound.preload = "none"),
            (this.plonkSound.src = this.config.plonkSound),
            (this.plonkSound.volume = 0.5)),
          this.readOnly && this._onBlur(),
          this._requestUpdate();
      }
      speak_(t, e) {
        e = e || {
          withHighlighting: !1,
        };
        const s = (function (t, e) {
          let s = null;
          switch (e) {
            case "all":
              s = t.mathlist.root;
              break;
            case "selection":
              t.mathlist.isCollapsed() || (s = t.mathlist.getSelectedAtoms());
              break;
            case "left": {
              const e = t.mathlist.siblings(),
                i = t.mathlist.startOffset();
              if (i >= 1) {
                s = [];
                for (let t = 1; t <= i; t++) s.push(e[t]);
              }
              break;
            }
            case "right": {
              const e = t.mathlist.siblings(),
                i = t.mathlist.endOffset() + 1;
              if (i <= e.length - 1) {
                s = [];
                for (let t = i; t <= e.length - 1; t++) s.push(e[t]);
              }
              break;
            }
            case "start":
            case "end":
              break;
            case "group":
              s = t.mathlist.siblings();
              break;
            case "parent": {
              const e = t.mathlist.parent();
              e && "root" !== e.type && (s = t.mathlist.parent());
              break;
            }
          }
          return s;
        })(this, t);
        if (null === s)
          return (
            this.config.handleSpeak(
              (function (t) {
                let e = "";
                switch (t) {
                  case "all":
                    break;
                  case "selection":
                    e = "no selection";
                    break;
                  case "left":
                    e = "at start";
                    break;
                  case "right":
                    e = "at end";
                    break;
                  case "group":
                    break;
                  case "parent":
                    e = "no parent";
                }
                return e;
              })(t)
            ),
            !1
          );
        const i = {
          ...this.config,
        };
        (e.withHighlighting || "amazon" === i.speechEngine) &&
          ((i.textToSpeechMarkup =
            window.sre && "sre" === i.textToSpeechRules ? "ssml_step" : "ssml"),
          e.withHighlighting &&
            (i.atomIdsSettings = {
              seed: "random",
            }));
        const a = Zt.toSpeakableText(s, i);
        return (
          e.withHighlighting
            ? ((window.mathlive.readAloudMathField = this),
              this._render({
                forHighlighting: !0,
              }),
              this.config.handleReadAloud &&
                this.config.handleReadAloud(this.field, a, this.config))
            : this.config.handleSpeak && this.config.handleSpeak(a, i),
          !1
        );
      }
    }

    function Li(t, e, s) {
      const i = Object.assign({}, t.config);
      return (
        (i.textToSpeechMarkup = ""),
        (i.textToSpeechRulesOptions = i.textToSpeechRulesOptions || {}),
        (i.textToSpeechRulesOptions.markup = "none"),
        e + Zt.toSpeakableText(s, i)
      );
    }

    function zi(t, e, s, i) {
      let a = "";
      "plonk" === e
        ? (t.plonkSound &&
            (t.plonkSound.load(), t.plonkSound.play().catch((t) => {})),
          t._resetKeystrokeBuffer())
        : "delete" === e
        ? (a = Li(t, "deleted: ", i))
        : "focus" === e || /move/.test(e)
        ? (a =
            (t.mathlist.isCollapsed() ? "" : "selected: ") +
            t._nextAtomSpeechText(s))
        : "replacement" === e
        ? (a = Li(t, "", t.mathlist.sibling(0)))
        : "line" === e
        ? ((a = Li(t, "", t.mathlist.root)),
          (t.accessibleNode.innerHTML =
            '<math xmlns="http://www.w3.org/1998/Math/MathML">' +
            Zt.toMathML(t.mathlist.root, t.config) +
            "</math>"),
          t.textarea.setAttribute("aria-label", "after: " + a))
        : (a = i ? Li(t, e + " ", i) : e);
      const r = /\u00a0/.test(t.ariaLiveText.textContent) ? "   " : "   ";
      t.ariaLiveText.textContent = a + r;
    }

    function $i(t, e, s) {
      let i = s,
        a = 0;
      const r = t.length;
      for (; i < e.length; ) {
        const s = e[i];
        if (a <= 0 && e.slice(i, i + r) === t) return i;
        "\\" === s ? i++ : "{" === s ? a++ : "}" === s && a--, i++;
      }
      return -1;
    }

    function Ti(t, e, s, i) {
      const a = [];
      for (let r = 0; r < t.length; r++)
        if ("text" === t[r].type) {
          const n = t[r].data;
          let o,
            l = !0,
            c = 0;
          (o = n.indexOf(e)),
            -1 !== o &&
              ((c = o),
              c > 0 &&
                a.push({
                  type: "text",
                  data: n.slice(0, c),
                }),
              (l = !1));
          let h = !1;
          for (; !h; ) {
            if (l) {
              if (((o = n.indexOf(e, c)), -1 === o)) {
                h = !0;
                break;
              }
              c !== o &&
                a.push({
                  type: "text",
                  data: n.slice(c, o),
                }),
                (c = o);
            } else {
              if (((o = $i(s, n, c + e.length)), -1 === o)) {
                h = !0;
                break;
              }
              a.push({
                type: "math",
                data: n.slice(c + e.length, o),
                rawData: n.slice(c, o + s.length),
                mathstyle: i,
              }),
                (c = o + s.length);
            }
            l = !l;
          }
          c < n.length &&
            a.push({
              type: "text",
              data: n.slice(c),
            });
        } else a.push(t[r]);
      return a;
    }

    function Di(t, e) {
      let s = [
        {
          type: "text",
          data: t,
        },
      ];
      for (let t = 0; t < e.inline.length; t++) {
        const i = e.inline[t];
        s = Ti(s, i[0], i[1], "textstyle");
      }
      for (let t = 0; t < e.display.length; t++) {
        const i = e.display[t];
        s = Ti(s, i[0], i[1], "displaystyle");
      }
      return s;
    }

    function Fi(t, e, s, i) {
      const a = (function (t, e, s, i) {
        let a = document.createElement("span");
        a.setAttribute("aria-hidden", "true"),
          e.preserveOriginalContent &&
            (a.setAttribute("data-" + e.namespace + "original-content", t),
            s &&
              a.setAttribute("data-" + e.namespace + "original-mathstyle", s));
        try {
          a.innerHTML = e.renderToMarkup(t, {
            mathstyle: s || "displaystyle",
            format: "html",
            macros: e.macros,
          });
        } catch (e) {
          if (!i) return null;
          a = document.createTextNode(t);
        }
        return a;
      })(t, s, e, i);
      if (a && /\b(mathml|speakable-text)\b/i.test(s.renderAccessibleContent)) {
        const e = document.createDocumentFragment();
        if (
          (/\bmathml\b/i.test(s.renderAccessibleContent) &&
            s.renderToMathML &&
            e.appendChild(
              (function (t, e) {
                const s = document.createElement("span");
                try {
                  s.innerHTML =
                    "<math xmlns='http://www.w3.org/1998/Math/MathML'>" +
                    e.renderToMathML(t, e) +
                    "</math>";
                } catch (e) {
                  s.textContent = t;
                }
                return (s.className = "sr-only"), s;
              })(t, s)
            ),
          /\bspeakable-text\b/i.test(s.renderAccessibleContent) &&
            s.renderToSpeakableText)
        ) {
          const i = document.createElement("span");
          (i.innerHTML = s.renderToSpeakableText(t, s)),
            (i.className = "sr-only"),
            e.appendChild(i);
        }
        return e.appendChild(a), e;
      }
      return a;
    }

    function qi(t, e) {
      let s = null;
      if (e.TeX.processEnvironments && /^\s*\\begin/.test(t))
        (s = document.createDocumentFragment()),
          s.appendChild(Fi(t, void 0, e, !0));
      else {
        const i = Di(t, e.TeX.delimiters);
        if (1 === i.length && "text" === i[0].type) return null;
        s = document.createDocumentFragment();
        for (let t = 0; t < i.length; t++)
          "text" === i[t].type
            ? s.appendChild(document.createTextNode(i[t].data))
            : s.appendChild(Fi(i[t].data, i[t].mathstyle, e, !0));
      }
      return s;
    }
    (Ci.prototype.undo_ = Ci.prototype.undo),
      (Ci.prototype.redo_ = Ci.prototype.redo),
      (Ci.prototype.scrollIntoView_ = Ci.prototype.scrollIntoView),
      (Ci.prototype.scrollToStart_ = Ci.prototype.scrollToStart),
      (Ci.prototype.scrollToEnd_ = Ci.prototype.scrollToEnd),
      (Ci.prototype.insert_ = Ci.prototype.$insert);
    const Ei = {
      namespace: "",
      skipTags: [
        "noscript",
        "style",
        "textarea",
        "pre",
        "code",
        "annotation",
        "annotation-xml",
      ],
      processScriptType: "math/tex",
      ignoreClass: "tex2jax_ignore",
      processClass: "tex2jax_process",
      preserveOriginalContent: !0,
      renderAccessibleContent: "mathml",
      TeX: {
        disabled: !1,
        processEnvironments: !0,
        delimiters: {
          inline: [["\\(", "\\)"]],
          display: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
        },
      },
    };
    var Pi = {
      renderMathInElement: function (t, e) {
        try {
          if (
            (((e = Object.assign({}, Ei, e)).ignoreClassPattern = new RegExp(
              e.ignoreClass
            )),
            (e.processClassPattern = new RegExp(e.processClass)),
            (e.processScriptTypePattern = new RegExp(e.processScriptType)),
            (e.macros = J),
            e.namespace)
          ) {
            if (!/^[a-z]+[-]?$/.test(e.namespace))
              throw Error(
                "options.namespace must be a string of lowercase characters only"
              );
            /-$/.test(e.namespace) || (e.namespace += "-");
          }
          !(function t(e, s) {
            const i = e.getAttribute(
              "data-" + s.namespace + "original-content"
            );
            if (i) {
              const t = Fi(
                i,
                e.getAttribute("data-" + s.namespace + "mathstyle"),
                s,
                !1
              );
              null != t && ((e.textContent = ""), e.appendChild(t));
            } else {
              if (1 === e.childNodes.length && 3 === e.childNodes[0].nodeType) {
                const t = e.childNodes[0].textContent;
                if (s.TeX.processEnvironments && /^\s*\\begin/.test(t))
                  return (
                    (e.textContent = ""),
                    void e.appendChild(Fi(t, void 0, s, !0))
                  );
                const i = Di(t, s.TeX.delimiters);
                if (1 === i.length && "math" === i[0].type)
                  return (
                    (e.textContent = ""),
                    void e.appendChild(Fi(i[0].data, i[0].mathstyle, s, !0))
                  );
                if (1 === i.length && "text" === i[0].type) return;
              }
              for (let i = 0; i < e.childNodes.length; i++) {
                const a = e.childNodes[i];
                if (3 === a.nodeType) {
                  const t = qi(a.textContent, s);
                  t && ((i += t.childNodes.length - 1), e.replaceChild(t, a));
                } else if (1 === a.nodeType) {
                  const e = a.nodeName.toLowerCase();
                  if (
                    "script" === e &&
                    s.processScriptTypePattern.test(a.type)
                  ) {
                    let t = "displaystyle";
                    for (const e of a.type.split(";")) {
                      const s = e.split("=");
                      "mode" === s[0].toLowerCase() &&
                        (t =
                          "display" === s[1].toLoweCase()
                            ? "displaystyle"
                            : "textstyle");
                    }
                    const e = Fi(a.textContent, t, s, !0);
                    a.parentNode.replaceChild(e, a);
                  } else
                    "script" !== e &&
                      (s.processClassPattern.test(a.className) ||
                        (!s.skipTags.includes(e) &&
                          !s.ignoreClassPattern.test(a.className))) &&
                      t(a, s);
                }
              }
            }
          })(t, e);
        } catch (t) {
          Error;
        }
      },
    };

    function Bi(t, e) {
      if (!t) return null;
      let s = null;
      Array.isArray(e) && ((s = e.slice()), (e = s.shift()));
      let i = null;
      if ("number" == typeof e && e < t.length)
        return s && s.length > 0 ? Bi(t[e].children, s) : t[e];
      if ("string" == typeof e) {
        for (let a = 0; a < t.length; a++) {
          if (t[a].body === e)
            return s && s.length > 0 ? Bi(t[a].children, s) : t[a];
          if (((i = Bi(t[a].children, e)), i)) return i;
        }
        return i;
      }
      return null;
    }

    function Ki(t, e) {
      const s = Bi(t, e);
      return s ? s.classes || "" : null;
    }

    function Oi(t, e, s) {
      const i = t[e];
      return "string" == typeof i
        ? s + e + ':"' + i + '",\n'
        : "boolean" == typeof i || "number" == typeof i
        ? s + e + ":" + i + ",\n"
        : Array.isArray(i)
        ? s + e + ":" + Ri(i, s + "\t") + ",\n"
        : "";
    }

    function Ri(t, e) {
      if (!t) return "";
      e = e || "";
      let s = "";
      if (Array.isArray(t)) {
        if (0 === t.length) return "";
        s += "[\n";
        for (let i = 0; i < t.length; i++) s += Ri(t[i], e + "\t") + ",\n";
        s += e + "]\n";
      } else
        (s = e + "{\n"),
          (s += Oi(t, "type", e)),
          (s += Oi(t, "value", e)),
          (s += Oi(t, "fontFamily", e)),
          (s += Oi(t, "hasBarLine", e)),
          (s += Oi(t, "leftDelim", e)),
          (s += Oi(t, "rightDelim", e)),
          (s += Oi(t, "numer", e)),
          (s += Oi(t, "denom", e)),
          (s += Oi(t, "limits", e)),
          (s += Oi(t, "symbol", e)),
          (s += Oi(t, "framecolor", e)),
          (s += Oi(t, "position", e)),
          (s += Oi(t, "mathstyle", e)),
          (s += Oi(t, "superscript", e)),
          (s += Oi(t, "subscript", e)),
          (s += Oi(t, "body", e)),
          (s += Oi(t, "array", e)),
          (s += e + "}");
      return s;
    }

    function Ii(t, e) {
      let s = "";
      return (
        t[e] &&
          ((s += '<span class="styleprop">' + e + "=</span>"),
          (s += '<span class="stylevalue">'),
          (s += t[e]),
          (s += '</span>" ')),
        s
      );
    }
    var Ni = {
      mathlistToMarkup: function t(e, s) {
        if (!e) return "";
        s = s || "";
        let i = "";
        if (Array.isArray(e))
          for (let a = 0; a < e.length; a++) i += t(e[a], a + "." + s);
        else if (
          ((i = "<br>" + s),
          e.type &&
            ((i += '<span class="type'),
            (i += e.isSelected ? " selected" : ""),
            (i += e.caret ? " caret" : ""),
            (i += '">' + e.type + (e.caret ? " caret " : "") + "</span>")),
          "string" == typeof e.body &&
            e.body.length > 0 &&
            ((i += '&nbsp;<span class="value">'),
            (i += e.body),
            (e.body.charCodeAt(0) < 32 || e.body.charCodeAt(0) > 127) &&
              (i +=
                "&nbsp;U+" +
                ("000000" + e.body.charCodeAt(0).toString(16)).substr(-6)),
            (i += "</span>&nbsp;")),
          "mathrm" === e.fontFamily
            ? ((i += '<span style="opacity:.2">'),
              (i += Ii(e, "fontFamily")),
              (i += "</span>"))
            : (i += Ii(e, "fontFamily")),
          (i += Ii(e, "hasBarLine")),
          (i += Ii(e, "leftDelim")),
          (i += Ii(e, "rightDelim")),
          (i += Ii(e, "continuousFraction")),
          (i += Ii(e, "limits")),
          (i += Ii(e, "symbol")),
          (i += (function (t, e) {
            let s = "";
            return (
              t.framecolor &&
                ((s += '<span class="styleprop">framecolor=</span>'),
                (s +=
                  '<span style="font-size:2em;vertical-align:middle;color:' +
                  t.framecolor +
                  '">&#9632;</span>'),
                (s += '<span class="stylevalue">'),
                (s += t.framecolor),
                (s += "</span>")),
              s
            );
          })(e)),
          (i += Ii(e, "mathstyle")),
          (i += Ii(e, "size")),
          (i += Ii(e, "cls")),
          (i += Ii(e, "delim")),
          (i += Ii(e, "shift")),
          (i += Ii(e, "width")),
          (i += Ii(e, "height")),
          (i += Ii(e, "position")),
          (i += t(e.overscript, s + "↑")),
          (i += t(e.underscript, s + "↓")),
          (i += t(e.superscript, s + "↑")),
          (i += t(e.subscript, s + "↓")),
          (i += t(e.body, s + "▶")),
          (i += t(e.numer, s + "▲")),
          (i += t(e.denom, s + "▼")),
          e.array)
        )
          for (let a = 0; a < e.array.length; a++) {
            i += "<br>" + s + "⌗ row " + (a + 1) + "/" + e.array.length;
            for (let r = 0; r < e.array[a].length; r++)
              i += t(e.array[a][r], s + "⌗〉");
          }
        return i;
      },
      spanToMarkup: function t(e, s) {
        s = s || "";
        let i = "";
        if (Array.isArray(e))
          for (let a = 0; a < e.length; a++) i += t(e[a], s);
        else if (e && "table" !== e.tag)
          if (((i = "<br>" + s), e.classes.includes("fontsize-ensurer")))
            i += "FONTSIZE-ENSURER";
          else {
            if (
              (e.type && (i += '<span class="type">' + e.type + "</span>"),
              e.body &&
                e.body.length > 0 &&
                (i += '<span class="value">' + e.body + "</span>"),
              e.classes &&
                e.classes.length > 0 &&
                (i += '&nbsp;<span class="classes">' + e.classes + "</span>"),
              e.isTight &&
                (i += '&nbsp;<span class="stylevalue"> tight </span>'),
              e.caret && (i += '&nbsp;<span class="stylevalue"> caret </span>'),
              e.style)
            )
              for (const t in e.style)
                Object.prototype.hasOwnProperty.call(e.style, t) &&
                  ((i += '&nbsp;<span class="styleprop">' + t + ":</span>"),
                  (i +=
                    '<span class="stylevalue"> ' +
                    e.style[t] +
                    "</span>;&nbsp;"));
            e.children && (i += t(e.children, s + "▷"));
          }
        else if (e) {
          i +=
            "<br>" +
            s +
            "table " +
            e.array[0].length +
            "&times;" +
            e.array.length;
          for (let a = 0; a < e.array.length; a++)
            for (let r = 0; r < e.array[a].length; r++)
              (i += "<br>" + s + "[" + (a + 1) + ", " + (r + 1) + "] "),
                (i += t(e.array[a][r], ""));
        }
        return i;
      },
      mathlistToString: Ri,
      spanToString: function t(e, s) {
        s = s || "";
        let i = "";
        if (Array.isArray(e))
          if (0 === e.length) i += "[]\n";
          else {
            i += "[\n";
            for (let a = 0; a < e.length; a++)
              (i += t(e[a], "\t" + s + a + ",")),
                (i += a < e.length - 1 ? ",\n" : "\n");
            i += s + "]\n";
          }
        else {
          if (
            ((i = s + "{\n"),
            e.type && (i += s + 'type:"' + e.type + '",\n'),
            e.body &&
              e.body.length > 0 &&
              (i += s + 'body:"' + e.body + '",\n'),
            e.classes &&
              e.classes.length > 0 &&
              (i += s + 'classes:"' + e.classes + '",\n'),
            e.style)
          )
            for (const t in e.style)
              Object.prototype.hasOwnProperty.call(e.style, t) &&
                ((i += s + t + ':"'), (i += e.style[t] + '",\n'));
          e.children &&
            e.children.length > 0 &&
            (i += s + "children:" + t(e.children, s)),
            (i += s + "}");
        }
        return i;
      },
      hasClass: function (t, e, s) {
        let i = Ki(t, e);
        if (!i) return !1;
        i = i.split(" ");
        for (let t = 0; t < i.length; t++) if (i[t] === s) return !0;
        return !1;
      },
      getClasses: Ki,
      getProp: function (t, e, s) {
        const i = Bi(t, e);
        return i ? i[s] : null;
      },
      getStyle: function (t, e, s) {
        const i = Bi(t, e);
        return i && i.style ? i.style[s] : null;
      },
      getType: function (t, e) {
        const s = Bi(t, e);
        return s ? s.type : null;
      },
      getTag: function (t, e) {
        const s = Bi(t, e);
        return s ? s.tag : null;
      },
      latexToAsciiMath: function (t, e) {
        return gs(ge(t, (e = e || "math"), null, null));
      },
      asciiMathToLatex: function (t) {
        const [, e] = Re(t, {
          format: "ASCIIMath",
        });
        return e;
      },
    };

    function Hi(t, e) {
      ((e = e || {}).mathstyle = e.mathstyle || "displaystyle"),
        (e.letterShapeStyle = e.letterShapeStyle || "auto");
      const s = ge(t, "math", null, e.macros);
      if ("mathlist" === e.format) return s;
      let i = Gt(
        {
          mathstyle: k[e.mathstyle],
          letterShapeStyle: e.letterShapeStyle,
        },
        s
      );
      return (
        (i = (function t(e) {
          if (!e || 0 === e.length) return [];
          e[0].children = t(e[0].children);
          const s = [e[0]];
          for (let i = 1; i < e.length; i++)
            s[s.length - 1].tryCoalesceWith(e[i]) ||
              ((e[i].children = t(e[i].children)), s.push(e[i]));
          return s;
        })(i)),
        "span" === e.format ? i : H(I(i, "ML__base"), "ML__mathlive").toMarkup()
      );
    }

    function Wi(t, e) {
      if (!Zt.toMathML) return "";
      ((e = e || {}).macros = e.macros || {}), Object.assign(e.macros, J);
      const s = ge(t, "math", null, e.macros);
      return Zt.toMathML(s, e);
    }

    function Vi(t, e) {
      if (!Zt.toSpeakableText) return "";
      ((e = e || {}).macros = e.macros || {}), Object.assign(e.macros, J);
      const s = ge(t, "math", null, e.macros);
      return Zt.toSpeakableText(s, e);
    }

    function ji(t, e) {
      if (
        (!e && window && window.mathlive && (e = window.mathlive.config),
        (e = e || {}).speechEngine && "local" !== e.speechEngine)
      )
        if ("amazon" === e.speechEngine) {
          if (window && window.AWS) {
            const s = new window.AWS.Polly({
                apiVersion: "2016-06-10",
              }),
              i = {
                OutputFormat: "mp3",
                VoiceId: e.speechEngineVoice || "Joanna",
                Text: t,
                TextType: "ssml",
              };
            s.synthesizeSpeech(i, function (t, e) {
              if (t);
              else if (e && e.AudioStream) {
                const t = new Uint8Array(e.AudioStream),
                  s = new Blob([t.buffer], {
                    type: "audio/mpeg",
                  }),
                  i = URL.createObjectURL(s);
                new Audio(i).play().catch((t) => {});
              }
            });
          }
        } else e.speechEngine;
      else {
        const e = new SpeechSynthesisUtterance(t);
        window && window.speechSynthesis.speak(e);
      }
    }

    function Ui(t, e, s) {
      if (!window) return;
      if (
        (!s && window.mathlive && (s = window.mathlive.config),
        "amazon" !== (s = s || {}).speechEngine)
      )
        return void (s.handleSpeak && s.handleSpeak(e));
      if (!window.AWS) return;
      const i = new window.AWS.Polly({
          apiVersion: "2016-06-10",
        }),
        a = {
          OutputFormat: "json",
          VoiceId: s.speechEngineVoice || "Joanna",
          Text: e,
          TextType: "ssml",
          SpeechMarkTypes: ["ssml"],
        };
      (window.mathlive = window.mathlive || {}),
        (window.mathlive.readAloudElement = t);
      const r = s.onReadAloudStatus || window.mathlive.onReadAloudStatus;
      i.synthesizeSpeech(a, function (t, e) {
        if (t);
        else if (e && e.AudioStream) {
          const t = new TextDecoder("utf-8").decode(
            new Uint8Array(e.AudioStream)
          );
          (window.mathlive.readAloudMarks = t
            .split("\n")
            .map((t) => (t ? JSON.parse(t) : {}))),
            (window.mathlive.readAloudTokens = []);
          for (const t of window.mathlive.readAloudMarks)
            t.value && window.mathlive.readAloudTokens.push(t.value);
          (window.mathlive.readAloudCurrentMark = ""),
            (a.OutputFormat = "mp3"),
            (a.SpeechMarkTypes = []),
            i.synthesizeSpeech(a, function (t, e) {
              if (t);
              else if (e && e.AudioStream) {
                const t = new Uint8Array(e.AudioStream),
                  s = new Blob([t.buffer], {
                    type: "audio/mpeg",
                  }),
                  i = URL.createObjectURL(s);
                window.mathlive.readAloudAudio
                  ? window.mathlive.readAloudAudio.pause()
                  : ((window.mathlive.readAloudAudio = new Audio()),
                    window.mathlive.readAloudAudio.addEventListener(
                      "ended",
                      () => {
                        r && r(window.mathlive.readAloudMathField, "ended"),
                          window.mathlive.readAloudMathField
                            ? (window.mathlive.readAloudMathField._render(),
                              (window.mathlive.readAloudElement = null),
                              (window.mathlive.readAloudMathField = null),
                              (window.mathlive.readAloudTokens = []),
                              (window.mathlive.readAloudMarks = []),
                              (window.mathlive.readAloudCurrentMark = ""))
                            : (function t(e) {
                                e.classList.remove("highlight"),
                                  e.children &&
                                    Array.from(e.children).forEach((e) => {
                                      t(e);
                                    });
                              })(window.mathlive.readAloudElement);
                      }
                    ),
                    window.mathlive.readAloudAudio.addEventListener(
                      "timeupdate",
                      () => {
                        let t = "";
                        const e =
                          1e3 * window.mathlive.readAloudAudio.currentTime +
                          100;
                        for (const s of window.mathlive.readAloudMarks)
                          s.time < e && (t = s.value);
                        window.mathlive.readAloudCurrentMark !== t &&
                          ((window.mathlive.readAloudCurrentToken = t),
                          t && t === window.mathlive.readAloudFinalToken
                            ? window.mathlive.readAloudAudio.pause()
                            : ((window.mathlive.readAloudCurrentMark = t),
                              (function t(e, s) {
                                s && e.dataset.atomId !== s
                                  ? (e.classList.remove("highlight"),
                                    e.children &&
                                      e.children.length > 0 &&
                                      Array.from(e.children).forEach((e) => {
                                        t(e, s);
                                      }))
                                  : (e.classList.add("highlight"),
                                    e.children &&
                                      e.children.length > 0 &&
                                      Array.from(e.children).forEach((e) => {
                                        t(e);
                                      }));
                              })(
                                window.mathlive.readAloudElement,
                                window.mathlive.readAloudCurrentMark
                              )));
                      }
                    )),
                  (window.mathlive.readAloudAudio.src = i),
                  r && r(window.mathlive.readAloudMathField, "playing"),
                  window.mathlive.readAloudAudio.play();
              }
            });
        }
      });
    }

    function Gi(t) {
      let e = t;
      if ("string" == typeof t && ((e = document.getElementById(t)), !e))
        throw Error(`The element with ID "${t}" could not be found.`);
      return e;
    }

    function Zi(t, e) {
      Pi &&
        (((e = e || {}).renderToMarkup = e.renderToMarkup || Hi),
        (e.renderToMathML = e.renderToMathML || Wi),
        (e.renderToSpeakableText = e.renderToSpeakableText || Vi),
        (e.macros = e.macros || J),
        Pi.renderMathInElement(Gi(t), e));
    }

    function Xi(t) {
      if (t.namespace) {
        if (!/^[a-z]+[-]?$/.test(t.namespace))
          throw Error(
            "options.namespace must be a string of lowercase characters only"
          );
        /-$/.test(t.namespace) || (t.namespace += "-");
      }
    }
    return {
      latexToMarkup: Hi,
      latexToMathML: Wi,
      latexToSpeakableText: Vi,
      latexToAST: function (t, e) {
        if (!Zt.toAST) return {};
        ((e = e || {}).macros = e.macros || {}), Object.assign(e.macros, J);
        const s = ge(t, "math", null, e.macros);
        return Zt.toAST(s, e);
      },
      astToLatex: function (t, e) {
        return (function t(e, s) {
          const i = Object.assign(
            {
              precision: 14,
              decimalMarker: ".",
              groupSeparator: "\\, ",
              product: "\\cdot ",
              exponentProduct: "\\cdot ",
              exponentMarker: "",
              arcSeparator: "\\,",
              scientificNotation: "auto",
              beginRepeatingDigits: "\\overline{",
              endRepeatingDigits: "}",
            },
            s
          );
          let a = "";
          if (void 0 === e) return "";
          if ("string" == typeof e) a = e;
          else if (e.latex) a = e.latex;
          else if (Zs(e)) {
            const s = Gs(e);
            if (s === -1 / 0) a = "-\\infty ";
            else if (s === 1 / 0) a = "\\infty ";
            else if (
              "object" != typeof e.num ||
              ("string" != typeof e.num.re && "string" != typeof e.num.im)
            )
              a = isNaN(s) ? "\\text{NaN}" : gi(e.num, i);
            else {
              const t = Xs(e),
                s = Ys(e);
              isNaN(t) || isNaN(s)
                ? (a = "\\text{NaN}")
                : Math.abs(s) <= Number.EPSILON && Math.abs(t) <= Number.EPSILON
                ? (a = "0")
                : (Math.abs(t) > Number.EPSILON && (a = gi(t, i)),
                  Math.abs(s) > Number.EPSILON &&
                    (Math.abs(t) > Number.EPSILON && (a += s > 0 ? "+" : ""),
                    (a +=
                      (1 !== Math.abs(s) ? gi(s, i) : "") + "\\imaginaryI ")));
            }
            Js(e) && (a += "^{" + t(e.sup, i) + "}"),
              Qs(e) && (a += "_{" + t(e.sub, i) + "}");
          } else if (e.group)
            (a = t(e.group, i)),
              Zs(e.group) || Us(e.group)
                ? 0 !== Ys(e.group) && (a = pi(e.fence || "(),", a))
                : (a = pi(e.fence || "(),", a)),
              Js(e) && (a += "^{" + t(e.sup, i) + "}"),
              Qs(e) && (a += "_{" + t(e.sub, i) + "}");
          else if (e.fn)
            if ("bind" === e.fn) {
              if (((a = t(Es(e, 0), i) + "|_{"), e.arg && 2 === e.arg.length))
                a += t(Es(e, 1));
              else {
                let s = "";
                for (let i = 1; i < e.arg.length; i += 2)
                  (a += s + t(Es(e, i)) + " = " + t(Es(e, i + 1))), (s = ", ");
              }
              a += "}";
            } else if ("divide" === e.fn)
              a = "\\frac{" + t(Es(e, 0), i) + "}{" + t(Es(e, 1), i) + "}";
            else if ("negate" === e.fn) a = "-" + t(Es(e, 0), i);
            else if ("subtract" === e.fn)
              a = t(Es(e, 0), i) + " - " + t(Es(e, 1), i);
            else if (
              ("add" !== e.fn && "multiply" !== e.fn) ||
              !Array.isArray(e.arg)
            )
              if ("list" === e.fn || "list2" === e.fn) {
                const s = [];
                for (const a of e.arg) s.push(t(a, i));
                a = s.join("list2" === e.fn ? "; " : ", ");
              } else if ("sequence" === e.fn)
                a = e.arg.map((e) => t(e, i)).join("");
              else if ("text" === e.fn) a = "\\text{" + (e.arg[0] || "") + "}";
              else if (
                "pow" === e.fn &&
                Array.isArray(e.arg) &&
                e.arg.length >= 2
              )
                (a = t(Es(e, 0), i)),
                  Zs(Es(e, 0)) || Us(Es(e, 0)) || (a = pi(e.fence || "(),", a)),
                  (a += "^{" + t(Es(e, 1), i) + "}");
              else if ("equal" === e.fn && e.arg && e.arg.length > 2)
                a = e.arg.map((e) => t(e, i)).join(" = ");
              else {
                const s = (function (t) {
                  let e = Fs[t];
                  return (
                    e ||
                      (e =
                        t.length > 1
                          ? "\\operatorname{" + t + "}%^%_ %"
                          : t + "%^%_ %"),
                    e
                  );
                })(e.fn);
                a = s;
                let r = "";
                if (
                  /%(?![01_^])/.test(s) &&
                  Array.isArray(e.arg) &&
                  e.arg.length > 1
                )
                  a += pi(e.fence || "(),", ...e.arg.map((e) => t(e, i)));
                else if (Array.isArray(e.arg) && e.arg.length > 0) {
                  const n = t(Es(e, 0), i),
                    o = t(Es(e, 1), i),
                    l = [...e.arg];
                  /%0/.test(s) && ((a = a.replace("%0", n)), l.shift()),
                    /%1/.test(s) && ((a = a.replace("%1", o)), l.shift()),
                    l.length > 0 &&
                      (r = pi(e.fence || "(),", ...l.map((e) => t(e, i))));
                } else r = pi(e.fence || "(),", "");
                (a = Js(e)
                  ? a.replace("%^", "^{" + t(e.sup, i) + "}")
                  : a.replace("%^", "")),
                  (a = Qs(e)
                    ? a.replace("%_", "_{" + t(e.sub, i) + "}")
                    : a.replace("%_", "")),
                  (a = a.replace(/%(?![01_^])/, r)),
                  (a = a.replace("%0", "").replace("%1", ""));
              }
            else {
              const s = [];
              for (const a of e.arg)
                "add" === a.fn ||
                "subtract" === a.fn ||
                (0 !== Xs((r = a)) && 0 !== Ys(r)) ||
                (Js(e) && 0 !== Ys(a) && 1 !== Ys(a))
                  ? s.push(pi("() ", t(a, i)))
                  : s.push(t(a, i));
              if ("multiply" === e.fn)
                a =
                  !e.arg ||
                  2 !== e.arg.length ||
                  (!Zs(e.arg[0]) && "divide" !== e.arg[0].fn) ||
                  (Zs(e.arg[1]) && (0 !== Xs(e.arg[1]) || 1 !== Ys(e.arg[1])))
                    ? s.join(" \\times ")
                    : s[0] + s[1];
              else if (e.arg && 1 === e.arg.length)
                a =
                  "negate" === e.arg[0].fn || (Zs(e.arg[0]) && Gs(e.arg[0]) < 0)
                    ? s[0]
                    : "+" + s[0];
              else {
                a = s[0];
                for (let t = 1; t < e.arg.length; t++)
                  "negate" === e.arg[t].fn || (Zs(e.arg[t]) && Gs(e.arg[t]) < 0)
                    ? (a += s[t])
                    : (a += " + " + s[t]);
              }
            }
          else if ("string" == typeof e.sym) {
            a = Us(e);
            let s = a.match(/^&#x([0-9a-f]+);$/i);
            s && s[1]
              ? (a = String.fromCodePoint(parseInt(s[1], 16)))
              : ((s = a.match(/^&#([0-9]+);$/i)),
                s && s[1] && (a = String.fromCodePoint(parseInt(s[1])))),
              "string" == typeof e.variant &&
                (a =
                  "\\" +
                  {
                    normal: "mathrm",
                    "double-struck": "mathbb",
                    bold: "mathbf",
                    fraktur: "mathfrak",
                    script: "mathscr",
                    "sans-serif": "mathsf",
                    monospace: "mathtt",
                  }[e.variant] +
                  "{" +
                  a +
                  "}"),
              Js(e) && (a += "^{" + t(e.sup, i) + "}"),
              Qs(e) && (a += "_{" + t(e.sub, i) + "}");
          } else "string" == typeof e.text && (a = "\\text{" + e.text + "}");
          var r;
          return (
            "string" == typeof e.error && (a = "\\bbox[#F56165]{" + a + "}"), a
          );
        })("string" == typeof t ? JSON.parse(t) : t, e);
      },
      makeMathField: function (t, e) {
        return (
          ((e = e || {}).handleSpeak = e.handleSpeak || ji),
          (e.handleReadAloud = e.handleReadAloud || Ui),
          new Ci(Gi(t), e)
        );
      },
      renderMathInDocument: function (t) {
        Zi(document.body, t);
      },
      renderMathInElement: Zi,
      revertToOriginalContent: function (t, e) {
        (t = (t = Gi(t)).children[1]) instanceof Ci
          ? t.revertToOriginalContent()
          : (Xi((e = e || {})),
            (t.innerHTML = t.getAttribute(
              "data-" + (e.namespace || "") + "original-content"
            )));
      },
      getOriginalContent: function (t, e) {
        return (t = (t = Gi(t)).children[1]) instanceof Ci
          ? t.originalContent
          : (Xi((e = e || {})),
            t.getAttribute("data-" + (e.namespace || "") + "original-content"));
      },
      readAloud: Ui,
      readAloudStatus: function () {
        return window
          ? ((window.mathlive = window.mathlive || {}),
            window.mathlive.readAloudAudio
              ? window.mathlive.readAloudAudio.paused
                ? "paused"
                : window.mathlive.readAloudAudio.ended
                ? "ready"
                : "playing"
              : "ready")
          : "unavailable";
      },
      pauseReadAloud: function () {
        window &&
          ((window.mathlive = window.mathlive || {}),
          window.mathlive.readAloudAudio &&
            (window.mathlive.onReadAloudStatus &&
              window.mathlive.onReadAloudStatus(
                window.mathlive.readAloudMathField,
                "paused"
              ),
            window.mathlive.readAloudAudio.pause()));
      },
      resumeReadAloud: function () {
        window &&
          ((window.mathlive = window.mathlive || {}),
          window.mathlive.readAloudAudio &&
            (window.mathlive.onReadAloudStatus &&
              window.mathlive.onReadAloudStatus(
                window.mathlive.readAloudMathField,
                "playing"
              ),
            window.mathlive.readAloudAudio.play()));
      },
      playReadAloud: function (t, e) {
        if (
          window &&
          ((window.mathlive = window.mathlive || {}),
          window.mathlive.readAloudAudio)
        ) {
          let s = 0;
          if (((window.mathlive.readAloudFinalToken = null), t)) {
            window.mathlive.readAloudMarks =
              window.mathlive.readAloudMarks || [];
            for (const e of window.mathlive.readAloudMarks)
              e.value === t && (s = e.time / 1e3);
            let i = window.mathlive.readAloudTokens.indexOf(t);
            i >= 0 &&
              ((i += e),
              i < window.mathlive.readAloudTokens.length &&
                (window.mathlive.readAloudFinalToken = i));
          }
          (window.mathlive.readAloudAudio.currentTime = s),
            window.mathlive.onReadAloudStatus &&
              window.mathlive.onReadAloudStatus(
                window.mathlive.readAloudMathField,
                "playing"
              ),
            window.mathlive.readAloudAudio.play();
        }
      },
      debug: {
        getStyle: Ni.getStyle,
        getType: Ni.getType,
        spanToString: Ni.spanToString,
        hasClass: Ni.hasClass,
        latexToAsciiMath: Ni.latexToAsciiMath,
        asciiMathToLatex: Ni.asciiMathToLatex,
      },
    };
  }),
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = factory())
    : "function" == typeof define && define.amd
    ? define(factory)
    : ((global = global || self).MathLive = factory());
